["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/base/node/useSlider/useSlider.js"],"~:js","shadow$provide.module$node_modules$$mui$base$node$useSlider$useSlider = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  function asc(a, b) {\n    return a - b;\n  }\n  function findClosest(values, currentValue) {\n    var _values$reduce;\n    ({index:values} = null != (_values$reduce = values.reduce((acc, value, index) => {\n      value = Math.abs(currentValue - value);\n      return null === acc || value < acc.distance || value === acc.distance ? {distance:value, index} : acc;\n    }, null)) ? _values$reduce : {});\n    return values;\n  }\n  function trackFinger(event, touchId) {\n    if (void 0 !== touchId.current && event.changedTouches) {\n      for (let i = 0; i < event.changedTouches.length; i += 1) {\n        const touch = event.changedTouches[i];\n        if (touch.identifier === touchId.current) {\n          return {x:touch.clientX, y:touch.clientY};\n        }\n      }\n      return !1;\n    }\n    return {x:event.clientX, y:event.clientY};\n  }\n  function valueToPercent(value, min, max) {\n    return 100 * (value - min) / (max - min);\n  }\n  function setValueIndex({values, newValue, index}) {\n    values = values.slice();\n    values[index] = newValue;\n    return values.sort(asc);\n  }\n  function focusThumb({sliderRef, activeIndex, setActive}) {\n    var _sliderRef$current, _doc$activeElement;\n    const doc = (0,_utils.unstable_ownerDocument)(sliderRef.current);\n    if (null == (_sliderRef$current = sliderRef.current) || !_sliderRef$current.contains(doc.activeElement) || Number(null == doc || null == (_doc$activeElement = doc.activeElement) ? void 0 : _doc$activeElement.getAttribute(\"data-index\")) !== activeIndex) {\n      var _sliderRef$current2;\n      null == (_sliderRef$current2 = sliderRef.current) || _sliderRef$current2.querySelector(`[type=\"range\"][data-index=\"${activeIndex}\"]`).focus();\n    }\n    setActive && setActive(activeIndex);\n  }\n  function areValuesEqual(newValue, oldValue) {\n    return \"number\" === typeof newValue && \"number\" === typeof oldValue ? newValue === oldValue : \"object\" === typeof newValue && \"object\" === typeof oldValue ? (0,_utils2.areArraysEqual)(newValue, oldValue) : !1;\n  }\n  function doesSupportTouchActionNone() {\n    void 0 === cachedSupportsTouchActionNone && (cachedSupportsTouchActionNone = \"undefined\" !== typeof CSS && \"function\" === typeof CSS.supports ? CSS.supports(\"touch-action\", \"none\") : !0);\n    return cachedSupportsTouchActionNone;\n  }\n  \"use client\";\n  global = require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.Identity = void 0;\n  exports.useSlider = function(parameters) {\n    const {\"aria-labelledby\":ariaLabelledby, defaultValue, disabled = !1, disableSwap = !1, isRtl = !1, marks:marksProp = !1, max = 100, min = 0, name, onChange, onChangeCommitted, orientation = \"horizontal\", rootRef:ref, scale = Identity, step = 1, shiftStep = 10, tabIndex, value:valueProp} = parameters, touchId = React.useRef(), [active, setActive] = React.useState(-1), [open, setOpen] = React.useState(-1), [dragging, setDragging] = React.useState(!1), moveCount = React.useRef(0), [valueDerived, \n    setValueState] = (0,_utils.unstable_useControlled)({controlled:valueProp, default:null != defaultValue ? defaultValue : min, name:\"Slider\"}), handleChange = onChange && ((event, value, thumbIndex) => {\n      event = event.nativeEvent || event;\n      event = new event.constructor(event.type, event);\n      Object.defineProperty(event, \"target\", {writable:!0, value:{value, name}});\n      onChange(event, value, thumbIndex);\n    }), range = Array.isArray(valueDerived);\n    let values = range ? valueDerived.slice().sort(asc) : [valueDerived];\n    values = values.map(value => null == value ? min : (0,_utils.clamp)(value, min, max));\n    const marks = !0 === marksProp && null !== step ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({value:min + step * index})) : marksProp || [], marksValues = marks.map(mark => mark.value), {isFocusVisibleRef, onBlur:handleBlurVisible, onFocus:handleFocusVisible, ref:focusVisibleRef} = (0,_utils.unstable_useIsFocusVisible)(), [focusedThumbIndex, setFocusedThumbIndex] = React.useState(-1), sliderRef = React.useRef();\n    var handleFocusRef = (0,_utils.unstable_useForkRef)(focusVisibleRef, sliderRef);\n    const handleRef = (0,_utils.unstable_useForkRef)(ref, handleFocusRef), createHandleHiddenInputFocus = otherHandlers => event => {\n      var _otherHandlers$onFocu;\n      const index = Number(event.currentTarget.getAttribute(\"data-index\"));\n      handleFocusVisible(event);\n      !0 === isFocusVisibleRef.current && setFocusedThumbIndex(index);\n      setOpen(index);\n      null == otherHandlers || null == (_otherHandlers$onFocu = otherHandlers.onFocus) || _otherHandlers$onFocu.call(otherHandlers, event);\n    }, createHandleHiddenInputBlur = otherHandlers => event => {\n      var _otherHandlers$onBlur;\n      handleBlurVisible(event);\n      !1 === isFocusVisibleRef.current && setFocusedThumbIndex(-1);\n      setOpen(-1);\n      null == otherHandlers || null == (_otherHandlers$onBlur = otherHandlers.onBlur) || _otherHandlers$onBlur.call(otherHandlers, event);\n    }, changeValue = (event, valueInput) => {\n      const index = Number(event.currentTarget.getAttribute(\"data-index\"));\n      var value = values[index], marksIndex = marksValues.indexOf(value);\n      if (marks && null == step) {\n        const maxMarksValue = marksValues[marksValues.length - 1];\n        valueInput = valueInput > maxMarksValue ? maxMarksValue : valueInput < marksValues[0] ? marksValues[0] : valueInput < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];\n      }\n      valueInput = (0,_utils.clamp)(valueInput, min, max);\n      range && (disableSwap && (valueInput = (0,_utils.clamp)(valueInput, values[index - 1] || -Infinity, values[index + 1] || Infinity)), value = valueInput, valueInput = setValueIndex({values, newValue:valueInput, index}), marksIndex = index, disableSwap || (marksIndex = valueInput.indexOf(value)), focusThumb({sliderRef, activeIndex:marksIndex}));\n      setValueState(valueInput);\n      setFocusedThumbIndex(index);\n      handleChange && !areValuesEqual(valueInput, valueDerived) && handleChange(event, valueInput, index);\n      onChangeCommitted && onChangeCommitted(event, valueInput);\n    }, createHandleHiddenInputKeyDown = otherHandlers => event => {\n      var _otherHandlers$onKeyD;\n      if (null !== step) {\n        var index = Number(event.currentTarget.getAttribute(\"data-index\"));\n        index = values[index];\n        let newValue = null;\n        if ((\"ArrowLeft\" === event.key || \"ArrowDown\" === event.key) && event.shiftKey || \"PageDown\" === event.key) {\n          newValue = Math.max(index - shiftStep, min);\n        } else if ((\"ArrowRight\" === event.key || \"ArrowUp\" === event.key) && event.shiftKey || \"PageUp\" === event.key) {\n          newValue = Math.min(index + shiftStep, max);\n        }\n        null !== newValue && (changeValue(event, newValue), event.preventDefault());\n      }\n      null == otherHandlers || null == (_otherHandlers$onKeyD = otherHandlers.onKeyDown) || _otherHandlers$onKeyD.call(otherHandlers, event);\n    };\n    (0,_utils.unstable_useEnhancedEffect)(() => {\n      if (disabled && sliderRef.current.contains(document.activeElement)) {\n        var _document$activeEleme;\n        null == (_document$activeEleme = document.activeElement) || _document$activeEleme.blur();\n      }\n    }, [disabled]);\n    disabled && -1 !== active && setActive(-1);\n    disabled && -1 !== focusedThumbIndex && setFocusedThumbIndex(-1);\n    const createHandleHiddenInputChange = otherHandlers => event => {\n      var _otherHandlers$onChan;\n      null == (_otherHandlers$onChan = otherHandlers.onChange) || _otherHandlers$onChan.call(otherHandlers, event);\n      changeValue(event, event.target.valueAsNumber);\n    }, previousIndex = React.useRef();\n    let axis = orientation;\n    isRtl && \"horizontal\" === orientation && (axis += \"-reverse\");\n    const getFingerNewValue = ({finger, move = !1}) => {\n      var {current:slider} = sliderRef;\n      const {width, height, bottom, left} = slider.getBoundingClientRect();\n      finger = 0 === axis.indexOf(\"vertical\") ? (bottom - finger.y) / height : (finger.x - left) / width;\n      -1 !== axis.indexOf(\"-reverse\") && (finger = 1 - finger);\n      slider = (max - min) * finger + min;\n      if (step) {\n        finger = Number;\n        slider = Math.round((slider - min) / step) * step + min;\n        var JSCompiler_temp_const = slider.toFixed;\n        if (1 > Math.abs(step)) {\n          var JSCompiler_inline_result = step.toExponential().split(\"e-\");\n          const matissaDecimalPart = JSCompiler_inline_result[0].split(\".\")[1];\n          JSCompiler_inline_result = (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(JSCompiler_inline_result[1], 10);\n        } else {\n          JSCompiler_inline_result = (JSCompiler_inline_result = step.toString().split(\".\")[1]) ? JSCompiler_inline_result.length : 0;\n        }\n        slider = finger(JSCompiler_temp_const.call(slider, JSCompiler_inline_result));\n      } else {\n        finger = findClosest(marksValues, slider), slider = marksValues[finger];\n      }\n      slider = (0,_utils.clamp)(slider, min, max);\n      finger = 0;\n      range && (finger = move ? previousIndex.current : findClosest(values, slider), disableSwap && (slider = (0,_utils.clamp)(slider, values[finger - 1] || -Infinity, values[finger + 1] || Infinity)), JSCompiler_temp_const = slider, slider = setValueIndex({values, newValue:slider, index:finger}), disableSwap && move || (finger = slider.indexOf(JSCompiler_temp_const), previousIndex.current = finger));\n      return {newValue:slider, activeIndex:finger};\n    }, handleTouchMove = (0,_utils.unstable_useEventCallback)(nativeEvent => {\n      const finger = trackFinger(nativeEvent, touchId);\n      if (finger) {\n        if (moveCount.current += 1, \"mousemove\" === nativeEvent.type && 0 === nativeEvent.buttons) {\n          handleTouchEnd(nativeEvent);\n        } else {\n          var {newValue, activeIndex} = getFingerNewValue({finger, move:!0});\n          focusThumb({sliderRef, activeIndex, setActive});\n          setValueState(newValue);\n          !dragging && 2 < moveCount.current && setDragging(!0);\n          handleChange && !areValuesEqual(newValue, valueDerived) && handleChange(nativeEvent, newValue, activeIndex);\n        }\n      }\n    }), handleTouchEnd = (0,_utils.unstable_useEventCallback)(nativeEvent => {\n      var finger = trackFinger(nativeEvent, touchId);\n      setDragging(!1);\n      finger && ({newValue:finger} = getFingerNewValue({finger, move:!0}), setActive(-1), \"touchend\" === nativeEvent.type && setOpen(-1), onChangeCommitted && onChangeCommitted(nativeEvent, finger), touchId.current = void 0, stopListening());\n    }), handleTouchStart = (0,_utils.unstable_useEventCallback)(nativeEvent => {\n      if (!disabled) {\n        doesSupportTouchActionNone() || nativeEvent.preventDefault();\n        var touch = nativeEvent.changedTouches[0];\n        null != touch && (touchId.current = touch.identifier);\n        touch = trackFinger(nativeEvent, touchId);\n        if (!1 !== touch) {\n          const {newValue, activeIndex} = getFingerNewValue({finger:touch});\n          focusThumb({sliderRef, activeIndex, setActive});\n          setValueState(newValue);\n          handleChange && !areValuesEqual(newValue, valueDerived) && handleChange(nativeEvent, newValue, activeIndex);\n        }\n        moveCount.current = 0;\n        nativeEvent = (0,_utils.unstable_ownerDocument)(sliderRef.current);\n        nativeEvent.addEventListener(\"touchmove\", handleTouchMove, {passive:!0});\n        nativeEvent.addEventListener(\"touchend\", handleTouchEnd, {passive:!0});\n      }\n    }), stopListening = React.useCallback(() => {\n      const doc = (0,_utils.unstable_ownerDocument)(sliderRef.current);\n      doc.removeEventListener(\"mousemove\", handleTouchMove);\n      doc.removeEventListener(\"mouseup\", handleTouchEnd);\n      doc.removeEventListener(\"touchmove\", handleTouchMove);\n      doc.removeEventListener(\"touchend\", handleTouchEnd);\n    }, [handleTouchEnd, handleTouchMove]);\n    React.useEffect(() => {\n      const {current:slider} = sliderRef;\n      slider.addEventListener(\"touchstart\", handleTouchStart, {passive:doesSupportTouchActionNone()});\n      return () => {\n        slider.removeEventListener(\"touchstart\", handleTouchStart);\n        stopListening();\n      };\n    }, [stopListening, handleTouchStart]);\n    React.useEffect(() => {\n      disabled && stopListening();\n    }, [disabled, stopListening]);\n    const createHandleMouseDown = otherHandlers => event => {\n      var _otherHandlers$onMous;\n      null == (_otherHandlers$onMous = otherHandlers.onMouseDown) || _otherHandlers$onMous.call(otherHandlers, event);\n      if (!disabled && !event.defaultPrevented && 0 === event.button) {\n        event.preventDefault();\n        _otherHandlers$onMous = trackFinger(event, touchId);\n        if (!1 !== _otherHandlers$onMous) {\n          const {newValue, activeIndex} = getFingerNewValue({finger:_otherHandlers$onMous});\n          focusThumb({sliderRef, activeIndex, setActive});\n          setValueState(newValue);\n          handleChange && !areValuesEqual(newValue, valueDerived) && handleChange(event, newValue, activeIndex);\n        }\n        moveCount.current = 0;\n        event = (0,_utils.unstable_ownerDocument)(sliderRef.current);\n        event.addEventListener(\"mousemove\", handleTouchMove, {passive:!0});\n        event.addEventListener(\"mouseup\", handleTouchEnd);\n      }\n    };\n    handleFocusRef = valueToPercent(range ? values[0] : min, min, max);\n    const trackLeap = valueToPercent(values[values.length - 1], min, max) - handleFocusRef, createHandleMouseOver = otherHandlers => event => {\n      var _otherHandlers$onMous2;\n      null == (_otherHandlers$onMous2 = otherHandlers.onMouseOver) || _otherHandlers$onMous2.call(otherHandlers, event);\n      event = Number(event.currentTarget.getAttribute(\"data-index\"));\n      setOpen(event);\n    }, createHandleMouseLeave = otherHandlers => event => {\n      var _otherHandlers$onMous3;\n      null == (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) || _otherHandlers$onMous3.call(otherHandlers, event);\n      setOpen(-1);\n    };\n    return {active, axis, axisProps, dragging, focusedThumbIndex, getHiddenInputProps:(externalProps = {}) => {\n      var _parameters$step, externalHandlers = (0,_utils2.extractEventHandlers)(externalProps);\n      const ownEventHandlers = {onChange:createHandleHiddenInputChange(externalHandlers || {}), onFocus:createHandleHiddenInputFocus(externalHandlers || {}), onBlur:createHandleHiddenInputBlur(externalHandlers || {}), onKeyDown:createHandleHiddenInputKeyDown(externalHandlers || {})};\n      externalHandlers = (0,_extends2.default)({}, externalHandlers, ownEventHandlers);\n      return (0,_extends2.default)({tabIndex, \"aria-labelledby\":ariaLabelledby, \"aria-orientation\":orientation, \"aria-valuemax\":scale(max), \"aria-valuemin\":scale(min), name, type:\"range\", min:parameters.min, max:parameters.max, step:null === parameters.step && parameters.marks ? \"any\" : null != (_parameters$step = parameters.step) ? _parameters$step : void 0, disabled}, externalProps, externalHandlers, {style:(0,_extends2.default)({}, _utils.visuallyHidden, {direction:isRtl ? \"rtl\" : \"ltr\", width:\"100%\", \n      height:\"100%\"})});\n    }, getRootProps:(externalProps = {}) => {\n      var externalHandlers = (0,_utils2.extractEventHandlers)(externalProps);\n      const ownEventHandlers = {onMouseDown:createHandleMouseDown(externalHandlers || {})};\n      externalHandlers = (0,_extends2.default)({}, externalHandlers, ownEventHandlers);\n      return (0,_extends2.default)({}, externalProps, {ref:handleRef}, externalHandlers);\n    }, getThumbProps:(externalProps = {}) => {\n      const externalHandlers = (0,_utils2.extractEventHandlers)(externalProps), ownEventHandlers = {onMouseOver:createHandleMouseOver(externalHandlers || {}), onMouseLeave:createHandleMouseLeave(externalHandlers || {})};\n      return (0,_extends2.default)({}, externalProps, externalHandlers, ownEventHandlers);\n    }, marks, open, range, rootRef:handleRef, trackLeap, trackOffset:handleFocusRef, values, getThumbStyle:index => ({pointerEvents:-1 !== active && active !== index ? \"none\" : void 0})};\n  };\n  exports.valueToPercent = valueToPercent;\n  var _extends2 = global(require(\"module$node_modules$$babel$runtime$helpers$extends\")), React = function(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }(require(\"module$node_modules$react$index\")), _utils = require(\"module$node_modules$$mui$utils$node$index\"), _utils2 = require(\"module$node_modules$$mui$base$node$utils$index\");\n  const axisProps = {horizontal:{offset:percent => ({left:`${percent}%`}), leap:percent => ({width:`${percent}%`})}, \"horizontal-reverse\":{offset:percent => ({right:`${percent}%`}), leap:percent => ({width:`${percent}%`})}, vertical:{offset:percent => ({bottom:`${percent}%`}), leap:percent => ({height:`${percent}%`})}}, Identity = x => x;\n  exports.Identity = Identity;\n  let cachedSupportsTouchActionNone;\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$base$node$useSlider$useSlider\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Identity = void 0;\nexports.useSlider = useSlider;\nexports.valueToPercent = valueToPercent;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _utils = require(\"@mui/utils\");\nvar _utils2 = require(\"../utils\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;\nfunction asc(a, b) {\n  return a - b;\n}\nfunction findClosest(values, currentValue) {\n  var _values$reduce;\n  const {\n    index: closestIndex\n  } = (_values$reduce = values.reduce((acc, value, index) => {\n    const distance = Math.abs(currentValue - value);\n    if (acc === null || distance < acc.distance || distance === acc.distance) {\n      return {\n        distance,\n        index\n      };\n    }\n    return acc;\n  }, null)) != null ? _values$reduce : {};\n  return closestIndex;\n}\nfunction trackFinger(event, touchId) {\n  // The event is TouchEvent\n  if (touchId.current !== undefined && event.changedTouches) {\n    const touchEvent = event;\n    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {\n      const touch = touchEvent.changedTouches[i];\n      if (touch.identifier === touchId.current) {\n        return {\n          x: touch.clientX,\n          y: touch.clientY\n        };\n      }\n    }\n    return false;\n  }\n\n  // The event is MouseEvent\n  return {\n    x: event.clientX,\n    y: event.clientY\n  };\n}\nfunction valueToPercent(value, min, max) {\n  return (value - min) * 100 / (max - min);\n}\nfunction percentToValue(percent, min, max) {\n  return (max - min) * percent + min;\n}\nfunction getDecimalPrecision(num) {\n  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.\n  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.\n  if (Math.abs(num) < 1) {\n    const parts = num.toExponential().split('e-');\n    const matissaDecimalPart = parts[0].split('.')[1];\n    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);\n  }\n  const decimalPart = num.toString().split('.')[1];\n  return decimalPart ? decimalPart.length : 0;\n}\nfunction roundValueToStep(value, step, min) {\n  const nearest = Math.round((value - min) / step) * step + min;\n  return Number(nearest.toFixed(getDecimalPrecision(step)));\n}\nfunction setValueIndex({\n  values,\n  newValue,\n  index\n}) {\n  const output = values.slice();\n  output[index] = newValue;\n  return output.sort(asc);\n}\nfunction focusThumb({\n  sliderRef,\n  activeIndex,\n  setActive\n}) {\n  var _sliderRef$current, _doc$activeElement;\n  const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\n  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null || (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {\n    var _sliderRef$current2;\n    (_sliderRef$current2 = sliderRef.current) == null || _sliderRef$current2.querySelector(`[type=\"range\"][data-index=\"${activeIndex}\"]`).focus();\n  }\n  if (setActive) {\n    setActive(activeIndex);\n  }\n}\nfunction areValuesEqual(newValue, oldValue) {\n  if (typeof newValue === 'number' && typeof oldValue === 'number') {\n    return newValue === oldValue;\n  }\n  if (typeof newValue === 'object' && typeof oldValue === 'object') {\n    return (0, _utils2.areArraysEqual)(newValue, oldValue);\n  }\n  return false;\n}\nconst axisProps = {\n  horizontal: {\n    offset: percent => ({\n      left: `${percent}%`\n    }),\n    leap: percent => ({\n      width: `${percent}%`\n    })\n  },\n  'horizontal-reverse': {\n    offset: percent => ({\n      right: `${percent}%`\n    }),\n    leap: percent => ({\n      width: `${percent}%`\n    })\n  },\n  vertical: {\n    offset: percent => ({\n      bottom: `${percent}%`\n    }),\n    leap: percent => ({\n      height: `${percent}%`\n    })\n  }\n};\nconst Identity = x => x;\n\n// TODO: remove support for Safari < 13.\n// https://caniuse.com/#search=touch-action\n//\n// Safari, on iOS, supports touch action since v13.\n// Over 80% of the iOS phones are compatible\n// in August 2020.\n// Utilizing the CSS.supports method to check if touch-action is supported.\n// Since CSS.supports is supported on all but Edge@12 and IE and touch-action\n// is supported on both Edge@12 and IE if CSS.supports is not available that means that\n// touch-action will be supported\nexports.Identity = Identity;\nlet cachedSupportsTouchActionNone;\nfunction doesSupportTouchActionNone() {\n  if (cachedSupportsTouchActionNone === undefined) {\n    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {\n      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');\n    } else {\n      cachedSupportsTouchActionNone = true;\n    }\n  }\n  return cachedSupportsTouchActionNone;\n}\n/**\n *\n * Demos:\n *\n * - [Slider](https://mui.com/base-ui/react-slider/#hook)\n *\n * API:\n *\n * - [useSlider API](https://mui.com/base-ui/react-slider/hooks-api/#use-slider)\n */\nfunction useSlider(parameters) {\n  const {\n    'aria-labelledby': ariaLabelledby,\n    defaultValue,\n    disabled = false,\n    disableSwap = false,\n    isRtl = false,\n    marks: marksProp = false,\n    max = 100,\n    min = 0,\n    name,\n    onChange,\n    onChangeCommitted,\n    orientation = 'horizontal',\n    rootRef: ref,\n    scale = Identity,\n    step = 1,\n    shiftStep = 10,\n    tabIndex,\n    value: valueProp\n  } = parameters;\n  const touchId = React.useRef();\n  // We can't use the :active browser pseudo-classes.\n  // - The active state isn't triggered when clicking on the rail.\n  // - The active state isn't transferred when inversing a range slider.\n  const [active, setActive] = React.useState(-1);\n  const [open, setOpen] = React.useState(-1);\n  const [dragging, setDragging] = React.useState(false);\n  const moveCount = React.useRef(0);\n  const [valueDerived, setValueState] = (0, _utils.unstable_useControlled)({\n    controlled: valueProp,\n    default: defaultValue != null ? defaultValue : min,\n    name: 'Slider'\n  });\n  const handleChange = onChange && ((event, value, thumbIndex) => {\n    // Redefine target to allow name and value to be read.\n    // This allows seamless integration with the most popular form libraries.\n    // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492\n    // Clone the event to not override `target` of the original event.\n    const nativeEvent = event.nativeEvent || event;\n    // @ts-ignore The nativeEvent is function, not object\n    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\n    Object.defineProperty(clonedEvent, 'target', {\n      writable: true,\n      value: {\n        value,\n        name\n      }\n    });\n    onChange(clonedEvent, value, thumbIndex);\n  });\n  const range = Array.isArray(valueDerived);\n  let values = range ? valueDerived.slice().sort(asc) : [valueDerived];\n  values = values.map(value => value == null ? min : (0, _utils.clamp)(value, min, max));\n  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({\n    value: min + step * index\n  })) : marksProp || [];\n  const marksValues = marks.map(mark => mark.value);\n  const {\n    isFocusVisibleRef,\n    onBlur: handleBlurVisible,\n    onFocus: handleFocusVisible,\n    ref: focusVisibleRef\n  } = (0, _utils.unstable_useIsFocusVisible)();\n  const [focusedThumbIndex, setFocusedThumbIndex] = React.useState(-1);\n  const sliderRef = React.useRef();\n  const handleFocusRef = (0, _utils.unstable_useForkRef)(focusVisibleRef, sliderRef);\n  const handleRef = (0, _utils.unstable_useForkRef)(ref, handleFocusRef);\n  const createHandleHiddenInputFocus = otherHandlers => event => {\n    var _otherHandlers$onFocu;\n    const index = Number(event.currentTarget.getAttribute('data-index'));\n    handleFocusVisible(event);\n    if (isFocusVisibleRef.current === true) {\n      setFocusedThumbIndex(index);\n    }\n    setOpen(index);\n    otherHandlers == null || (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);\n  };\n  const createHandleHiddenInputBlur = otherHandlers => event => {\n    var _otherHandlers$onBlur;\n    handleBlurVisible(event);\n    if (isFocusVisibleRef.current === false) {\n      setFocusedThumbIndex(-1);\n    }\n    setOpen(-1);\n    otherHandlers == null || (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);\n  };\n  const changeValue = (event, valueInput) => {\n    const index = Number(event.currentTarget.getAttribute('data-index'));\n    const value = values[index];\n    const marksIndex = marksValues.indexOf(value);\n    let newValue = valueInput;\n    if (marks && step == null) {\n      const maxMarksValue = marksValues[marksValues.length - 1];\n      if (newValue > maxMarksValue) {\n        newValue = maxMarksValue;\n      } else if (newValue < marksValues[0]) {\n        newValue = marksValues[0];\n      } else {\n        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];\n      }\n    }\n    newValue = (0, _utils.clamp)(newValue, min, max);\n    if (range) {\n      // Bound the new value to the thumb's neighbours.\n      if (disableSwap) {\n        newValue = (0, _utils.clamp)(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);\n      }\n      const previousValue = newValue;\n      newValue = setValueIndex({\n        values,\n        newValue,\n        index\n      });\n      let activeIndex = index;\n\n      // Potentially swap the index if needed.\n      if (!disableSwap) {\n        activeIndex = newValue.indexOf(previousValue);\n      }\n      focusThumb({\n        sliderRef,\n        activeIndex\n      });\n    }\n    setValueState(newValue);\n    setFocusedThumbIndex(index);\n    if (handleChange && !areValuesEqual(newValue, valueDerived)) {\n      handleChange(event, newValue, index);\n    }\n    if (onChangeCommitted) {\n      onChangeCommitted(event, newValue);\n    }\n  };\n  const createHandleHiddenInputKeyDown = otherHandlers => event => {\n    var _otherHandlers$onKeyD;\n    // The Shift + Up/Down keyboard shortcuts for moving the slider makes sense to be supported\n    // only if the step is defined. If the step is null, this means tha the marks are used for specifying the valid values.\n    if (step !== null) {\n      const index = Number(event.currentTarget.getAttribute('data-index'));\n      const value = values[index];\n      let newValue = null;\n      if ((event.key === 'ArrowLeft' || event.key === 'ArrowDown') && event.shiftKey || event.key === 'PageDown') {\n        newValue = Math.max(value - shiftStep, min);\n      } else if ((event.key === 'ArrowRight' || event.key === 'ArrowUp') && event.shiftKey || event.key === 'PageUp') {\n        newValue = Math.min(value + shiftStep, max);\n      }\n      if (newValue !== null) {\n        changeValue(event, newValue);\n        event.preventDefault();\n      }\n    }\n    otherHandlers == null || (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);\n  };\n  (0, _utils.unstable_useEnhancedEffect)(() => {\n    if (disabled && sliderRef.current.contains(document.activeElement)) {\n      var _document$activeEleme;\n      // This is necessary because Firefox and Safari will keep focus\n      // on a disabled element:\n      // https://codesandbox.io/p/sandbox/mui-pr-22247-forked-h151h?file=/src/App.js\n      // @ts-ignore\n      (_document$activeEleme = document.activeElement) == null || _document$activeEleme.blur();\n    }\n  }, [disabled]);\n  if (disabled && active !== -1) {\n    setActive(-1);\n  }\n  if (disabled && focusedThumbIndex !== -1) {\n    setFocusedThumbIndex(-1);\n  }\n  const createHandleHiddenInputChange = otherHandlers => event => {\n    var _otherHandlers$onChan;\n    (_otherHandlers$onChan = otherHandlers.onChange) == null || _otherHandlers$onChan.call(otherHandlers, event);\n    // @ts-ignore\n    changeValue(event, event.target.valueAsNumber);\n  };\n  const previousIndex = React.useRef();\n  let axis = orientation;\n  if (isRtl && orientation === 'horizontal') {\n    axis += '-reverse';\n  }\n  const getFingerNewValue = ({\n    finger,\n    move = false\n  }) => {\n    const {\n      current: slider\n    } = sliderRef;\n    const {\n      width,\n      height,\n      bottom,\n      left\n    } = slider.getBoundingClientRect();\n    let percent;\n    if (axis.indexOf('vertical') === 0) {\n      percent = (bottom - finger.y) / height;\n    } else {\n      percent = (finger.x - left) / width;\n    }\n    if (axis.indexOf('-reverse') !== -1) {\n      percent = 1 - percent;\n    }\n    let newValue;\n    newValue = percentToValue(percent, min, max);\n    if (step) {\n      newValue = roundValueToStep(newValue, step, min);\n    } else {\n      const closestIndex = findClosest(marksValues, newValue);\n      newValue = marksValues[closestIndex];\n    }\n    newValue = (0, _utils.clamp)(newValue, min, max);\n    let activeIndex = 0;\n    if (range) {\n      if (!move) {\n        activeIndex = findClosest(values, newValue);\n      } else {\n        activeIndex = previousIndex.current;\n      }\n\n      // Bound the new value to the thumb's neighbours.\n      if (disableSwap) {\n        newValue = (0, _utils.clamp)(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);\n      }\n      const previousValue = newValue;\n      newValue = setValueIndex({\n        values,\n        newValue,\n        index: activeIndex\n      });\n\n      // Potentially swap the index if needed.\n      if (!(disableSwap && move)) {\n        activeIndex = newValue.indexOf(previousValue);\n        previousIndex.current = activeIndex;\n      }\n    }\n    return {\n      newValue,\n      activeIndex\n    };\n  };\n  const handleTouchMove = (0, _utils.unstable_useEventCallback)(nativeEvent => {\n    const finger = trackFinger(nativeEvent, touchId);\n    if (!finger) {\n      return;\n    }\n    moveCount.current += 1;\n\n    // Cancel move in case some other element consumed a mouseup event and it was not fired.\n    // @ts-ignore buttons doesn't not exists on touch event\n    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      handleTouchEnd(nativeEvent);\n      return;\n    }\n    const {\n      newValue,\n      activeIndex\n    } = getFingerNewValue({\n      finger,\n      move: true\n    });\n    focusThumb({\n      sliderRef,\n      activeIndex,\n      setActive\n    });\n    setValueState(newValue);\n    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {\n      setDragging(true);\n    }\n    if (handleChange && !areValuesEqual(newValue, valueDerived)) {\n      handleChange(nativeEvent, newValue, activeIndex);\n    }\n  });\n  const handleTouchEnd = (0, _utils.unstable_useEventCallback)(nativeEvent => {\n    const finger = trackFinger(nativeEvent, touchId);\n    setDragging(false);\n    if (!finger) {\n      return;\n    }\n    const {\n      newValue\n    } = getFingerNewValue({\n      finger,\n      move: true\n    });\n    setActive(-1);\n    if (nativeEvent.type === 'touchend') {\n      setOpen(-1);\n    }\n    if (onChangeCommitted) {\n      onChangeCommitted(nativeEvent, newValue);\n    }\n    touchId.current = undefined;\n\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    stopListening();\n  });\n  const handleTouchStart = (0, _utils.unstable_useEventCallback)(nativeEvent => {\n    if (disabled) {\n      return;\n    }\n    // If touch-action: none; is not supported we need to prevent the scroll manually.\n    if (!doesSupportTouchActionNone()) {\n      nativeEvent.preventDefault();\n    }\n    const touch = nativeEvent.changedTouches[0];\n    if (touch != null) {\n      // A number that uniquely identifies the current finger in the touch session.\n      touchId.current = touch.identifier;\n    }\n    const finger = trackFinger(nativeEvent, touchId);\n    if (finger !== false) {\n      const {\n        newValue,\n        activeIndex\n      } = getFingerNewValue({\n        finger\n      });\n      focusThumb({\n        sliderRef,\n        activeIndex,\n        setActive\n      });\n      setValueState(newValue);\n      if (handleChange && !areValuesEqual(newValue, valueDerived)) {\n        handleChange(nativeEvent, newValue, activeIndex);\n      }\n    }\n    moveCount.current = 0;\n    const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\n    doc.addEventListener('touchmove', handleTouchMove, {\n      passive: true\n    });\n    doc.addEventListener('touchend', handleTouchEnd, {\n      passive: true\n    });\n  });\n  const stopListening = React.useCallback(() => {\n    const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\n    doc.removeEventListener('mousemove', handleTouchMove);\n    doc.removeEventListener('mouseup', handleTouchEnd);\n    doc.removeEventListener('touchmove', handleTouchMove);\n    doc.removeEventListener('touchend', handleTouchEnd);\n  }, [handleTouchEnd, handleTouchMove]);\n  React.useEffect(() => {\n    const {\n      current: slider\n    } = sliderRef;\n    slider.addEventListener('touchstart', handleTouchStart, {\n      passive: doesSupportTouchActionNone()\n    });\n    return () => {\n      slider.removeEventListener('touchstart', handleTouchStart);\n      stopListening();\n    };\n  }, [stopListening, handleTouchStart]);\n  React.useEffect(() => {\n    if (disabled) {\n      stopListening();\n    }\n  }, [disabled, stopListening]);\n  const createHandleMouseDown = otherHandlers => event => {\n    var _otherHandlers$onMous;\n    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null || _otherHandlers$onMous.call(otherHandlers, event);\n    if (disabled) {\n      return;\n    }\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    // Only handle left clicks\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Avoid text selection\n    event.preventDefault();\n    const finger = trackFinger(event, touchId);\n    if (finger !== false) {\n      const {\n        newValue,\n        activeIndex\n      } = getFingerNewValue({\n        finger\n      });\n      focusThumb({\n        sliderRef,\n        activeIndex,\n        setActive\n      });\n      setValueState(newValue);\n      if (handleChange && !areValuesEqual(newValue, valueDerived)) {\n        handleChange(event, newValue, activeIndex);\n      }\n    }\n    moveCount.current = 0;\n    const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\n    doc.addEventListener('mousemove', handleTouchMove, {\n      passive: true\n    });\n    doc.addEventListener('mouseup', handleTouchEnd);\n  };\n  const trackOffset = valueToPercent(range ? values[0] : min, min, max);\n  const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;\n  const getRootProps = (externalProps = {}) => {\n    const externalHandlers = (0, _utils2.extractEventHandlers)(externalProps);\n    const ownEventHandlers = {\n      onMouseDown: createHandleMouseDown(externalHandlers || {})\n    };\n    const mergedEventHandlers = (0, _extends2.default)({}, externalHandlers, ownEventHandlers);\n    return (0, _extends2.default)({}, externalProps, {\n      ref: handleRef\n    }, mergedEventHandlers);\n  };\n  const createHandleMouseOver = otherHandlers => event => {\n    var _otherHandlers$onMous2;\n    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null || _otherHandlers$onMous2.call(otherHandlers, event);\n    const index = Number(event.currentTarget.getAttribute('data-index'));\n    setOpen(index);\n  };\n  const createHandleMouseLeave = otherHandlers => event => {\n    var _otherHandlers$onMous3;\n    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null || _otherHandlers$onMous3.call(otherHandlers, event);\n    setOpen(-1);\n  };\n  const getThumbProps = (externalProps = {}) => {\n    const externalHandlers = (0, _utils2.extractEventHandlers)(externalProps);\n    const ownEventHandlers = {\n      onMouseOver: createHandleMouseOver(externalHandlers || {}),\n      onMouseLeave: createHandleMouseLeave(externalHandlers || {})\n    };\n    return (0, _extends2.default)({}, externalProps, externalHandlers, ownEventHandlers);\n  };\n  const getThumbStyle = index => {\n    return {\n      // So the non active thumb doesn't show its label on hover.\n      pointerEvents: active !== -1 && active !== index ? 'none' : undefined\n    };\n  };\n  const getHiddenInputProps = (externalProps = {}) => {\n    var _parameters$step;\n    const externalHandlers = (0, _utils2.extractEventHandlers)(externalProps);\n    const ownEventHandlers = {\n      onChange: createHandleHiddenInputChange(externalHandlers || {}),\n      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),\n      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),\n      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})\n    };\n    const mergedEventHandlers = (0, _extends2.default)({}, externalHandlers, ownEventHandlers);\n    return (0, _extends2.default)({\n      tabIndex,\n      'aria-labelledby': ariaLabelledby,\n      'aria-orientation': orientation,\n      'aria-valuemax': scale(max),\n      'aria-valuemin': scale(min),\n      name,\n      type: 'range',\n      min: parameters.min,\n      max: parameters.max,\n      step: parameters.step === null && parameters.marks ? 'any' : (_parameters$step = parameters.step) != null ? _parameters$step : undefined,\n      disabled\n    }, externalProps, mergedEventHandlers, {\n      style: (0, _extends2.default)({}, _utils.visuallyHidden, {\n        direction: isRtl ? 'rtl' : 'ltr',\n        // So that VoiceOver's focus indicator matches the thumb's dimensions\n        width: '100%',\n        height: '100%'\n      })\n    });\n  };\n  return {\n    active,\n    axis: axis,\n    axisProps,\n    dragging,\n    focusedThumbIndex,\n    getHiddenInputProps,\n    getRootProps,\n    getThumbProps,\n    marks: marks,\n    open,\n    range,\n    rootRef: handleRef,\n    trackLeap,\n    trackOffset,\n    values,\n    getThumbStyle\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$mui$base$node$utils$index","~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$$babel$runtime$helpers$extends","~$module$node_modules$$mui$utils$node$index"]],"~:properties",["^5",["focusedThumbIndex","range","sliderRef","values","leap","min","rootRef","width","right","passive","index","onChange","offset","finger","height","valueToPercent","getHiddenInputProps","tabIndex","dragging","getRootProps","x","__esModule","max","axis","vertical","newValue","marks","onMouseLeave","onMouseDown","controlled","activeIndex","name","style","value","useSlider","direction","onFocus","writable","distance","current","onBlur","move","type","Identity","y","getThumbStyle","horizontal","trackLeap","ref","__proto__","target","bottom","onKeyDown","axisProps","active","setActive","open","disabled","onMouseOver","default","left","pointerEvents","getThumbProps","trackOffset","step"]],"~:compiled-at",1712152511322,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$base$node$useSlider$useSlider.js\",\n\"lineCount\":276,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/base/node/useSlider/useSlider.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$base$node$useSlider$useSlider\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Identity = void 0;\\nexports.useSlider = useSlider;\\nexports.valueToPercent = valueToPercent;\\nvar _extends2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/extends\\\"));\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar _utils = require(\\\"@mui/utils\\\");\\nvar _utils2 = require(\\\"../utils\\\");\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\nconst INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;\\nfunction asc(a, b) {\\n  return a - b;\\n}\\nfunction findClosest(values, currentValue) {\\n  var _values$reduce;\\n  const {\\n    index: closestIndex\\n  } = (_values$reduce = values.reduce((acc, value, index) => {\\n    const distance = Math.abs(currentValue - value);\\n    if (acc === null || distance < acc.distance || distance === acc.distance) {\\n      return {\\n        distance,\\n        index\\n      };\\n    }\\n    return acc;\\n  }, null)) != null ? _values$reduce : {};\\n  return closestIndex;\\n}\\nfunction trackFinger(event, touchId) {\\n  // The event is TouchEvent\\n  if (touchId.current !== undefined && event.changedTouches) {\\n    const touchEvent = event;\\n    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {\\n      const touch = touchEvent.changedTouches[i];\\n      if (touch.identifier === touchId.current) {\\n        return {\\n          x: touch.clientX,\\n          y: touch.clientY\\n        };\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // The event is MouseEvent\\n  return {\\n    x: event.clientX,\\n    y: event.clientY\\n  };\\n}\\nfunction valueToPercent(value, min, max) {\\n  return (value - min) * 100 / (max - min);\\n}\\nfunction percentToValue(percent, min, max) {\\n  return (max - min) * percent + min;\\n}\\nfunction getDecimalPrecision(num) {\\n  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.\\n  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.\\n  if (Math.abs(num) < 1) {\\n    const parts = num.toExponential().split('e-');\\n    const matissaDecimalPart = parts[0].split('.')[1];\\n    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);\\n  }\\n  const decimalPart = num.toString().split('.')[1];\\n  return decimalPart ? decimalPart.length : 0;\\n}\\nfunction roundValueToStep(value, step, min) {\\n  const nearest = Math.round((value - min) / step) * step + min;\\n  return Number(nearest.toFixed(getDecimalPrecision(step)));\\n}\\nfunction setValueIndex({\\n  values,\\n  newValue,\\n  index\\n}) {\\n  const output = values.slice();\\n  output[index] = newValue;\\n  return output.sort(asc);\\n}\\nfunction focusThumb({\\n  sliderRef,\\n  activeIndex,\\n  setActive\\n}) {\\n  var _sliderRef$current, _doc$activeElement;\\n  const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\\n  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null || (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {\\n    var _sliderRef$current2;\\n    (_sliderRef$current2 = sliderRef.current) == null || _sliderRef$current2.querySelector(`[type=\\\"range\\\"][data-index=\\\"${activeIndex}\\\"]`).focus();\\n  }\\n  if (setActive) {\\n    setActive(activeIndex);\\n  }\\n}\\nfunction areValuesEqual(newValue, oldValue) {\\n  if (typeof newValue === 'number' && typeof oldValue === 'number') {\\n    return newValue === oldValue;\\n  }\\n  if (typeof newValue === 'object' && typeof oldValue === 'object') {\\n    return (0, _utils2.areArraysEqual)(newValue, oldValue);\\n  }\\n  return false;\\n}\\nconst axisProps = {\\n  horizontal: {\\n    offset: percent => ({\\n      left: `${percent}%`\\n    }),\\n    leap: percent => ({\\n      width: `${percent}%`\\n    })\\n  },\\n  'horizontal-reverse': {\\n    offset: percent => ({\\n      right: `${percent}%`\\n    }),\\n    leap: percent => ({\\n      width: `${percent}%`\\n    })\\n  },\\n  vertical: {\\n    offset: percent => ({\\n      bottom: `${percent}%`\\n    }),\\n    leap: percent => ({\\n      height: `${percent}%`\\n    })\\n  }\\n};\\nconst Identity = x => x;\\n\\n// TODO: remove support for Safari < 13.\\n// https://caniuse.com/#search=touch-action\\n//\\n// Safari, on iOS, supports touch action since v13.\\n// Over 80% of the iOS phones are compatible\\n// in August 2020.\\n// Utilizing the CSS.supports method to check if touch-action is supported.\\n// Since CSS.supports is supported on all but Edge@12 and IE and touch-action\\n// is supported on both Edge@12 and IE if CSS.supports is not available that means that\\n// touch-action will be supported\\nexports.Identity = Identity;\\nlet cachedSupportsTouchActionNone;\\nfunction doesSupportTouchActionNone() {\\n  if (cachedSupportsTouchActionNone === undefined) {\\n    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {\\n      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');\\n    } else {\\n      cachedSupportsTouchActionNone = true;\\n    }\\n  }\\n  return cachedSupportsTouchActionNone;\\n}\\n/**\\n *\\n * Demos:\\n *\\n * - [Slider](https://mui.com/base-ui/react-slider/#hook)\\n *\\n * API:\\n *\\n * - [useSlider API](https://mui.com/base-ui/react-slider/hooks-api/#use-slider)\\n */\\nfunction useSlider(parameters) {\\n  const {\\n    'aria-labelledby': ariaLabelledby,\\n    defaultValue,\\n    disabled = false,\\n    disableSwap = false,\\n    isRtl = false,\\n    marks: marksProp = false,\\n    max = 100,\\n    min = 0,\\n    name,\\n    onChange,\\n    onChangeCommitted,\\n    orientation = 'horizontal',\\n    rootRef: ref,\\n    scale = Identity,\\n    step = 1,\\n    shiftStep = 10,\\n    tabIndex,\\n    value: valueProp\\n  } = parameters;\\n  const touchId = React.useRef();\\n  // We can't use the :active browser pseudo-classes.\\n  // - The active state isn't triggered when clicking on the rail.\\n  // - The active state isn't transferred when inversing a range slider.\\n  const [active, setActive] = React.useState(-1);\\n  const [open, setOpen] = React.useState(-1);\\n  const [dragging, setDragging] = React.useState(false);\\n  const moveCount = React.useRef(0);\\n  const [valueDerived, setValueState] = (0, _utils.unstable_useControlled)({\\n    controlled: valueProp,\\n    default: defaultValue != null ? defaultValue : min,\\n    name: 'Slider'\\n  });\\n  const handleChange = onChange && ((event, value, thumbIndex) => {\\n    // Redefine target to allow name and value to be read.\\n    // This allows seamless integration with the most popular form libraries.\\n    // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492\\n    // Clone the event to not override `target` of the original event.\\n    const nativeEvent = event.nativeEvent || event;\\n    // @ts-ignore The nativeEvent is function, not object\\n    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\\n    Object.defineProperty(clonedEvent, 'target', {\\n      writable: true,\\n      value: {\\n        value,\\n        name\\n      }\\n    });\\n    onChange(clonedEvent, value, thumbIndex);\\n  });\\n  const range = Array.isArray(valueDerived);\\n  let values = range ? valueDerived.slice().sort(asc) : [valueDerived];\\n  values = values.map(value => value == null ? min : (0, _utils.clamp)(value, min, max));\\n  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({\\n    value: min + step * index\\n  })) : marksProp || [];\\n  const marksValues = marks.map(mark => mark.value);\\n  const {\\n    isFocusVisibleRef,\\n    onBlur: handleBlurVisible,\\n    onFocus: handleFocusVisible,\\n    ref: focusVisibleRef\\n  } = (0, _utils.unstable_useIsFocusVisible)();\\n  const [focusedThumbIndex, setFocusedThumbIndex] = React.useState(-1);\\n  const sliderRef = React.useRef();\\n  const handleFocusRef = (0, _utils.unstable_useForkRef)(focusVisibleRef, sliderRef);\\n  const handleRef = (0, _utils.unstable_useForkRef)(ref, handleFocusRef);\\n  const createHandleHiddenInputFocus = otherHandlers => event => {\\n    var _otherHandlers$onFocu;\\n    const index = Number(event.currentTarget.getAttribute('data-index'));\\n    handleFocusVisible(event);\\n    if (isFocusVisibleRef.current === true) {\\n      setFocusedThumbIndex(index);\\n    }\\n    setOpen(index);\\n    otherHandlers == null || (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);\\n  };\\n  const createHandleHiddenInputBlur = otherHandlers => event => {\\n    var _otherHandlers$onBlur;\\n    handleBlurVisible(event);\\n    if (isFocusVisibleRef.current === false) {\\n      setFocusedThumbIndex(-1);\\n    }\\n    setOpen(-1);\\n    otherHandlers == null || (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);\\n  };\\n  const changeValue = (event, valueInput) => {\\n    const index = Number(event.currentTarget.getAttribute('data-index'));\\n    const value = values[index];\\n    const marksIndex = marksValues.indexOf(value);\\n    let newValue = valueInput;\\n    if (marks && step == null) {\\n      const maxMarksValue = marksValues[marksValues.length - 1];\\n      if (newValue > maxMarksValue) {\\n        newValue = maxMarksValue;\\n      } else if (newValue < marksValues[0]) {\\n        newValue = marksValues[0];\\n      } else {\\n        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];\\n      }\\n    }\\n    newValue = (0, _utils.clamp)(newValue, min, max);\\n    if (range) {\\n      // Bound the new value to the thumb's neighbours.\\n      if (disableSwap) {\\n        newValue = (0, _utils.clamp)(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);\\n      }\\n      const previousValue = newValue;\\n      newValue = setValueIndex({\\n        values,\\n        newValue,\\n        index\\n      });\\n      let activeIndex = index;\\n\\n      // Potentially swap the index if needed.\\n      if (!disableSwap) {\\n        activeIndex = newValue.indexOf(previousValue);\\n      }\\n      focusThumb({\\n        sliderRef,\\n        activeIndex\\n      });\\n    }\\n    setValueState(newValue);\\n    setFocusedThumbIndex(index);\\n    if (handleChange && !areValuesEqual(newValue, valueDerived)) {\\n      handleChange(event, newValue, index);\\n    }\\n    if (onChangeCommitted) {\\n      onChangeCommitted(event, newValue);\\n    }\\n  };\\n  const createHandleHiddenInputKeyDown = otherHandlers => event => {\\n    var _otherHandlers$onKeyD;\\n    // The Shift + Up/Down keyboard shortcuts for moving the slider makes sense to be supported\\n    // only if the step is defined. If the step is null, this means tha the marks are used for specifying the valid values.\\n    if (step !== null) {\\n      const index = Number(event.currentTarget.getAttribute('data-index'));\\n      const value = values[index];\\n      let newValue = null;\\n      if ((event.key === 'ArrowLeft' || event.key === 'ArrowDown') && event.shiftKey || event.key === 'PageDown') {\\n        newValue = Math.max(value - shiftStep, min);\\n      } else if ((event.key === 'ArrowRight' || event.key === 'ArrowUp') && event.shiftKey || event.key === 'PageUp') {\\n        newValue = Math.min(value + shiftStep, max);\\n      }\\n      if (newValue !== null) {\\n        changeValue(event, newValue);\\n        event.preventDefault();\\n      }\\n    }\\n    otherHandlers == null || (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);\\n  };\\n  (0, _utils.unstable_useEnhancedEffect)(() => {\\n    if (disabled && sliderRef.current.contains(document.activeElement)) {\\n      var _document$activeEleme;\\n      // This is necessary because Firefox and Safari will keep focus\\n      // on a disabled element:\\n      // https://codesandbox.io/p/sandbox/mui-pr-22247-forked-h151h?file=/src/App.js\\n      // @ts-ignore\\n      (_document$activeEleme = document.activeElement) == null || _document$activeEleme.blur();\\n    }\\n  }, [disabled]);\\n  if (disabled && active !== -1) {\\n    setActive(-1);\\n  }\\n  if (disabled && focusedThumbIndex !== -1) {\\n    setFocusedThumbIndex(-1);\\n  }\\n  const createHandleHiddenInputChange = otherHandlers => event => {\\n    var _otherHandlers$onChan;\\n    (_otherHandlers$onChan = otherHandlers.onChange) == null || _otherHandlers$onChan.call(otherHandlers, event);\\n    // @ts-ignore\\n    changeValue(event, event.target.valueAsNumber);\\n  };\\n  const previousIndex = React.useRef();\\n  let axis = orientation;\\n  if (isRtl && orientation === 'horizontal') {\\n    axis += '-reverse';\\n  }\\n  const getFingerNewValue = ({\\n    finger,\\n    move = false\\n  }) => {\\n    const {\\n      current: slider\\n    } = sliderRef;\\n    const {\\n      width,\\n      height,\\n      bottom,\\n      left\\n    } = slider.getBoundingClientRect();\\n    let percent;\\n    if (axis.indexOf('vertical') === 0) {\\n      percent = (bottom - finger.y) / height;\\n    } else {\\n      percent = (finger.x - left) / width;\\n    }\\n    if (axis.indexOf('-reverse') !== -1) {\\n      percent = 1 - percent;\\n    }\\n    let newValue;\\n    newValue = percentToValue(percent, min, max);\\n    if (step) {\\n      newValue = roundValueToStep(newValue, step, min);\\n    } else {\\n      const closestIndex = findClosest(marksValues, newValue);\\n      newValue = marksValues[closestIndex];\\n    }\\n    newValue = (0, _utils.clamp)(newValue, min, max);\\n    let activeIndex = 0;\\n    if (range) {\\n      if (!move) {\\n        activeIndex = findClosest(values, newValue);\\n      } else {\\n        activeIndex = previousIndex.current;\\n      }\\n\\n      // Bound the new value to the thumb's neighbours.\\n      if (disableSwap) {\\n        newValue = (0, _utils.clamp)(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);\\n      }\\n      const previousValue = newValue;\\n      newValue = setValueIndex({\\n        values,\\n        newValue,\\n        index: activeIndex\\n      });\\n\\n      // Potentially swap the index if needed.\\n      if (!(disableSwap && move)) {\\n        activeIndex = newValue.indexOf(previousValue);\\n        previousIndex.current = activeIndex;\\n      }\\n    }\\n    return {\\n      newValue,\\n      activeIndex\\n    };\\n  };\\n  const handleTouchMove = (0, _utils.unstable_useEventCallback)(nativeEvent => {\\n    const finger = trackFinger(nativeEvent, touchId);\\n    if (!finger) {\\n      return;\\n    }\\n    moveCount.current += 1;\\n\\n    // Cancel move in case some other element consumed a mouseup event and it was not fired.\\n    // @ts-ignore buttons doesn't not exists on touch event\\n    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {\\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\\n      handleTouchEnd(nativeEvent);\\n      return;\\n    }\\n    const {\\n      newValue,\\n      activeIndex\\n    } = getFingerNewValue({\\n      finger,\\n      move: true\\n    });\\n    focusThumb({\\n      sliderRef,\\n      activeIndex,\\n      setActive\\n    });\\n    setValueState(newValue);\\n    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {\\n      setDragging(true);\\n    }\\n    if (handleChange && !areValuesEqual(newValue, valueDerived)) {\\n      handleChange(nativeEvent, newValue, activeIndex);\\n    }\\n  });\\n  const handleTouchEnd = (0, _utils.unstable_useEventCallback)(nativeEvent => {\\n    const finger = trackFinger(nativeEvent, touchId);\\n    setDragging(false);\\n    if (!finger) {\\n      return;\\n    }\\n    const {\\n      newValue\\n    } = getFingerNewValue({\\n      finger,\\n      move: true\\n    });\\n    setActive(-1);\\n    if (nativeEvent.type === 'touchend') {\\n      setOpen(-1);\\n    }\\n    if (onChangeCommitted) {\\n      onChangeCommitted(nativeEvent, newValue);\\n    }\\n    touchId.current = undefined;\\n\\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\\n    stopListening();\\n  });\\n  const handleTouchStart = (0, _utils.unstable_useEventCallback)(nativeEvent => {\\n    if (disabled) {\\n      return;\\n    }\\n    // If touch-action: none; is not supported we need to prevent the scroll manually.\\n    if (!doesSupportTouchActionNone()) {\\n      nativeEvent.preventDefault();\\n    }\\n    const touch = nativeEvent.changedTouches[0];\\n    if (touch != null) {\\n      // A number that uniquely identifies the current finger in the touch session.\\n      touchId.current = touch.identifier;\\n    }\\n    const finger = trackFinger(nativeEvent, touchId);\\n    if (finger !== false) {\\n      const {\\n        newValue,\\n        activeIndex\\n      } = getFingerNewValue({\\n        finger\\n      });\\n      focusThumb({\\n        sliderRef,\\n        activeIndex,\\n        setActive\\n      });\\n      setValueState(newValue);\\n      if (handleChange && !areValuesEqual(newValue, valueDerived)) {\\n        handleChange(nativeEvent, newValue, activeIndex);\\n      }\\n    }\\n    moveCount.current = 0;\\n    const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\\n    doc.addEventListener('touchmove', handleTouchMove, {\\n      passive: true\\n    });\\n    doc.addEventListener('touchend', handleTouchEnd, {\\n      passive: true\\n    });\\n  });\\n  const stopListening = React.useCallback(() => {\\n    const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\\n    doc.removeEventListener('mousemove', handleTouchMove);\\n    doc.removeEventListener('mouseup', handleTouchEnd);\\n    doc.removeEventListener('touchmove', handleTouchMove);\\n    doc.removeEventListener('touchend', handleTouchEnd);\\n  }, [handleTouchEnd, handleTouchMove]);\\n  React.useEffect(() => {\\n    const {\\n      current: slider\\n    } = sliderRef;\\n    slider.addEventListener('touchstart', handleTouchStart, {\\n      passive: doesSupportTouchActionNone()\\n    });\\n    return () => {\\n      slider.removeEventListener('touchstart', handleTouchStart);\\n      stopListening();\\n    };\\n  }, [stopListening, handleTouchStart]);\\n  React.useEffect(() => {\\n    if (disabled) {\\n      stopListening();\\n    }\\n  }, [disabled, stopListening]);\\n  const createHandleMouseDown = otherHandlers => event => {\\n    var _otherHandlers$onMous;\\n    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null || _otherHandlers$onMous.call(otherHandlers, event);\\n    if (disabled) {\\n      return;\\n    }\\n    if (event.defaultPrevented) {\\n      return;\\n    }\\n\\n    // Only handle left clicks\\n    if (event.button !== 0) {\\n      return;\\n    }\\n\\n    // Avoid text selection\\n    event.preventDefault();\\n    const finger = trackFinger(event, touchId);\\n    if (finger !== false) {\\n      const {\\n        newValue,\\n        activeIndex\\n      } = getFingerNewValue({\\n        finger\\n      });\\n      focusThumb({\\n        sliderRef,\\n        activeIndex,\\n        setActive\\n      });\\n      setValueState(newValue);\\n      if (handleChange && !areValuesEqual(newValue, valueDerived)) {\\n        handleChange(event, newValue, activeIndex);\\n      }\\n    }\\n    moveCount.current = 0;\\n    const doc = (0, _utils.unstable_ownerDocument)(sliderRef.current);\\n    doc.addEventListener('mousemove', handleTouchMove, {\\n      passive: true\\n    });\\n    doc.addEventListener('mouseup', handleTouchEnd);\\n  };\\n  const trackOffset = valueToPercent(range ? values[0] : min, min, max);\\n  const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;\\n  const getRootProps = (externalProps = {}) => {\\n    const externalHandlers = (0, _utils2.extractEventHandlers)(externalProps);\\n    const ownEventHandlers = {\\n      onMouseDown: createHandleMouseDown(externalHandlers || {})\\n    };\\n    const mergedEventHandlers = (0, _extends2.default)({}, externalHandlers, ownEventHandlers);\\n    return (0, _extends2.default)({}, externalProps, {\\n      ref: handleRef\\n    }, mergedEventHandlers);\\n  };\\n  const createHandleMouseOver = otherHandlers => event => {\\n    var _otherHandlers$onMous2;\\n    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null || _otherHandlers$onMous2.call(otherHandlers, event);\\n    const index = Number(event.currentTarget.getAttribute('data-index'));\\n    setOpen(index);\\n  };\\n  const createHandleMouseLeave = otherHandlers => event => {\\n    var _otherHandlers$onMous3;\\n    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null || _otherHandlers$onMous3.call(otherHandlers, event);\\n    setOpen(-1);\\n  };\\n  const getThumbProps = (externalProps = {}) => {\\n    const externalHandlers = (0, _utils2.extractEventHandlers)(externalProps);\\n    const ownEventHandlers = {\\n      onMouseOver: createHandleMouseOver(externalHandlers || {}),\\n      onMouseLeave: createHandleMouseLeave(externalHandlers || {})\\n    };\\n    return (0, _extends2.default)({}, externalProps, externalHandlers, ownEventHandlers);\\n  };\\n  const getThumbStyle = index => {\\n    return {\\n      // So the non active thumb doesn't show its label on hover.\\n      pointerEvents: active !== -1 && active !== index ? 'none' : undefined\\n    };\\n  };\\n  const getHiddenInputProps = (externalProps = {}) => {\\n    var _parameters$step;\\n    const externalHandlers = (0, _utils2.extractEventHandlers)(externalProps);\\n    const ownEventHandlers = {\\n      onChange: createHandleHiddenInputChange(externalHandlers || {}),\\n      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),\\n      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),\\n      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})\\n    };\\n    const mergedEventHandlers = (0, _extends2.default)({}, externalHandlers, ownEventHandlers);\\n    return (0, _extends2.default)({\\n      tabIndex,\\n      'aria-labelledby': ariaLabelledby,\\n      'aria-orientation': orientation,\\n      'aria-valuemax': scale(max),\\n      'aria-valuemin': scale(min),\\n      name,\\n      type: 'range',\\n      min: parameters.min,\\n      max: parameters.max,\\n      step: parameters.step === null && parameters.marks ? 'any' : (_parameters$step = parameters.step) != null ? _parameters$step : undefined,\\n      disabled\\n    }, externalProps, mergedEventHandlers, {\\n      style: (0, _extends2.default)({}, _utils.visuallyHidden, {\\n        direction: isRtl ? 'rtl' : 'ltr',\\n        // So that VoiceOver's focus indicator matches the thumb's dimensions\\n        width: '100%',\\n        height: '100%'\\n      })\\n    });\\n  };\\n  return {\\n    active,\\n    axis: axis,\\n    axisProps,\\n    dragging,\\n    focusedThumbIndex,\\n    getHiddenInputProps,\\n    getRootProps,\\n    getThumbProps,\\n    marks: marks,\\n    open,\\n    range,\\n    rootRef: handleRef,\\n    trackLeap,\\n    trackOffset,\\n    values,\\n    getThumbStyle\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"asc\",\"a\",\"b\",\"findClosest\",\"values\",\"currentValue\",\"_values$reduce\",\"closestIndex\",\"reduce\",\"acc\",\"value\",\"index\",\"distance\",\"Math\",\"abs\",\"trackFinger\",\"event\",\"touchId\",\"undefined\",\"current\",\"changedTouches\",\"i\",\"length\",\"touch\",\"identifier\",\"x\",\"clientX\",\"y\",\"clientY\",\"valueToPercent\",\"min\",\"max\",\"setValueIndex\",\"newValue\",\"output\",\"slice\",\"sort\",\"focusThumb\",\"sliderRef\",\"activeIndex\",\"setActive\",\"_sliderRef$current\",\"_doc$activeElement\",\"doc\",\"_utils\",\"unstable_ownerDocument\",\"contains\",\"activeElement\",\"Number\",\"getAttribute\",\"_sliderRef$current2\",\"querySelector\",\"focus\",\"areValuesEqual\",\"oldValue\",\"_utils2\",\"areArraysEqual\",\"doesSupportTouchActionNone\",\"cachedSupportsTouchActionNone\",\"CSS\",\"supports\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"Identity\",\"useSlider\",\"parameters\",\"ariaLabelledby\",\"defaultValue\",\"disabled\",\"disableSwap\",\"isRtl\",\"marksProp\",\"name\",\"onChange\",\"onChangeCommitted\",\"orientation\",\"ref\",\"scale\",\"step\",\"shiftStep\",\"tabIndex\",\"valueProp\",\"React\",\"useRef\",\"active\",\"useState\",\"open\",\"setOpen\",\"dragging\",\"setDragging\",\"moveCount\",\"valueDerived\",\"setValueState\",\"unstable_useControlled\",\"controlled\",\"default\",\"handleChange\",\"thumbIndex\",\"nativeEvent\",\"clonedEvent\",\"constructor\",\"type\",\"writable\",\"range\",\"Array\",\"isArray\",\"map\",\"clamp\",\"marks\",\"floor\",\"_\",\"marksValues\",\"mark\",\"isFocusVisibleRef\",\"handleBlurVisible\",\"handleFocusVisible\",\"focusVisibleRef\",\"unstable_useIsFocusVisible\",\"focusedThumbIndex\",\"setFocusedThumbIndex\",\"handleFocusRef\",\"unstable_useForkRef\",\"handleRef\",\"createHandleHiddenInputFocus\",\"otherHandlers\",\"_otherHandlers$onFocu\",\"currentTarget\",\"onFocus\",\"call\",\"createHandleHiddenInputBlur\",\"_otherHandlers$onBlur\",\"onBlur\",\"changeValue\",\"valueInput\",\"marksIndex\",\"indexOf\",\"maxMarksValue\",\"Infinity\",\"previousValue\",\"createHandleHiddenInputKeyDown\",\"_otherHandlers$onKeyD\",\"key\",\"shiftKey\",\"preventDefault\",\"onKeyDown\",\"unstable_useEnhancedEffect\",\"document\",\"_document$activeEleme\",\"blur\",\"createHandleHiddenInputChange\",\"_otherHandlers$onChan\",\"target\",\"valueAsNumber\",\"previousIndex\",\"axis\",\"getFingerNewValue\",\"finger\",\"move\",\"slider\",\"width\",\"height\",\"bottom\",\"left\",\"getBoundingClientRect\",\"percent\",\"nearest\",\"round\",\"toFixed\",\"parts\",\"toExponential\",\"split\",\"matissaDecimalPart\",\"parseInt\",\"decimalPart\",\"toString\",\"handleTouchMove\",\"unstable_useEventCallback\",\"buttons\",\"handleTouchEnd\",\"INTENTIONAL_DRAG_COUNT_THRESHOLD\",\"stopListening\",\"handleTouchStart\",\"addEventListener\",\"passive\",\"useCallback\",\"removeEventListener\",\"useEffect\",\"createHandleMouseDown\",\"_otherHandlers$onMous\",\"onMouseDown\",\"defaultPrevented\",\"button\",\"trackOffset\",\"trackLeap\",\"createHandleMouseOver\",\"_otherHandlers$onMous2\",\"onMouseOver\",\"createHandleMouseLeave\",\"_otherHandlers$onMous3\",\"onMouseLeave\",\"axisProps\",\"getHiddenInputProps\",\"externalProps\",\"_parameters$step\",\"externalHandlers\",\"extractEventHandlers\",\"ownEventHandlers\",\"mergedEventHandlers\",\"_extends2\",\"style\",\"visuallyHidden\",\"direction\",\"getRootProps\",\"getThumbProps\",\"rootRef\",\"getThumbStyle\",\"pointerEvents\",\"_interopRequireWildcard\",\"__esModule\",\"has\",\"get\",\"n\",\"__proto__\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"set\",\"horizontal\",\"offset\",\"leap\",\"right\",\"vertical\"]\n}\n"]