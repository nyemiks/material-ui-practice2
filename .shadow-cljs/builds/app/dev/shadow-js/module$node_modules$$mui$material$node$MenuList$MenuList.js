["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/material/node/MenuList/MenuList.js"],"~:js","shadow$provide.module$node_modules$$mui$material$node$MenuList$MenuList = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  function nextItem(list, item, disableListWrap) {\n    return list === item ? list.firstChild : item && item.nextElementSibling ? item.nextElementSibling : disableListWrap ? null : list.firstChild;\n  }\n  function previousItem(list, item, disableListWrap) {\n    return list === item ? disableListWrap ? list.firstChild : list.lastChild : item && item.previousElementSibling ? item.previousElementSibling : disableListWrap ? null : list.lastChild;\n  }\n  function textCriteriaMatches(nextFocus, textCriteria) {\n    if (void 0 === textCriteria) {\n      return !0;\n    }\n    let text = nextFocus.innerText;\n    void 0 === text && (text = nextFocus.textContent);\n    text = text.trim().toLowerCase();\n    return 0 === text.length ? !1 : textCriteria.repeating ? text[0] === textCriteria.keys[0] : 0 === text.indexOf(textCriteria.keys.join(\"\"));\n  }\n  function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n    let wrappedOnce = !1;\n    for (currentFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : !1); currentFocus;) {\n      if (currentFocus === list.firstChild) {\n        if (wrappedOnce) {\n          break;\n        }\n        wrappedOnce = !0;\n      }\n      const nextFocusDisabled = disabledItemsFocusable ? !1 : currentFocus.disabled || \"true\" === currentFocus.getAttribute(\"aria-disabled\");\n      if (currentFocus.hasAttribute(\"tabindex\") && textCriteriaMatches(currentFocus, textCriteria) && !nextFocusDisabled) {\n        return currentFocus.focus(), !0;\n      }\n      currentFocus = traversalFunction(list, currentFocus, disableListWrap);\n    }\n    return !1;\n  }\n  \"use client\";\n  module = require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.default = void 0;\n  var _extends2 = module(require(\"module$node_modules$$babel$runtime$helpers$extends\")), _objectWithoutPropertiesLoose2 = module(require(\"module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose\")), React = function(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }(require(\"module$node_modules$react$index\")), _reactIs = require(\"module$node_modules$react_is$index\");\n  global = module(require(\"module$node_modules$prop_types$index\"));\n  var _ownerDocument = module(require(\"module$node_modules$$mui$material$node$utils$ownerDocument\")), _List = module(require(\"module$node_modules$$mui$material$node$List$index\")), _getScrollbarSize = module(require(\"module$node_modules$$mui$material$node$utils$getScrollbarSize\")), _useForkRef = module(require(\"module$node_modules$$mui$material$node$utils$useForkRef\")), _useEnhancedEffect = module(require(\"module$node_modules$$mui$material$node$utils$useEnhancedEffect\")), _jsxRuntime = require(\"module$node_modules$react$jsx_runtime\");\n  const _excluded = \"actions autoFocus autoFocusItem children className disabledItemsFocusable disableListWrap onKeyDown variant\".split(\" \");\n  require = React.forwardRef(function(props, ref) {\n    const {actions, autoFocus = !1, autoFocusItem = !1, children, className, disabledItemsFocusable = !1, disableListWrap = !1, onKeyDown, variant = \"selectedMenu\"} = props;\n    props = (0,_objectWithoutPropertiesLoose2.default)(props, _excluded);\n    const listRef = React.useRef(null), textCriteriaRef = React.useRef({keys:[], repeating:!0, previousKeyMatched:!0, lastTime:null});\n    (0,_useEnhancedEffect.default)(() => {\n      autoFocus && listRef.current.focus();\n    }, [autoFocus]);\n    React.useImperativeHandle(actions, () => ({adjustStyleForScrollbar:(containerElement, {direction}) => {\n      const noExplicitWidth = !listRef.current.style.width;\n      containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth && (containerElement = `${(0,_getScrollbarSize.default)((0,_ownerDocument.default)(containerElement))}px`, listRef.current.style[\"rtl\" === direction ? \"paddingLeft\" : \"paddingRight\"] = containerElement, listRef.current.style.width = `calc(100% + ${containerElement})`);\n      return listRef.current;\n    }}), []);\n    ref = (0,_useForkRef.default)(listRef, ref);\n    let activeItemIndex = -1;\n    React.Children.forEach(children, (child, index) => {\n      React.isValidElement(child) ? ((0,_reactIs.isFragment)(child) && console.error(\"MUI: The Menu component doesn't accept a Fragment as a child.\\nConsider providing an array instead.\"), child.props.disabled || (\"selectedMenu\" === variant && child.props.selected ? activeItemIndex = index : -1 === activeItemIndex && (activeItemIndex = index)), activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight) && (activeItemIndex += 1, activeItemIndex >= \n      children.length && (activeItemIndex = -1))) : activeItemIndex === index && (activeItemIndex += 1, activeItemIndex >= children.length && (activeItemIndex = -1));\n    });\n    const items = React.Children.map(children, (child, index) => index === activeItemIndex ? (index = {}, autoFocusItem && (index.autoFocus = !0), void 0 === child.props.tabIndex && \"selectedMenu\" === variant && (index.tabIndex = 0), React.cloneElement(child, index)) : child);\n    return (0,_jsxRuntime.jsx)(_List.default, (0,_extends2.default)({role:\"menu\", ref, className, onKeyDown:event => {\n      const list = listRef.current;\n      var key = event.key;\n      const currentFocus = (0,_ownerDocument.default)(list).activeElement;\n      if (\"ArrowDown\" === key) {\n        event.preventDefault(), moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n      } else if (\"ArrowUp\" === key) {\n        event.preventDefault(), moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n      } else if (\"Home\" === key) {\n        event.preventDefault(), moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n      } else if (\"End\" === key) {\n        event.preventDefault(), moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n      } else if (1 === key.length) {\n        const criteria = textCriteriaRef.current;\n        key = key.toLowerCase();\n        const currTime = performance.now();\n        0 < criteria.keys.length && (500 < currTime - criteria.lastTime ? (criteria.keys = [], criteria.repeating = !0, criteria.previousKeyMatched = !0) : criteria.repeating && key !== criteria.keys[0] && (criteria.repeating = !1));\n        criteria.lastTime = currTime;\n        criteria.keys.push(key);\n        key = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n        criteria.previousKeyMatched && (key || moveFocus(list, currentFocus, !1, disabledItemsFocusable, nextItem, criteria)) ? event.preventDefault() : criteria.previousKeyMatched = !1;\n      }\n      onKeyDown && onKeyDown(event);\n    }, tabIndex:autoFocus ? 0 : -1}, props, {children:items}));\n  });\n  require.propTypes = {autoFocus:global.default.bool, autoFocusItem:global.default.bool, children:global.default.node, className:global.default.string, disabledItemsFocusable:global.default.bool, disableListWrap:global.default.bool, onKeyDown:global.default.func, variant:global.default.oneOf([\"menu\", \"selectedMenu\"])};\n  exports.default = require;\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$material$node$MenuList$MenuList\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _reactIs = require(\"react-is\");\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _ownerDocument = _interopRequireDefault(require(\"../utils/ownerDocument\"));\nvar _List = _interopRequireDefault(require(\"../List\"));\nvar _getScrollbarSize = _interopRequireDefault(require(\"../utils/getScrollbarSize\"));\nvar _useForkRef = _interopRequireDefault(require(\"../utils/useForkRef\"));\nvar _useEnhancedEffect = _interopRequireDefault(require(\"../utils/useEnhancedEffect\"));\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nconst _excluded = [\"actions\", \"autoFocus\", \"autoFocusItem\", \"children\", \"className\", \"disabledItemsFocusable\", \"disableListWrap\", \"onKeyDown\", \"variant\"];\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction nextItem(list, item, disableListWrap) {\n  if (list === item) {\n    return list.firstChild;\n  }\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n  return disableListWrap ? null : list.firstChild;\n}\nfunction previousItem(list, item, disableListWrap) {\n  if (list === item) {\n    return disableListWrap ? list.firstChild : list.lastChild;\n  }\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n  return disableListWrap ? null : list.lastChild;\n}\nfunction textCriteriaMatches(nextFocus, textCriteria) {\n  if (textCriteria === undefined) {\n    return true;\n  }\n  let text = nextFocus.innerText;\n  if (text === undefined) {\n    // jsdom doesn't support innerText\n    text = nextFocus.textContent;\n  }\n  text = text.trim().toLowerCase();\n  if (text.length === 0) {\n    return false;\n  }\n  if (textCriteria.repeating) {\n    return text[0] === textCriteria.keys[0];\n  }\n  return text.indexOf(textCriteria.keys.join('')) === 0;\n}\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n  let wrappedOnce = false;\n  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return false;\n      }\n      wrappedOnce = true;\n    }\n\n    // Same logic as useAutocomplete.js\n    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\n    } else {\n      nextFocus.focus();\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A permanently displayed menu following https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/.\n * It's exposed to help customization of the [`Menu`](/material-ui/api/menu/) component if you\n * use it separately you need to move focus into the component manually. Once\n * the focus is placed inside the component it is fully keyboard accessible.\n */\nconst MenuList = /*#__PURE__*/React.forwardRef(function MenuList(props, ref) {\n  const {\n      // private\n      // eslint-disable-next-line react/prop-types\n      actions,\n      autoFocus = false,\n      autoFocusItem = false,\n      children,\n      className,\n      disabledItemsFocusable = false,\n      disableListWrap = false,\n      onKeyDown,\n      variant = 'selectedMenu'\n    } = props,\n    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);\n  const listRef = React.useRef(null);\n  const textCriteriaRef = React.useRef({\n    keys: [],\n    repeating: true,\n    previousKeyMatched: true,\n    lastTime: null\n  });\n  (0, _useEnhancedEffect.default)(() => {\n    if (autoFocus) {\n      listRef.current.focus();\n    }\n  }, [autoFocus]);\n  React.useImperativeHandle(actions, () => ({\n    adjustStyleForScrollbar: (containerElement, {\n      direction\n    }) => {\n      // Let's ignore that piece of logic if users are already overriding the width\n      // of the menu.\n      const noExplicitWidth = !listRef.current.style.width;\n      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\n        const scrollbarSize = `${(0, _getScrollbarSize.default)((0, _ownerDocument.default)(containerElement))}px`;\n        listRef.current.style[direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\n        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;\n      }\n      return listRef.current;\n    }\n  }), []);\n  const handleKeyDown = event => {\n    const list = listRef.current;\n    const key = event.key;\n    /**\n     * @type {Element} - will always be defined since we are in a keydown handler\n     * attached to an element. A keydown event is either dispatched to the activeElement\n     * or document.body or document.documentElement. Only the first case will\n     * trigger this specific handler.\n     */\n    const currentFocus = (0, _ownerDocument.default)(list).activeElement;\n    if (key === 'ArrowDown') {\n      // Prevent scroll of the page\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'ArrowUp') {\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key === 'Home') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'End') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key.length === 1) {\n      const criteria = textCriteriaRef.current;\n      const lowerKey = key.toLowerCase();\n      const currTime = performance.now();\n      if (criteria.keys.length > 0) {\n        // Reset\n        if (currTime - criteria.lastTime > 500) {\n          criteria.keys = [];\n          criteria.repeating = true;\n          criteria.previousKeyMatched = true;\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\n          criteria.repeating = false;\n        }\n      }\n      criteria.lastTime = currTime;\n      criteria.keys.push(lowerKey);\n      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\n        event.preventDefault();\n      } else {\n        criteria.previousKeyMatched = false;\n      }\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n  const handleRef = (0, _useForkRef.default)(listRef, ref);\n\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n  let activeItemIndex = -1;\n  // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n  React.Children.forEach(children, (child, index) => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      if (activeItemIndex === index) {\n        activeItemIndex += 1;\n        if (activeItemIndex >= children.length) {\n          // there are no focusable items within the list.\n          activeItemIndex = -1;\n        }\n      }\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if ((0, _reactIs.isFragment)(child)) {\n        console.error([\"MUI: The Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {\n      activeItemIndex += 1;\n      if (activeItemIndex >= children.length) {\n        // there are no focusable items within the list.\n        activeItemIndex = -1;\n      }\n    }\n  });\n  const items = React.Children.map(children, (child, index) => {\n    if (index === activeItemIndex) {\n      const newChildProps = {};\n      if (autoFocusItem) {\n        newChildProps.autoFocus = true;\n      }\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\n        newChildProps.tabIndex = 0;\n      }\n      return /*#__PURE__*/React.cloneElement(child, newChildProps);\n    }\n    return child;\n  });\n  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_List.default, (0, _extends2.default)({\n    role: \"menu\",\n    ref: handleRef,\n    className: className,\n    onKeyDown: handleKeyDown,\n    tabIndex: autoFocus ? 0 : -1\n  }, other, {\n    children: items\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? MenuList.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * If `true`, will focus the `[role=\"menu\"]` container and move into tab order.\n   * @default false\n   */\n  autoFocus: _propTypes.default.bool,\n  /**\n   * If `true`, will focus the first menuitem if `variant=\"menu\"` or selected item\n   * if `variant=\"selectedMenu\"`.\n   * @default false\n   */\n  autoFocusItem: _propTypes.default.bool,\n  /**\n   * MenuList contents, normally `MenuItem`s.\n   */\n  children: _propTypes.default.node,\n  /**\n   * @ignore\n   */\n  className: _propTypes.default.string,\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: _propTypes.default.bool,\n  /**\n   * If `true`, the menu items will not wrap focus.\n   * @default false\n   */\n  disableListWrap: _propTypes.default.bool,\n  /**\n   * @ignore\n   */\n  onKeyDown: _propTypes.default.func,\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   * @default 'selectedMenu'\n   */\n  variant: _propTypes.default.oneOf(['menu', 'selectedMenu'])\n} : void 0;\nvar _default = exports.default = MenuList;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_is$index","~$module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose","~$module$node_modules$react$jsx_runtime","~$module$node_modules$$mui$material$node$utils$getScrollbarSize","~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$$mui$material$node$utils$useEnhancedEffect","~$module$node_modules$$babel$runtime$helpers$extends","~$module$node_modules$$mui$material$node$utils$ownerDocument","~$module$node_modules$$mui$material$node$List$index","~$module$node_modules$$mui$material$node$utils$useForkRef"]],"~:properties",["^5",["role","width","keys","tabIndex","className","children","__esModule","propTypes","disableListWrap","value","repeating","disabledItemsFocusable","previousKeyMatched","ref","__proto__","adjustStyleForScrollbar","onKeyDown","default","autoFocusItem","variant","lastTime","autoFocus"]],"~:compiled-at",1712152511813,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$material$node$MenuList$MenuList.js\",\n\"lineCount\":116,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/material/node/MenuList/MenuList.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$material$node$MenuList$MenuList\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = void 0;\\nvar _extends2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/extends\\\"));\\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/objectWithoutPropertiesLoose\\\"));\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar _reactIs = require(\\\"react-is\\\");\\nvar _propTypes = _interopRequireDefault(require(\\\"prop-types\\\"));\\nvar _ownerDocument = _interopRequireDefault(require(\\\"../utils/ownerDocument\\\"));\\nvar _List = _interopRequireDefault(require(\\\"../List\\\"));\\nvar _getScrollbarSize = _interopRequireDefault(require(\\\"../utils/getScrollbarSize\\\"));\\nvar _useForkRef = _interopRequireDefault(require(\\\"../utils/useForkRef\\\"));\\nvar _useEnhancedEffect = _interopRequireDefault(require(\\\"../utils/useEnhancedEffect\\\"));\\nvar _jsxRuntime = require(\\\"react/jsx-runtime\\\");\\nconst _excluded = [\\\"actions\\\", \\\"autoFocus\\\", \\\"autoFocusItem\\\", \\\"children\\\", \\\"className\\\", \\\"disabledItemsFocusable\\\", \\\"disableListWrap\\\", \\\"onKeyDown\\\", \\\"variant\\\"];\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\nfunction nextItem(list, item, disableListWrap) {\\n  if (list === item) {\\n    return list.firstChild;\\n  }\\n  if (item && item.nextElementSibling) {\\n    return item.nextElementSibling;\\n  }\\n  return disableListWrap ? null : list.firstChild;\\n}\\nfunction previousItem(list, item, disableListWrap) {\\n  if (list === item) {\\n    return disableListWrap ? list.firstChild : list.lastChild;\\n  }\\n  if (item && item.previousElementSibling) {\\n    return item.previousElementSibling;\\n  }\\n  return disableListWrap ? null : list.lastChild;\\n}\\nfunction textCriteriaMatches(nextFocus, textCriteria) {\\n  if (textCriteria === undefined) {\\n    return true;\\n  }\\n  let text = nextFocus.innerText;\\n  if (text === undefined) {\\n    // jsdom doesn't support innerText\\n    text = nextFocus.textContent;\\n  }\\n  text = text.trim().toLowerCase();\\n  if (text.length === 0) {\\n    return false;\\n  }\\n  if (textCriteria.repeating) {\\n    return text[0] === textCriteria.keys[0];\\n  }\\n  return text.indexOf(textCriteria.keys.join('')) === 0;\\n}\\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\\n  let wrappedOnce = false;\\n  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\\n  while (nextFocus) {\\n    // Prevent infinite loop.\\n    if (nextFocus === list.firstChild) {\\n      if (wrappedOnce) {\\n        return false;\\n      }\\n      wrappedOnce = true;\\n    }\\n\\n    // Same logic as useAutocomplete.js\\n    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\\n      // Move to the next element.\\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\\n    } else {\\n      nextFocus.focus();\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * A permanently displayed menu following https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/.\\n * It's exposed to help customization of the [`Menu`](/material-ui/api/menu/) component if you\\n * use it separately you need to move focus into the component manually. Once\\n * the focus is placed inside the component it is fully keyboard accessible.\\n */\\nconst MenuList = /*#__PURE__*/React.forwardRef(function MenuList(props, ref) {\\n  const {\\n      // private\\n      // eslint-disable-next-line react/prop-types\\n      actions,\\n      autoFocus = false,\\n      autoFocusItem = false,\\n      children,\\n      className,\\n      disabledItemsFocusable = false,\\n      disableListWrap = false,\\n      onKeyDown,\\n      variant = 'selectedMenu'\\n    } = props,\\n    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);\\n  const listRef = React.useRef(null);\\n  const textCriteriaRef = React.useRef({\\n    keys: [],\\n    repeating: true,\\n    previousKeyMatched: true,\\n    lastTime: null\\n  });\\n  (0, _useEnhancedEffect.default)(() => {\\n    if (autoFocus) {\\n      listRef.current.focus();\\n    }\\n  }, [autoFocus]);\\n  React.useImperativeHandle(actions, () => ({\\n    adjustStyleForScrollbar: (containerElement, {\\n      direction\\n    }) => {\\n      // Let's ignore that piece of logic if users are already overriding the width\\n      // of the menu.\\n      const noExplicitWidth = !listRef.current.style.width;\\n      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\\n        const scrollbarSize = `${(0, _getScrollbarSize.default)((0, _ownerDocument.default)(containerElement))}px`;\\n        listRef.current.style[direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\\n        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;\\n      }\\n      return listRef.current;\\n    }\\n  }), []);\\n  const handleKeyDown = event => {\\n    const list = listRef.current;\\n    const key = event.key;\\n    /**\\n     * @type {Element} - will always be defined since we are in a keydown handler\\n     * attached to an element. A keydown event is either dispatched to the activeElement\\n     * or document.body or document.documentElement. Only the first case will\\n     * trigger this specific handler.\\n     */\\n    const currentFocus = (0, _ownerDocument.default)(list).activeElement;\\n    if (key === 'ArrowDown') {\\n      // Prevent scroll of the page\\n      event.preventDefault();\\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\\n    } else if (key === 'ArrowUp') {\\n      event.preventDefault();\\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\\n    } else if (key === 'Home') {\\n      event.preventDefault();\\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\\n    } else if (key === 'End') {\\n      event.preventDefault();\\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\\n    } else if (key.length === 1) {\\n      const criteria = textCriteriaRef.current;\\n      const lowerKey = key.toLowerCase();\\n      const currTime = performance.now();\\n      if (criteria.keys.length > 0) {\\n        // Reset\\n        if (currTime - criteria.lastTime > 500) {\\n          criteria.keys = [];\\n          criteria.repeating = true;\\n          criteria.previousKeyMatched = true;\\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\\n          criteria.repeating = false;\\n        }\\n      }\\n      criteria.lastTime = currTime;\\n      criteria.keys.push(lowerKey);\\n      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\\n        event.preventDefault();\\n      } else {\\n        criteria.previousKeyMatched = false;\\n      }\\n    }\\n    if (onKeyDown) {\\n      onKeyDown(event);\\n    }\\n  };\\n  const handleRef = (0, _useForkRef.default)(listRef, ref);\\n\\n  /**\\n   * the index of the item should receive focus\\n   * in a `variant=\\\"selectedMenu\\\"` it's the first `selected` item\\n   * otherwise it's the very first item.\\n   */\\n  let activeItemIndex = -1;\\n  // since we inject focus related props into children we have to do a lookahead\\n  // to check if there is a `selected` item. We're looking for the last `selected`\\n  // item and use the first valid item as a fallback\\n  React.Children.forEach(children, (child, index) => {\\n    if (! /*#__PURE__*/React.isValidElement(child)) {\\n      if (activeItemIndex === index) {\\n        activeItemIndex += 1;\\n        if (activeItemIndex >= children.length) {\\n          // there are no focusable items within the list.\\n          activeItemIndex = -1;\\n        }\\n      }\\n      return;\\n    }\\n    if (process.env.NODE_ENV !== 'production') {\\n      if ((0, _reactIs.isFragment)(child)) {\\n        console.error([\\\"MUI: The Menu component doesn't accept a Fragment as a child.\\\", 'Consider providing an array instead.'].join('\\\\n'));\\n      }\\n    }\\n    if (!child.props.disabled) {\\n      if (variant === 'selectedMenu' && child.props.selected) {\\n        activeItemIndex = index;\\n      } else if (activeItemIndex === -1) {\\n        activeItemIndex = index;\\n      }\\n    }\\n    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {\\n      activeItemIndex += 1;\\n      if (activeItemIndex >= children.length) {\\n        // there are no focusable items within the list.\\n        activeItemIndex = -1;\\n      }\\n    }\\n  });\\n  const items = React.Children.map(children, (child, index) => {\\n    if (index === activeItemIndex) {\\n      const newChildProps = {};\\n      if (autoFocusItem) {\\n        newChildProps.autoFocus = true;\\n      }\\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\\n        newChildProps.tabIndex = 0;\\n      }\\n      return /*#__PURE__*/React.cloneElement(child, newChildProps);\\n    }\\n    return child;\\n  });\\n  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_List.default, (0, _extends2.default)({\\n    role: \\\"menu\\\",\\n    ref: handleRef,\\n    className: className,\\n    onKeyDown: handleKeyDown,\\n    tabIndex: autoFocus ? 0 : -1\\n  }, other, {\\n    children: items\\n  }));\\n});\\nprocess.env.NODE_ENV !== \\\"production\\\" ? MenuList.propTypes /* remove-proptypes */ = {\\n  // \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 Warning \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n  // \\u2502 These PropTypes are generated from the TypeScript type definitions. \\u2502\\n  // \\u2502    To update them, edit the d.ts file and run `pnpm proptypes`.     \\u2502\\n  // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n  /**\\n   * If `true`, will focus the `[role=\\\"menu\\\"]` container and move into tab order.\\n   * @default false\\n   */\\n  autoFocus: _propTypes.default.bool,\\n  /**\\n   * If `true`, will focus the first menuitem if `variant=\\\"menu\\\"` or selected item\\n   * if `variant=\\\"selectedMenu\\\"`.\\n   * @default false\\n   */\\n  autoFocusItem: _propTypes.default.bool,\\n  /**\\n   * MenuList contents, normally `MenuItem`s.\\n   */\\n  children: _propTypes.default.node,\\n  /**\\n   * @ignore\\n   */\\n  className: _propTypes.default.string,\\n  /**\\n   * If `true`, will allow focus on disabled items.\\n   * @default false\\n   */\\n  disabledItemsFocusable: _propTypes.default.bool,\\n  /**\\n   * If `true`, the menu items will not wrap focus.\\n   * @default false\\n   */\\n  disableListWrap: _propTypes.default.bool,\\n  /**\\n   * @ignore\\n   */\\n  onKeyDown: _propTypes.default.func,\\n  /**\\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\\n   * and the vertical alignment relative to the anchor element.\\n   * @default 'selectedMenu'\\n   */\\n  variant: _propTypes.default.oneOf(['menu', 'selectedMenu'])\\n} : void 0;\\nvar _default = exports.default = MenuList;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"nextItem\",\"list\",\"item\",\"disableListWrap\",\"firstChild\",\"nextElementSibling\",\"previousItem\",\"lastChild\",\"previousElementSibling\",\"textCriteriaMatches\",\"nextFocus\",\"textCriteria\",\"undefined\",\"text\",\"innerText\",\"textContent\",\"trim\",\"toLowerCase\",\"length\",\"repeating\",\"keys\",\"indexOf\",\"join\",\"moveFocus\",\"currentFocus\",\"disabledItemsFocusable\",\"traversalFunction\",\"wrappedOnce\",\"nextFocusDisabled\",\"disabled\",\"getAttribute\",\"hasAttribute\",\"focus\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"value\",\"default\",\"_extends2\",\"_objectWithoutPropertiesLoose2\",\"React\",\"_interopRequireWildcard\",\"__esModule\",\"has\",\"get\",\"n\",\"__proto__\",\"a\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"call\",\"i\",\"set\",\"_reactIs\",\"_propTypes\",\"_ownerDocument\",\"_List\",\"_getScrollbarSize\",\"_useForkRef\",\"_useEnhancedEffect\",\"_jsxRuntime\",\"_excluded\",\"MenuList\",\"forwardRef\",\"props\",\"ref\",\"actions\",\"autoFocus\",\"autoFocusItem\",\"children\",\"className\",\"onKeyDown\",\"variant\",\"other\",\"listRef\",\"useRef\",\"textCriteriaRef\",\"previousKeyMatched\",\"lastTime\",\"current\",\"useImperativeHandle\",\"adjustStyleForScrollbar\",\"containerElement\",\"direction\",\"noExplicitWidth\",\"style\",\"width\",\"clientHeight\",\"scrollbarSize\",\"handleRef\",\"activeItemIndex\",\"Children\",\"forEach\",\"child\",\"index\",\"isValidElement\",\"isFragment\",\"console\",\"error\",\"selected\",\"muiSkipListHighlight\",\"type\",\"items\",\"map\",\"newChildProps\",\"tabIndex\",\"cloneElement\",\"jsx\",\"role\",\"event\",\"handleKeyDown\",\"key\",\"activeElement\",\"preventDefault\",\"criteria\",\"lowerKey\",\"currTime\",\"performance\",\"now\",\"push\",\"keepFocusOnCurrent\",\"propTypes\",\"bool\",\"node\",\"string\",\"func\",\"oneOf\"]\n}\n"]