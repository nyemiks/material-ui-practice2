["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/base/node/unstable_useModal/ModalManager.js"],"~:js","shadow$provide.module$node_modules$$mui$base$node$unstable_useModal$ModalManager = function(global, require, module, exports) {\n  function isOverflowing(container) {\n    const doc = (0,_utils.unstable_ownerDocument)(container);\n    return doc.body === container ? (0,_utils.unstable_ownerWindow)(container).innerWidth > doc.documentElement.clientWidth : container.scrollHeight > container.clientHeight;\n  }\n  function ariaHidden(element, show) {\n    show ? element.setAttribute(\"aria-hidden\", \"true\") : element.removeAttribute(\"aria-hidden\");\n  }\n  function getPaddingRight(element) {\n    return parseInt((0,_utils.unstable_ownerWindow)(element).getComputedStyle(element).paddingRight, 10) || 0;\n  }\n  function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {\n    const blacklist = [mountElement, currentElement, ...elementsToExclude];\n    [].forEach.call(container.children, element => {\n      const isNotExcludedElement = -1 === blacklist.indexOf(element), isForbiddenTagName = -1 !== \"TEMPLATE SCRIPT STYLE LINK MAP META NOSCRIPT PICTURE COL COLGROUP PARAM SLOT SOURCE TRACK\".split(\" \").indexOf(element.tagName), isInputHidden = \"INPUT\" === element.tagName && \"hidden\" === element.getAttribute(\"type\");\n      isNotExcludedElement && !isForbiddenTagName && !isInputHidden && ariaHidden(element, show);\n    });\n  }\n  function findIndexOf(items, callback) {\n    let idx = -1;\n    items.some((item, index) => callback(item) ? (idx = index, !0) : !1);\n    return idx;\n  }\n  function handleContainer(containerInfo, props) {\n    const restoreStyle = [];\n    containerInfo = containerInfo.container;\n    if (!props.disableScrollLock) {\n      if (isOverflowing(containerInfo)) {\n        const scrollbarSize = (0,_utils.unstable_getScrollbarSize)((0,_utils.unstable_ownerDocument)(containerInfo));\n        restoreStyle.push({value:containerInfo.style.paddingRight, property:\"padding-right\", el:containerInfo});\n        containerInfo.style.paddingRight = `${getPaddingRight(containerInfo) + scrollbarSize}px`;\n        props = (0,_utils.unstable_ownerDocument)(containerInfo).querySelectorAll(\".mui-fixed\");\n        [].forEach.call(props, element => {\n          restoreStyle.push({value:element.style.paddingRight, property:\"padding-right\", el:element});\n          element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n        });\n      }\n      if (containerInfo.parentNode instanceof DocumentFragment) {\n        containerInfo = (0,_utils.unstable_ownerDocument)(containerInfo).body;\n      } else {\n        props = containerInfo.parentElement;\n        const containerWindow = (0,_utils.unstable_ownerWindow)(containerInfo);\n        containerInfo = \"HTML\" === (null == props ? void 0 : props.nodeName) && \"scroll\" === containerWindow.getComputedStyle(props).overflowY ? props : containerInfo;\n      }\n      restoreStyle.push({value:containerInfo.style.overflow, property:\"overflow\", el:containerInfo}, {value:containerInfo.style.overflowX, property:\"overflow-x\", el:containerInfo}, {value:containerInfo.style.overflowY, property:\"overflow-y\", el:containerInfo});\n      containerInfo.style.overflow = \"hidden\";\n    }\n    return () => {\n      restoreStyle.forEach(({value, el, property}) => {\n        value ? el.style.setProperty(property, value) : el.style.removeProperty(property);\n      });\n    };\n  }\n  function getHiddenSiblings(container) {\n    const hiddenSiblings = [];\n    [].forEach.call(container.children, element => {\n      \"true\" === element.getAttribute(\"aria-hidden\") && hiddenSiblings.push(element);\n    });\n    return hiddenSiblings;\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.ModalManager = void 0;\n  exports.ariaHidden = ariaHidden;\n  var _utils = require(\"module$node_modules$$mui$utils$node$index\");\n  class ModalManager {\n    constructor() {\n      this.modals = [];\n      this.containers = [];\n    }\n    add(modal, container) {\n      let modalIndex = this.modals.indexOf(modal);\n      if (-1 !== modalIndex) {\n        return modalIndex;\n      }\n      modalIndex = this.modals.length;\n      this.modals.push(modal);\n      modal.modalRef && ariaHidden(modal.modalRef, !1);\n      const hiddenSiblings = getHiddenSiblings(container);\n      ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, !0);\n      const containerIndex = findIndexOf(this.containers, item => item.container === container);\n      if (-1 !== containerIndex) {\n        return this.containers[containerIndex].modals.push(modal), modalIndex;\n      }\n      this.containers.push({modals:[modal], container, restore:null, hiddenSiblings});\n      return modalIndex;\n    }\n    mount(modal, props) {\n      var containerIndex = findIndexOf(this.containers, item => -1 !== item.modals.indexOf(modal));\n      containerIndex = this.containers[containerIndex];\n      containerIndex.restore || (containerIndex.restore = handleContainer(containerIndex, props));\n    }\n    remove(modal, ariaHiddenState = !0) {\n      const modalIndex = this.modals.indexOf(modal);\n      if (-1 === modalIndex) {\n        return modalIndex;\n      }\n      const containerIndex = findIndexOf(this.containers, item => -1 !== item.modals.indexOf(modal)), containerInfo = this.containers[containerIndex];\n      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n      this.modals.splice(modalIndex, 1);\n      0 === containerInfo.modals.length ? (containerInfo.restore && containerInfo.restore(), modal.modalRef && ariaHidden(modal.modalRef, ariaHiddenState), ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, !1), this.containers.splice(containerIndex, 1)) : (ariaHiddenState = containerInfo.modals[containerInfo.modals.length - 1], ariaHiddenState.modalRef && ariaHidden(ariaHiddenState.modalRef, !1));\n      return modalIndex;\n    }\n    isTopModal(modal) {\n      return 0 < this.modals.length && this.modals[this.modals.length - 1] === modal;\n    }\n  }\n  exports.ModalManager = ModalManager;\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$base$node$unstable_useModal$ModalManager\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModalManager = void 0;\nexports.ariaHidden = ariaHidden;\nvar _utils = require(\"@mui/utils\");\n// Is a vertical scrollbar displayed?\nfunction isOverflowing(container) {\n  const doc = (0, _utils.unstable_ownerDocument)(container);\n  if (doc.body === container) {\n    return (0, _utils.unstable_ownerWindow)(container).innerWidth > doc.documentElement.clientWidth;\n  }\n  return container.scrollHeight > container.clientHeight;\n}\nfunction ariaHidden(element, show) {\n  if (show) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\nfunction getPaddingRight(element) {\n  return parseInt((0, _utils.unstable_ownerWindow)(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\nfunction isAriaHiddenForbiddenOnElement(element) {\n  // The forbidden HTML tags are the ones from ARIA specification that\n  // can be children of body and can't have aria-hidden attribute.\n  // cf. https://www.w3.org/TR/html-aria/#docconformance\n  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];\n  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;\n  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';\n  return isForbiddenTagName || isInputHidden;\n}\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n  [].forEach.call(container.children, element => {\n    const isNotExcludedElement = blacklist.indexOf(element) === -1;\n    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n    if (isNotExcludedElement && isNotForbiddenElement) {\n      ariaHidden(element, show);\n    }\n  });\n}\nfunction findIndexOf(items, callback) {\n  let idx = -1;\n  items.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n    return false;\n  });\n  return idx;\n}\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const container = containerInfo.container;\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = (0, _utils.unstable_getScrollbarSize)((0, _utils.unstable_ownerDocument)(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      });\n      // Use computed style, here to get the real padding to add our scrollbar width.\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;\n\n      // .mui-fixed is a global helper.\n      const fixedElements = (0, _utils.unstable_ownerDocument)(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, element => {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n      });\n    }\n    let scrollContainer;\n    if (container.parentNode instanceof DocumentFragment) {\n      scrollContainer = (0, _utils.unstable_ownerDocument)(container).body;\n    } else {\n      // Support html overflow-y: auto for scroll stability between pages\n      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n      const parent = container.parentElement;\n      const containerWindow = (0, _utils.unstable_ownerWindow)(container);\n      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;\n    }\n\n    // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n  const restore = () => {\n    restoreStyle.forEach(({\n      value,\n      el,\n      property\n    }) => {\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n  return restore;\n}\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, element => {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\nclass ModalManager {\n  constructor() {\n    this.containers = void 0;\n    this.modals = void 0;\n    this.modals = [];\n    this.containers = [];\n  }\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n    modalIndex = this.modals.length;\n    this.modals.push(modal);\n\n    // If the modal we are adding is already in the DOM.\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n    const hiddenSiblings = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblings\n    });\n    return modalIndex;\n  }\n  mount(modal, props) {\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n  remove(modal, ariaHiddenState = true) {\n    const modalIndex = this.modals.indexOf(modal);\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1);\n\n    // If that was the last modal in a container, clean up the container.\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, ariaHiddenState);\n      }\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];\n      // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n    return modalIndex;\n  }\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n}\nexports.ModalManager = ModalManager;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$mui$utils$node$index"]],"~:properties",["^5",["el","ariaHidden","__esModule","ModalManager","value","property","modals","overflow","restore","hiddenSiblings","containers","container","paddingRight"]],"~:compiled-at",1712152511244,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$base$node$unstable_useModal$ModalManager.js\",\n\"lineCount\":109,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/base/node/unstable_useModal/ModalManager.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$base$node$unstable_useModal$ModalManager\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ModalManager = void 0;\\nexports.ariaHidden = ariaHidden;\\nvar _utils = require(\\\"@mui/utils\\\");\\n// Is a vertical scrollbar displayed?\\nfunction isOverflowing(container) {\\n  const doc = (0, _utils.unstable_ownerDocument)(container);\\n  if (doc.body === container) {\\n    return (0, _utils.unstable_ownerWindow)(container).innerWidth > doc.documentElement.clientWidth;\\n  }\\n  return container.scrollHeight > container.clientHeight;\\n}\\nfunction ariaHidden(element, show) {\\n  if (show) {\\n    element.setAttribute('aria-hidden', 'true');\\n  } else {\\n    element.removeAttribute('aria-hidden');\\n  }\\n}\\nfunction getPaddingRight(element) {\\n  return parseInt((0, _utils.unstable_ownerWindow)(element).getComputedStyle(element).paddingRight, 10) || 0;\\n}\\nfunction isAriaHiddenForbiddenOnElement(element) {\\n  // The forbidden HTML tags are the ones from ARIA specification that\\n  // can be children of body and can't have aria-hidden attribute.\\n  // cf. https://www.w3.org/TR/html-aria/#docconformance\\n  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];\\n  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;\\n  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';\\n  return isForbiddenTagName || isInputHidden;\\n}\\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {\\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\\n  [].forEach.call(container.children, element => {\\n    const isNotExcludedElement = blacklist.indexOf(element) === -1;\\n    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\\n    if (isNotExcludedElement && isNotForbiddenElement) {\\n      ariaHidden(element, show);\\n    }\\n  });\\n}\\nfunction findIndexOf(items, callback) {\\n  let idx = -1;\\n  items.some((item, index) => {\\n    if (callback(item)) {\\n      idx = index;\\n      return true;\\n    }\\n    return false;\\n  });\\n  return idx;\\n}\\nfunction handleContainer(containerInfo, props) {\\n  const restoreStyle = [];\\n  const container = containerInfo.container;\\n  if (!props.disableScrollLock) {\\n    if (isOverflowing(container)) {\\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\\n      const scrollbarSize = (0, _utils.unstable_getScrollbarSize)((0, _utils.unstable_ownerDocument)(container));\\n      restoreStyle.push({\\n        value: container.style.paddingRight,\\n        property: 'padding-right',\\n        el: container\\n      });\\n      // Use computed style, here to get the real padding to add our scrollbar width.\\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;\\n\\n      // .mui-fixed is a global helper.\\n      const fixedElements = (0, _utils.unstable_ownerDocument)(container).querySelectorAll('.mui-fixed');\\n      [].forEach.call(fixedElements, element => {\\n        restoreStyle.push({\\n          value: element.style.paddingRight,\\n          property: 'padding-right',\\n          el: element\\n        });\\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\\n      });\\n    }\\n    let scrollContainer;\\n    if (container.parentNode instanceof DocumentFragment) {\\n      scrollContainer = (0, _utils.unstable_ownerDocument)(container).body;\\n    } else {\\n      // Support html overflow-y: auto for scroll stability between pages\\n      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\\n      const parent = container.parentElement;\\n      const containerWindow = (0, _utils.unstable_ownerWindow)(container);\\n      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;\\n    }\\n\\n    // Block the scroll even if no scrollbar is visible to account for mobile keyboard\\n    // screensize shrink.\\n    restoreStyle.push({\\n      value: scrollContainer.style.overflow,\\n      property: 'overflow',\\n      el: scrollContainer\\n    }, {\\n      value: scrollContainer.style.overflowX,\\n      property: 'overflow-x',\\n      el: scrollContainer\\n    }, {\\n      value: scrollContainer.style.overflowY,\\n      property: 'overflow-y',\\n      el: scrollContainer\\n    });\\n    scrollContainer.style.overflow = 'hidden';\\n  }\\n  const restore = () => {\\n    restoreStyle.forEach(({\\n      value,\\n      el,\\n      property\\n    }) => {\\n      if (value) {\\n        el.style.setProperty(property, value);\\n      } else {\\n        el.style.removeProperty(property);\\n      }\\n    });\\n  };\\n  return restore;\\n}\\nfunction getHiddenSiblings(container) {\\n  const hiddenSiblings = [];\\n  [].forEach.call(container.children, element => {\\n    if (element.getAttribute('aria-hidden') === 'true') {\\n      hiddenSiblings.push(element);\\n    }\\n  });\\n  return hiddenSiblings;\\n}\\n/**\\n * @ignore - do not document.\\n *\\n * Proper state management for containers and the modals in those containers.\\n * Simplified, but inspired by react-overlay's ModalManager class.\\n * Used by the Modal to ensure proper styling of containers.\\n */\\nclass ModalManager {\\n  constructor() {\\n    this.containers = void 0;\\n    this.modals = void 0;\\n    this.modals = [];\\n    this.containers = [];\\n  }\\n  add(modal, container) {\\n    let modalIndex = this.modals.indexOf(modal);\\n    if (modalIndex !== -1) {\\n      return modalIndex;\\n    }\\n    modalIndex = this.modals.length;\\n    this.modals.push(modal);\\n\\n    // If the modal we are adding is already in the DOM.\\n    if (modal.modalRef) {\\n      ariaHidden(modal.modalRef, false);\\n    }\\n    const hiddenSiblings = getHiddenSiblings(container);\\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\\n    if (containerIndex !== -1) {\\n      this.containers[containerIndex].modals.push(modal);\\n      return modalIndex;\\n    }\\n    this.containers.push({\\n      modals: [modal],\\n      container,\\n      restore: null,\\n      hiddenSiblings\\n    });\\n    return modalIndex;\\n  }\\n  mount(modal, props) {\\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\\n    const containerInfo = this.containers[containerIndex];\\n    if (!containerInfo.restore) {\\n      containerInfo.restore = handleContainer(containerInfo, props);\\n    }\\n  }\\n  remove(modal, ariaHiddenState = true) {\\n    const modalIndex = this.modals.indexOf(modal);\\n    if (modalIndex === -1) {\\n      return modalIndex;\\n    }\\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\\n    const containerInfo = this.containers[containerIndex];\\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\\n    this.modals.splice(modalIndex, 1);\\n\\n    // If that was the last modal in a container, clean up the container.\\n    if (containerInfo.modals.length === 0) {\\n      // The modal might be closed before it had the chance to be mounted in the DOM.\\n      if (containerInfo.restore) {\\n        containerInfo.restore();\\n      }\\n      if (modal.modalRef) {\\n        // In case the modal wasn't in the DOM yet.\\n        ariaHidden(modal.modalRef, ariaHiddenState);\\n      }\\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\\n      this.containers.splice(containerIndex, 1);\\n    } else {\\n      // Otherwise make sure the next top modal is visible to a screen reader.\\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];\\n      // as soon as a modal is adding its modalRef is undefined. it can't set\\n      // aria-hidden because the dom element doesn't exist either\\n      // when modal was unmounted before modalRef gets null\\n      if (nextTop.modalRef) {\\n        ariaHidden(nextTop.modalRef, false);\\n      }\\n    }\\n    return modalIndex;\\n  }\\n  isTopModal(modal) {\\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\\n  }\\n}\\nexports.ModalManager = ModalManager;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isOverflowing\",\"container\",\"doc\",\"_utils\",\"unstable_ownerDocument\",\"body\",\"unstable_ownerWindow\",\"innerWidth\",\"documentElement\",\"clientWidth\",\"scrollHeight\",\"clientHeight\",\"ariaHidden\",\"element\",\"show\",\"setAttribute\",\"removeAttribute\",\"getPaddingRight\",\"parseInt\",\"getComputedStyle\",\"paddingRight\",\"ariaHiddenSiblings\",\"mountElement\",\"currentElement\",\"elementsToExclude\",\"blacklist\",\"forEach\",\"call\",\"children\",\"isNotExcludedElement\",\"indexOf\",\"isForbiddenTagName\",\"forbiddenTagNames\",\"tagName\",\"isInputHidden\",\"getAttribute\",\"findIndexOf\",\"items\",\"callback\",\"idx\",\"some\",\"item\",\"index\",\"handleContainer\",\"containerInfo\",\"props\",\"restoreStyle\",\"disableScrollLock\",\"scrollbarSize\",\"unstable_getScrollbarSize\",\"push\",\"value\",\"style\",\"property\",\"el\",\"fixedElements\",\"querySelectorAll\",\"parentNode\",\"DocumentFragment\",\"scrollContainer\",\"parent\",\"parentElement\",\"containerWindow\",\"nodeName\",\"overflowY\",\"overflow\",\"overflowX\",\"restore\",\"setProperty\",\"removeProperty\",\"getHiddenSiblings\",\"hiddenSiblings\",\"Object\",\"defineProperty\",\"ModalManager\",\"constructor\",\"modals\",\"containers\",\"add\",\"modal\",\"modalIndex\",\"length\",\"modalRef\",\"mount\",\"containerIndex\",\"remove\",\"ariaHiddenState\",\"splice\",\"nextTop\",\"isTopModal\"]\n}\n"]