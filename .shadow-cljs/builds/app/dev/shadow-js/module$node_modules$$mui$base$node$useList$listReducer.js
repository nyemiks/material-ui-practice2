["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/base/node/useList/listReducer.js"],"~:js","shadow$provide.module$node_modules$$mui$base$node$useList$listReducer = function(global, require, module, exports) {\n  function findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {\n    if (0 === items.length || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {\n      return -1;\n    }\n    for (;;) {\n      if (!wrapAround && \"next\" === lookupDirection && currentIndex === items.length || !wrapAround && \"previous\" === lookupDirection && -1 === currentIndex) {\n        return -1;\n      }\n      if (includeDisabledItems ? 0 : isItemDisabled(items[currentIndex], currentIndex)) {\n        currentIndex += \"next\" === lookupDirection ? 1 : -1, wrapAround && (currentIndex = (currentIndex + items.length) % items.length);\n      } else {\n        return currentIndex;\n      }\n    }\n  }\n  function moveHighlight(previouslyHighlightedValue, offset, context) {\n    var _items$nextIndex;\n    const {items, isItemDisabled, disableListWrap, disabledItemsFocusable, itemComparer, focusManagement} = context;\n    var defaultHighlightedIndex = \"DOM\" === focusManagement ? 0 : -1, maxIndex = items.length - 1;\n    context = null == previouslyHighlightedValue ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));\n    let wrapAround = !disableListWrap;\n    switch(offset) {\n      case \"reset\":\n        if (-1 === defaultHighlightedIndex) {\n          return null;\n        }\n        maxIndex = 0;\n        offset = \"next\";\n        wrapAround = !1;\n        break;\n      case \"start\":\n        maxIndex = 0;\n        offset = \"next\";\n        wrapAround = !1;\n        break;\n      case \"end\":\n        offset = \"previous\";\n        wrapAround = !1;\n        break;\n      default:\n        defaultHighlightedIndex = context + offset, 0 > defaultHighlightedIndex ? !wrapAround && -1 !== context || 1 < Math.abs(offset) ? (maxIndex = 0, offset = \"next\") : offset = \"previous\" : defaultHighlightedIndex > maxIndex ? !wrapAround || 1 < Math.abs(offset) ? offset = \"previous\" : (maxIndex = 0, offset = \"next\") : (maxIndex = defaultHighlightedIndex, offset = 0 <= offset ? \"next\" : \"previous\");\n    }\n    offset = findValidItemToHighlight(maxIndex, offset, items, disabledItemsFocusable, isItemDisabled, wrapAround);\n    return -1 !== offset || null === previouslyHighlightedValue || isItemDisabled(previouslyHighlightedValue, context) ? null != (_items$nextIndex = items[offset]) ? _items$nextIndex : null : previouslyHighlightedValue;\n  }\n  function toggleSelection(item, selectedValues, selectionMode, itemComparer) {\n    return \"none\" === selectionMode ? [] : \"single\" === selectionMode ? itemComparer(selectedValues[0], item) ? selectedValues : [item] : selectedValues.some(sv => itemComparer(sv, item)) ? selectedValues.filter(sv => !itemComparer(sv, item)) : [...selectedValues, item];\n  }\n  function handleItemSelection(item, state, context) {\n    const {itemComparer, isItemDisabled, selectionMode, items} = context;\n    ({selectedValues:context} = state);\n    const itemIndex = items.findIndex(i => itemComparer(item, i));\n    if (isItemDisabled(item, itemIndex)) {\n      return state;\n    }\n    context = toggleSelection(item, context, selectionMode, itemComparer);\n    return (0,_extends2.default)({}, state, {selectedValues:context, highlightedValue:item});\n  }\n  function handleKeyDown(key, state, context) {\n    const previouslySelectedValue = state.highlightedValue, {orientation, pageSize} = context;\n    switch(key) {\n      case \"Home\":\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, \"start\", context)});\n      case \"End\":\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, \"end\", context)});\n      case \"PageUp\":\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, -pageSize, context)});\n      case \"PageDown\":\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, pageSize, context)});\n      case \"ArrowUp\":\n        if (\"vertical\" !== orientation) {\n          break;\n        }\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, -1, context)});\n      case \"ArrowDown\":\n        if (\"vertical\" !== orientation) {\n          break;\n        }\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, 1, context)});\n      case \"ArrowLeft\":\n        if (\"vertical\" === orientation) {\n          break;\n        }\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, \"horizontal-ltr\" === orientation ? -1 : 1, context)});\n      case \"ArrowRight\":\n        if (\"vertical\" === orientation) {\n          break;\n        }\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, \"horizontal-ltr\" === orientation ? 1 : -1, context)});\n      case \"Enter\":\n      case \" \":\n        if (null !== state.highlightedValue) {\n          return handleItemSelection(state.highlightedValue, state, context);\n        }\n    }\n    return state;\n  }\n  function handleItemsChange(items, previousItems, state, context) {\n    var _state$selectedValues;\n    const {itemComparer, focusManagement} = context;\n    let newHighlightedValue = null;\n    if (null != state.highlightedValue) {\n      var _items$find;\n      newHighlightedValue = null != (_items$find = items.find(item => itemComparer(item, state.highlightedValue))) ? _items$find : null;\n    } else {\n      \"DOM\" === focusManagement && 0 === previousItems.length && (newHighlightedValue = moveHighlight(null, \"reset\", context));\n    }\n    previousItems = (null != (_state$selectedValues = state.selectedValues) ? _state$selectedValues : []).filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));\n    return (0,_extends2.default)({}, state, {highlightedValue:newHighlightedValue, selectedValues:previousItems});\n  }\n  global = require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.handleItemSelection = handleItemSelection;\n  exports.listReducer = function(state, action) {\n    const {type, context} = action;\n    switch(type) {\n      case _listActions.ListActionTypes.keyDown:\n        return handleKeyDown(action.key, state, context);\n      case _listActions.ListActionTypes.itemClick:\n        return handleItemSelection(action.item, state, context);\n      case _listActions.ListActionTypes.blur:\n        return state = \"DOM\" === context.focusManagement ? state : (0,_extends2.default)({}, state, {highlightedValue:null}), state;\n      case _listActions.ListActionTypes.textNavigation:\n        a: {\n          action = action.searchString;\n          const {items, isItemDisabled, disabledItemsFocusable, getItemAsString} = context, startWithCurrentItem = 1 < action.length;\n          let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);\n          for (let index = 0; index < items.length; index += 1) {\n            if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {\n              break a;\n            }\n            var _stringifyItem = void 0, searchString = action;\n            const text = null == (_stringifyItem = getItemAsString(nextItem)) ? void 0 : _stringifyItem.trim().toLowerCase();\n            if (text && 0 !== text.length && 0 === text.indexOf(searchString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {\n              state = (0,_extends2.default)({}, state, {highlightedValue:nextItem});\n              break a;\n            }\n            nextItem = moveHighlight(nextItem, 1, context);\n          }\n        }\n        return state;\n      case _listActions.ListActionTypes.itemsChange:\n        return handleItemsChange(action.items, action.previousItems, state, context);\n      case _listActions.ListActionTypes.resetHighlight:\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(null, \"reset\", context)});\n      case _listActions.ListActionTypes.highlightLast:\n        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(null, \"end\", context)});\n      case _listActions.ListActionTypes.clearSelection:\n        return (0,_extends2.default)({}, state, {selectedValues:[], highlightedValue:moveHighlight(null, \"reset\", context)});\n      default:\n        return state;\n    }\n  };\n  exports.moveHighlight = moveHighlight;\n  exports.toggleSelection = toggleSelection;\n  var _extends2 = global(require(\"module$node_modules$$babel$runtime$helpers$extends\")), _listActions = require(\"module$node_modules$$mui$base$node$useList$listActions_types\");\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$base$node$useList$listReducer\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleItemSelection = handleItemSelection;\nexports.listReducer = listReducer;\nexports.moveHighlight = moveHighlight;\nexports.toggleSelection = toggleSelection;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _listActions = require(\"./listActions.types\");\n/**\n * Looks up the next valid item to highlight within the list.\n *\n * @param currentIndex The index of the start of the search.\n * @param lookupDirection Whether to look for the next or previous item.\n * @param items The array of items to search.\n * @param includeDisabledItems Whether to include disabled items in the search.\n * @param isItemDisabled A function that determines whether an item is disabled.\n * @param wrapAround Whether to wrap around the list when searching.\n * @returns The index of the next valid item to highlight or -1 if no valid item is found.\n */\nfunction findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {\n  if (items.length === 0 || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {\n    return -1;\n  }\n  let nextFocus = currentIndex;\n  for (;;) {\n    // No valid items found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === items.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n    const nextFocusDisabled = includeDisabledItems ? false : isItemDisabled(items[nextFocus], nextFocus);\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n      if (wrapAround) {\n        nextFocus = (nextFocus + items.length) % items.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\n\n/**\n * Gets the next item to highlight based on the current highlighted item and the search direction.\n *\n * @param previouslyHighlightedValue The item from which to start the search for the next candidate.\n * @param offset The offset from the previously highlighted item to search for the next candidate or a special named value ('reset', 'start', 'end').\n * @param context The list action context.\n *\n * @returns The next item to highlight or null if no item is valid.\n */\nfunction moveHighlight(previouslyHighlightedValue, offset, context) {\n  var _items$nextIndex;\n  const {\n    items,\n    isItemDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    itemComparer,\n    focusManagement\n  } = context;\n\n  // TODO: make this configurable\n  // The always should be an item highlighted when focus is managed by the DOM\n  // so that it's accessible by the `tab` key.\n  const defaultHighlightedIndex = focusManagement === 'DOM' ? 0 : -1;\n  const maxIndex = items.length - 1;\n  const previouslyHighlightedIndex = previouslyHighlightedValue == null ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));\n  let nextIndexCandidate;\n  let lookupDirection;\n  let wrapAround = !disableListWrap;\n  switch (offset) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n    default:\n      {\n        const newIndex = previouslyHighlightedIndex + offset;\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(offset) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(offset) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = offset >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n  const nextIndex = findValidItemToHighlight(nextIndexCandidate, lookupDirection, items, disabledItemsFocusable, isItemDisabled, wrapAround);\n\n  // If there are no valid items to highlight, return the previously highlighted item (if it's still valid).\n  if (nextIndex === -1 && previouslyHighlightedValue !== null && !isItemDisabled(previouslyHighlightedValue, previouslyHighlightedIndex)) {\n    return previouslyHighlightedValue;\n  }\n  return (_items$nextIndex = items[nextIndex]) != null ? _items$nextIndex : null;\n}\n\n/**\n * Toggles the selection of an item.\n *\n * @param item Item to toggle.\n * @param selectedValues Already selected items.\n * @param selectionMode The number of items that can be simultanously selected.\n * @param itemComparer A custom item comparer function.\n *\n * @returns The new array of selected items.\n */\nfunction toggleSelection(item, selectedValues, selectionMode, itemComparer) {\n  if (selectionMode === 'none') {\n    return [];\n  }\n  if (selectionMode === 'single') {\n    // if the item to select has already been selected, return the original array\n    if (itemComparer(selectedValues[0], item)) {\n      return selectedValues;\n    }\n    return [item];\n  }\n\n  // The toggled item is selected; remove it from the selection.\n  if (selectedValues.some(sv => itemComparer(sv, item))) {\n    return selectedValues.filter(sv => !itemComparer(sv, item));\n  }\n\n  // The toggled item is not selected - add it to the selection.\n  return [...selectedValues, item];\n}\n\n/**\n * Handles item selection in a list.\n *\n * @param item - The item to be selected.\n * @param state - The current state of the list.\n * @param context - The context of the list action.\n * @returns The new state of the list after the item has been selected, or the original state if the item is disabled.\n */\nfunction handleItemSelection(item, state, context) {\n  const {\n    itemComparer,\n    isItemDisabled,\n    selectionMode,\n    items\n  } = context;\n  const {\n    selectedValues\n  } = state;\n  const itemIndex = items.findIndex(i => itemComparer(item, i));\n  if (isItemDisabled(item, itemIndex)) {\n    return state;\n  }\n\n  // if the item is already selected, remove it from the selection, otherwise add it\n  const newSelectedValues = toggleSelection(item, selectedValues, selectionMode, itemComparer);\n  return (0, _extends2.default)({}, state, {\n    selectedValues: newSelectedValues,\n    highlightedValue: item\n  });\n}\nfunction handleKeyDown(key, state, context) {\n  const previouslySelectedValue = state.highlightedValue;\n  const {\n    orientation,\n    pageSize\n  } = context;\n  switch (key) {\n    case 'Home':\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', context)\n      });\n    case 'End':\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', context)\n      });\n    case 'PageUp':\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, context)\n      });\n    case 'PageDown':\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, context)\n      });\n    case 'ArrowUp':\n      if (orientation !== 'vertical') {\n        break;\n      }\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, context)\n      });\n    case 'ArrowDown':\n      if (orientation !== 'vertical') {\n        break;\n      }\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, context)\n      });\n    case 'ArrowLeft':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n        const offset = orientation === 'horizontal-ltr' ? -1 : 1;\n        return (0, _extends2.default)({}, state, {\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        });\n      }\n    case 'ArrowRight':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n        const offset = orientation === 'horizontal-ltr' ? 1 : -1;\n        return (0, _extends2.default)({}, state, {\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        });\n      }\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n      return handleItemSelection(state.highlightedValue, state, context);\n    default:\n      break;\n  }\n  return state;\n}\nfunction handleBlur(state, context) {\n  if (context.focusManagement === 'DOM') {\n    return state;\n  }\n  return (0, _extends2.default)({}, state, {\n    highlightedValue: null\n  });\n}\nfunction textCriteriaMatches(nextFocus, searchString, stringifyItem) {\n  var _stringifyItem;\n  const text = (_stringifyItem = stringifyItem(nextFocus)) == null ? void 0 : _stringifyItem.trim().toLowerCase();\n  if (!text || text.length === 0) {\n    // Make item not navigable if stringification fails or results in empty string.\n    return false;\n  }\n  return text.indexOf(searchString) === 0;\n}\nfunction handleTextNavigation(state, searchString, context) {\n  const {\n    items,\n    isItemDisabled,\n    disabledItemsFocusable,\n    getItemAsString\n  } = context;\n  const startWithCurrentItem = searchString.length > 1;\n  let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);\n  for (let index = 0; index < items.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {\n      return state;\n    }\n    if (textCriteriaMatches(nextItem, searchString, getItemAsString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {\n      // The nextItem is the element to be highlighted\n      return (0, _extends2.default)({}, state, {\n        highlightedValue: nextItem\n      });\n    }\n    // Move to the next element.\n    nextItem = moveHighlight(nextItem, 1, context);\n  }\n\n  // No item matches the text search criteria\n  return state;\n}\nfunction handleItemsChange(items, previousItems, state, context) {\n  var _state$selectedValues;\n  const {\n    itemComparer,\n    focusManagement\n  } = context;\n  let newHighlightedValue = null;\n  if (state.highlightedValue != null) {\n    var _items$find;\n    newHighlightedValue = (_items$find = items.find(item => itemComparer(item, state.highlightedValue))) != null ? _items$find : null;\n  } else if (focusManagement === 'DOM' && previousItems.length === 0) {\n    newHighlightedValue = moveHighlight(null, 'reset', context);\n  }\n\n  // exclude selected values that are no longer in the items list\n  const selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];\n  const newSelectedValues = selectedValues.filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));\n  return (0, _extends2.default)({}, state, {\n    highlightedValue: newHighlightedValue,\n    selectedValues: newSelectedValues\n  });\n}\nfunction handleResetHighlight(state, context) {\n  return (0, _extends2.default)({}, state, {\n    highlightedValue: moveHighlight(null, 'reset', context)\n  });\n}\nfunction handleHighlightLast(state, context) {\n  return (0, _extends2.default)({}, state, {\n    highlightedValue: moveHighlight(null, 'end', context)\n  });\n}\nfunction handleClearSelection(state, context) {\n  return (0, _extends2.default)({}, state, {\n    selectedValues: [],\n    highlightedValue: moveHighlight(null, 'reset', context)\n  });\n}\nfunction listReducer(state, action) {\n  const {\n    type,\n    context\n  } = action;\n  switch (type) {\n    case _listActions.ListActionTypes.keyDown:\n      return handleKeyDown(action.key, state, context);\n    case _listActions.ListActionTypes.itemClick:\n      return handleItemSelection(action.item, state, context);\n    case _listActions.ListActionTypes.blur:\n      return handleBlur(state, context);\n    case _listActions.ListActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, context);\n    case _listActions.ListActionTypes.itemsChange:\n      return handleItemsChange(action.items, action.previousItems, state, context);\n    case _listActions.ListActionTypes.resetHighlight:\n      return handleResetHighlight(state, context);\n    case _listActions.ListActionTypes.highlightLast:\n      return handleHighlightLast(state, context);\n    case _listActions.ListActionTypes.clearSelection:\n      return handleClearSelection(state, context);\n    default:\n      return state;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$shadow.js","~$module$node_modules$$babel$runtime$helpers$extends","~$module$node_modules$$mui$base$node$useList$listActions_types"]],"~:properties",["^5",["selectedValues","__esModule","value","listReducer","highlightedValue","handleItemSelection","moveHighlight","toggleSelection"]],"~:compiled-at",1712152511069,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$base$node$useList$listReducer.js\",\n\"lineCount\":159,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,GAA2E,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAwBnHC,UAASA,yBAAwB,CAACC,YAAD,EAAeC,eAAf,EAAgCC,KAAhC,EAAuCC,oBAAvC,EAA6DC,cAA7D,EAA6EC,UAA7E,CAAyF;AACxH,QAAqB,CAArB,KAAIH,KAAMI,CAAAA,MAAV,IAA0B,CAACH,oBAA3B,IAAmDD,KAAMK,CAAAA,KAAN,CAAY,CAACC,IAAD,EAAOC,SAAP,CAAA,IAAqBL,cAAA,CAAeI,IAAf,EAAqBC,SAArB,CAAjC,CAAnD;AACE,aAAO,CAAC,CAAR;AADF;AAIA,SAAA,CAAA,CAAA,CAAS;AAEP,UAAI,CAACJ,UAAL,IAAuC,MAAvC,KAAmBJ,eAAnB,IAAiDS,YAAjD,KAA+DR,KAAMI,CAAAA,MAArE,IAA+E,CAACD,UAAhF,IAAkH,UAAlH,KAA8FJ,eAA9F,IAA8I,CAAC,CAA/I,KAAgIS,YAAhI;AACE,eAAO,CAAC,CAAR;AADF;AAIA,UAD0BP,oBAAAQ,GAAuB,CAAvBA,GAA+BP,cAAA,CAAeF,KAAA,CAAMQ,YAAN,CAAf,EAAiCA,YAAjC,CACzD;AACEA,oBACA,IADiC,MAApB,KAAAT,eAAA,GAA6B,CAA7B,GAAiC,CAAC,CAC/C,EAAII,UAAJ,KACEK,YADF,IACeA,YADf,GAC2BR,KAAMI,CAAAA,MADjC,IAC2CJ,KAAMI,CAAAA,MADjD,CAAA;AAFF;AAME,eAAOI,YAAP;AANF;AANO;AAL+G;AA+B1HE,UAASA,cAAa,CAACC,0BAAD,EAA6BC,MAA7B,EAAqCC,OAArC,CAA8C;AAClE,QAAIC,gBAAJ;AACA,UAAM,CACJd,KADI,EAEJE,cAFI,EAGJa,eAHI,EAIJC,sBAJI,EAKJC,YALI,EAMJC,eANI,CAAA,GAOFL,OAPJ;AAYA,QAAMM,0BAA8C,KAApB,KAAAD,eAAA,GAA4B,CAA5B,GAAgC,CAAC,CAAjE,EACME,WAAWpB,KAAMI,CAAAA,MAAjBgB,GAA0B,CADhC;AAEMC,WAAAA,GAA2D,IAA9B,IAAAV,0BAAA,GAAqC,CAAC,CAAtC,GAA0CX,KAAMsB,CAAAA,SAAN,CAAgBhB,IAAA,IAAQW,YAAA,CAAaX,IAAb,EAAmBK,0BAAnB,CAAxB,CAAvEU;AAGN,QAAIlB,aAAa,CAACY,eAAlB;AACA,WAAQH,MAAR;AACE,WAAK,OAAL;AACE,YAAgC,CAAC,CAAjC,KAAIO,uBAAJ;AACE,iBAAO,IAAP;AADF;AAGAI,gBAAA,GAAqB,CAArB;AACAxB,cAAA,GAAkB,MAAlB;AACAI,kBAAA,GAAa,CAAA,CAAb;AACA;AACF,WAAK,OAAL;AACEoB,gBAAA,GAAqB,CAArB;AACAxB,cAAA,GAAkB,MAAlB;AACAI,kBAAA,GAAa,CAAA,CAAb;AACA;AACF,WAAK,KAAL;AAEEJ,cAAA,GAAkB,UAAlB;AACAI,kBAAA,GAAa,CAAA,CAAb;AACA;AACF;AAEUqB,+BACN,GADiBH,OACjB,GAD8CT,MAC9C,EAAe,CAAf,GAAIY,uBAAJ,GACM,CAACrB,UAAL,IAAkD,CAAC,CAAnD,KAAmBkB,OAAnB,IAA2E,CAA3E,GAAwDI,IAAKC,CAAAA,GAAL,CAASd,MAAT,CAAxD,IACEW,QACA,GADqB,CACrB,EAAAxB,MAAA,GAAkB,MAFpB,IAKEA,MALF,GAKoB,UANtB,GAQWyB,uBAAJ,GAAeJ,QAAf,GACD,CAACjB,UAAL,IAAsC,CAAtC,GAAmBsB,IAAKC,CAAAA,GAAL,CAASd,MAAT,CAAnB,GAEEb,MAFF,GAEoB,UAFpB,IAIEwB,QACA,GADqB,CACrB,EAAAxB,MAAA,GAAkB,MALpB,CADK,IASLwB,QACA,GADqBC,uBACrB,EAAAzB,MAAA,GAA4B,CAAV,IAAAa,MAAA,GAAc,MAAd,GAAuB,UAVpC,CARP;AAtBN;AA4CMe,UAAAA,GAAY9B,wBAAA,CAAyB0B,QAAzB,EAA6CxB,MAA7C,EAA8DC,KAA9D,EAAqEgB,sBAArE,EAA6Fd,cAA7F,EAA6GC,UAA7G,CAAZwB;AAGN,WAAkB,CAAC,CAAnB,KAAIA,MAAJ,IAAuD,IAAvD,KAAwBhB,0BAAxB,IAAgET,cAAA,CAAeS,0BAAf,EAA2CU,OAA3C,CAAhE,GAGgD,IAAzC,KAACP,gBAAD,GAAoBd,KAAA,CAAM2B,MAAN,CAApB,IAAgDb,gBAAhD,GAAmE,IAH1E,GACSH,0BADT;AAnEkE;AAmFpEiB,UAASA,gBAAe,CAACtB,IAAD,EAAOuB,cAAP,EAAuBC,aAAvB,EAAsCb,YAAtC,CAAoD;AAC1E,WAAsB,MAAtB,KAAIa,aAAJ,GACS,EADT,GAGsB,QAAtB,KAAIA,aAAJ,GAEMb,YAAA,CAAaY,cAAA,CAAe,CAAf,CAAb,EAAgCvB,IAAhC,CAAJ,GACSuB,cADT,GAGO,CAACvB,IAAD,CALT,GASIuB,cAAeE,CAAAA,IAAf,CAAoBC,EAAA,IAAMf,YAAA,CAAae,EAAb,EAAiB1B,IAAjB,CAA1B,CAAJ,GACSuB,cAAeI,CAAAA,MAAf,CAAsBD,EAAA,IAAM,CAACf,YAAA,CAAae,EAAb,EAAiB1B,IAAjB,CAA7B,CADT,GAKO,CAAC,GAAGuB,cAAJ,EAAoBvB,IAApB,CAjBP;AAD0E;AA6B5E4B,UAASA,oBAAmB,CAAC5B,IAAD,EAAO6B,KAAP,EAActB,OAAd,CAAuB;AACjD,UAAM,CACJI,YADI,EAEJf,cAFI,EAGJ4B,aAHI,EAIJ9B,KAJI,CAAA,GAKFa,OALJ;AAMA,KAAM,CACJ,eAAAgB,OADI,CAAN,GAEIM,KAFJ;AAGA,UAAM5B,YAAYP,KAAMsB,CAAAA,SAAN,CAAgBc,CAAA,IAAKnB,YAAA,CAAaX,IAAb,EAAmB8B,CAAnB,CAArB,CAAlB;AACA,QAAIlC,cAAA,CAAeI,IAAf,EAAqBC,SAArB,CAAJ;AACE,aAAO4B,KAAP;AADF;AAKME,WAAAA,GAAoBT,eAAA,CAAgBtB,IAAhB,EAAsBuB,OAAtB,EAAsCC,aAAtC,EAAqDb,YAArD,CAApBoB;AACN,WAAO,GAAIC,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCN,eAAgBQ,OADuB,EAEvCG,iBAAkBlC,IAFqB,CAAlC,CAAP;AAjBiD;AAsBnDmC,UAASA,cAAa,CAACC,GAAD,EAAMP,KAAN,EAAatB,OAAb,CAAsB;AAC1C,UAAM8B,0BAA0BR,KAAMK,CAAAA,gBAAtC,EACM,CACJI,WADI,EAEJC,QAFI,CAAA,GAGFhC,OAJJ;AAKA,WAAQ6B,GAAR;AACE,WAAK,MAAL;AACE,eAAO,GAAIJ,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAAuC,OAAvC,EAAgD9B,OAAhD,CADqB,CAAlC,CAAP;AAGF,WAAK,KAAL;AACE,eAAO,GAAIyB,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAAuC,KAAvC,EAA8C9B,OAA9C,CADqB,CAAlC,CAAP;AAGF,WAAK,QAAL;AACE,eAAO,GAAIyB,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAAuC,CAACE,QAAxC,EAAkDhC,OAAlD,CADqB,CAAlC,CAAP;AAGF,WAAK,UAAL;AACE,eAAO,GAAIyB,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAAuCE,QAAvC,EAAiDhC,OAAjD,CADqB,CAAlC,CAAP;AAGF,WAAK,SAAL;AACE,YAAoB,UAApB,KAAI+B,WAAJ;AACE;AADF;AAGA,eAAO,GAAIN,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAAuC,CAAC,CAAxC,EAA2C9B,OAA3C,CADqB,CAAlC,CAAP;AAGF,WAAK,WAAL;AACE,YAAoB,UAApB,KAAI+B,WAAJ;AACE;AADF;AAGA,eAAO,GAAIN,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAAuC,CAAvC,EAA0C9B,OAA1C,CADqB,CAAlC,CAAP;AAGF,WAAK,WAAL;AAEI,YAAoB,UAApB,KAAI+B,WAAJ;AACE;AADF;AAIA,eAAO,GAAIN,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAFW,gBAAhB/B,KAAAgC,WAAAhC,GAAmC,CAAC,CAApCA,GAAwC,CAEnC,EAA+CC,OAA/C,CADqB,CAAlC,CAAP;AAIJ,WAAK,YAAL;AAEI,YAAoB,UAApB,KAAI+B,WAAJ;AACE;AADF;AAIA,eAAO,GAAIN,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAciC,uBAAd,EAFW,gBAAhB/B,KAAAgC,WAAAhC,GAAmC,CAAnCA,GAAuC,CAAC,CAEnC,EAA+CC,OAA/C,CADqB,CAAlC,CAAP;AAIJ,WAAK,OAAL;AACA,WAAK,GAAL;AACE,YAA+B,IAA/B,KAAIsB,KAAMK,CAAAA,gBAAV;AAGA,iBAAON,mBAAA,CAAoBC,KAAMK,CAAAA,gBAA1B,EAA4CL,KAA5C,EAAmDtB,OAAnD,CAAP;AAHA;AArDJ;AA4DA,WAAOsB,KAAP;AAlE0C;AAgH5CW,UAASA,kBAAiB,CAAC9C,KAAD,EAAQ+C,aAAR,EAAuBZ,KAAvB,EAA8BtB,OAA9B,CAAuC;AAC/D,QAAImC,qBAAJ;AACA,UAAM,CACJ/B,YADI,EAEJC,eAFI,CAAA,GAGFL,OAHJ;AAIA,QAAIoC,sBAAsB,IAA1B;AACA,QAA8B,IAA9B,IAAId,KAAMK,CAAAA,gBAAV,CAAoC;AAClC,UAAIU,WAAJ;AACAD,yBAAA,GAAwG,IAAlF,KAACC,WAAD,GAAelD,KAAMmD,CAAAA,IAAN,CAAW7C,IAAA,IAAQW,YAAA,CAAaX,IAAb,EAAmB6B,KAAMK,CAAAA,gBAAzB,CAAnB,CAAf,IAAyFU,WAAzF,GAAuG,IAA7H;AAFkC,KAApC;AAG+B,WAAxB,KAAIhC,eAAJ,IAA0D,CAA1D,KAAiC6B,aAAc3C,CAAAA,MAA/C,KACL6C,mBADK,GACiBvC,aAAA,CAAc,IAAd,EAAoB,OAApB,EAA6BG,OAA7B,CADjB;AAHP;AASMwB,iBAAAA,GAAmCJ,CADgC,IAAlDJ,KAACmB,qBAADnB,GAAyBM,KAAMN,CAAAA,cAA/BA,IAAyDmB,qBAAzDnB,GAAiF,EAC/DI,EAAAA,MAAf,CAAsBmB,aAAA,IAAiBpD,KAAM+B,CAAAA,IAAN,CAAWzB,IAAA,IAAQW,YAAA,CAAaX,IAAb,EAAmB8C,aAAnB,CAAnB,CAAvC,CAApBf;AACN,WAAO,GAAIC,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAA2BJ,KAA3B,EAAkC,CACvCK,iBAAkBS,mBADqB,EAEvCpB,eAAgBQ,aAFuB,CAAlC,CAAP;AAjB+D;AA1S7DgB,QAAAA,GAAyB3D,OAAA,CAAQ,kEAAR,CAAzB2D;AACJC,QAAOC,CAAAA,cAAP,CAAsB3D,OAAtB,EAA+B,YAA/B,EAA6C,CAC3C4D,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGA5D,SAAQsC,CAAAA,mBAAR,GAA8BA,mBAA9B;AACAtC,SAAQ6D,CAAAA,WAAR,GA2UAA,QAAoB,CAACtB,KAAD,EAAQuB,MAAR,CAAgB;AAClC,UAAM,CACJC,IADI,EAEJ9C,OAFI,CAAA,GAGF6C,MAHJ;AAIA,WAAQC,IAAR;AACE,WAAKC,YAAaC,CAAAA,eAAgBC,CAAAA,OAAlC;AACE,eAAOrB,aAAA,CAAciB,MAAOhB,CAAAA,GAArB,EAA0BP,KAA1B,EAAiCtB,OAAjC,CAAP;AACF,WAAK+C,YAAaC,CAAAA,eAAgBE,CAAAA,SAAlC;AACE,eAAO7B,mBAAA,CAAoBwB,MAAOpD,CAAAA,IAA3B,EAAiC6B,KAAjC,EAAwCtB,OAAxC,CAAP;AACF,WAAK+C,YAAaC,CAAAA,eAAgBG,CAAAA,IAAlC;AACE,eA3FF,KA2FS,GA5FqB,KAAhC,KA4F6BnD,OA5FjBK,CAAAA,eAAZ,GA4FsBiB,KA5FtB,GAGO,GAAIG,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAyFeJ,KAzFf,EAAkC,CACvCK,iBAAkB,IADqB,CAAlC,CAyFI,EAAA,KAAP;AACF,WAAKoB,YAAaC,CAAAA,eAAgBI,CAAAA,cAAlC;AA7EwD,SAAA,CAAA;AA8EZC,gBAAAA,GAAPR,MAAOQ,CAAAA,YAAAA;AA7E9C,gBAAM,CACJlE,KADI,EAEJE,cAFI,EAGJc,sBAHI,EAIJmD,eAJI,CAAA,GA6EsDtD,OA7E5D,EAMMuD,uBAA6C,CAA7CA,GAAuBF,MAAa9D,CAAAA,MAN1C;AAOA,cAAIiE,WAAWD,oBAAA,GAsEiBjC,KAtEYK,CAAAA,gBAA7B,GAAgD9B,aAAA,CAsE/ByB,KAtEmDK,CAAAA,gBAApB,EAAsC,CAAtC,EAsEH3B,OAtEG,CAA/D;AACA,eAAK,IAAIyD,QAAQ,CAAjB,EAAoBA,KAApB,GAA4BtE,KAAMI,CAAAA,MAAlC,EAA0CkE,KAA1C,IAAmD,CAAnD,CAAsD;AAEpD,gBAAI,CAACD,QAAL,IAAiB,CAACD,oBAAlB,IAmE8BjC,KAnEkBK,CAAAA,gBAAhD,KAAqE6B,QAArE;AACE,oBAAA,CAAA;AADF;AAnBF,gBAAIE,iBAAAA,IAAAA,EAAJ,EAsBoCL,eAAAA,MAtBpC;AACA,kBAAMM,OAAsD,IAA/C,KAACD,cAAD,GAqBqCJ,eArBnB,CAqBLE,QArBK,CAAlB,IAAsD,IAAK,EAA3D,GAA+DE,cAAeE,CAAAA,IAAf,EAAsBC,CAAAA,WAAtB,EAA5E;AAqBE,gBApBGF,IAoBH,IApB2B,CAoB3B,KApBWA,IAAKpE,CAAAA,MAoBhB,IAhBoC,CAgBpC,KAhBKoE,IAAKG,CAAAA,OAAL,CAAaT,YAAb,CAgBL,KAAqE,CAAChE,cAAA,CAAemE,QAAf,EAAyBrE,KAAM2E,CAAAA,OAAN,CAAcN,QAAd,CAAzB,CAAtE,IAA2HrD,sBAA3H,EAAoJ;AAElJ,mBAAA,GAAO,GAAIsB,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EA8DqBJ,KA9DrB,EAAkC,CACvCK,iBAAkB6B,QADqB,CAAlC,CAAP;AAAA,oBAAA,CAAA;AAFkJ;AAOpJA,oBAAA,GAAW3D,aAAA,CAAc2D,QAAd,EAAwB,CAAxB,EAyD+CxD,OAzD/C,CAAX;AAZoD;AATI;AA8EtD,eAAO,KAAP;AACF,WAAK+C,YAAaC,CAAAA,eAAgBe,CAAAA,WAAlC;AACE,eAAO9B,iBAAA,CAAkBY,MAAO1D,CAAAA,KAAzB,EAAgC0D,MAAOX,CAAAA,aAAvC,EAAsDZ,KAAtD,EAA6DtB,OAA7D,CAAP;AACF,WAAK+C,YAAaC,CAAAA,eAAgBgB,CAAAA,cAAlC;AACE,eAhCG,GAAIvC,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EAgCyBJ,KAhCzB,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAc,IAAd,EAAoB,OAApB,EA+BmBG,OA/BnB,CADqB,CAAlC,CAgCH;AACF,WAAK+C,YAAaC,CAAAA,eAAgBiB,CAAAA,aAAlC;AACE,eA7BG,GAAIxC,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EA6BwBJ,KA7BxB,EAAkC,CACvCK,iBAAkB9B,aAAA,CAAc,IAAd,EAAoB,KAApB,EA4BkBG,OA5BlB,CADqB,CAAlC,CA6BH;AACF,WAAK+C,YAAaC,CAAAA,eAAgBkB,CAAAA,cAAlC;AACE,eA1BG,GAAIzC,SAAUC,CAAAA,OAAd,EAAuB,EAAvB,EA0ByBJ,KA1BzB,EAAkC,CACvCN,eAAgB,EADuB,EAEvCW,iBAAkB9B,aAAA,CAAc,IAAd,EAAoB,OAApB,EAwBmBG,OAxBnB,CAFqB,CAAlC,CA0BH;AACF;AACE,eAAOsB,KAAP;AAlBJ;AALkC,GA3UpC;AACAvC,SAAQc,CAAAA,aAAR,GAAwBA,aAAxB;AACAd,SAAQgC,CAAAA,eAAR,GAA0BA,eAA1B;AACA,MAAIU,YAAYe,MAAA,CAAuB3D,OAAA,CAAQ,oDAAR,CAAvB,CAAhB,EACIkE,eAAelE,OAAA,CAAQ,8DAAR,CADnB;AAXmH,CAAnH;;\",\n\"sources\":[\"node_modules/@mui/base/node/useList/listReducer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$base$node$useList$listReducer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.handleItemSelection = handleItemSelection;\\nexports.listReducer = listReducer;\\nexports.moveHighlight = moveHighlight;\\nexports.toggleSelection = toggleSelection;\\nvar _extends2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/extends\\\"));\\nvar _listActions = require(\\\"./listActions.types\\\");\\n/**\\n * Looks up the next valid item to highlight within the list.\\n *\\n * @param currentIndex The index of the start of the search.\\n * @param lookupDirection Whether to look for the next or previous item.\\n * @param items The array of items to search.\\n * @param includeDisabledItems Whether to include disabled items in the search.\\n * @param isItemDisabled A function that determines whether an item is disabled.\\n * @param wrapAround Whether to wrap around the list when searching.\\n * @returns The index of the next valid item to highlight or -1 if no valid item is found.\\n */\\nfunction findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {\\n  if (items.length === 0 || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {\\n    return -1;\\n  }\\n  let nextFocus = currentIndex;\\n  for (;;) {\\n    // No valid items found\\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === items.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\\n      return -1;\\n    }\\n    const nextFocusDisabled = includeDisabledItems ? false : isItemDisabled(items[nextFocus], nextFocus);\\n    if (nextFocusDisabled) {\\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\\n      if (wrapAround) {\\n        nextFocus = (nextFocus + items.length) % items.length;\\n      }\\n    } else {\\n      return nextFocus;\\n    }\\n  }\\n}\\n\\n/**\\n * Gets the next item to highlight based on the current highlighted item and the search direction.\\n *\\n * @param previouslyHighlightedValue The item from which to start the search for the next candidate.\\n * @param offset The offset from the previously highlighted item to search for the next candidate or a special named value ('reset', 'start', 'end').\\n * @param context The list action context.\\n *\\n * @returns The next item to highlight or null if no item is valid.\\n */\\nfunction moveHighlight(previouslyHighlightedValue, offset, context) {\\n  var _items$nextIndex;\\n  const {\\n    items,\\n    isItemDisabled,\\n    disableListWrap,\\n    disabledItemsFocusable,\\n    itemComparer,\\n    focusManagement\\n  } = context;\\n\\n  // TODO: make this configurable\\n  // The always should be an item highlighted when focus is managed by the DOM\\n  // so that it's accessible by the `tab` key.\\n  const defaultHighlightedIndex = focusManagement === 'DOM' ? 0 : -1;\\n  const maxIndex = items.length - 1;\\n  const previouslyHighlightedIndex = previouslyHighlightedValue == null ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));\\n  let nextIndexCandidate;\\n  let lookupDirection;\\n  let wrapAround = !disableListWrap;\\n  switch (offset) {\\n    case 'reset':\\n      if (defaultHighlightedIndex === -1) {\\n        return null;\\n      }\\n      nextIndexCandidate = 0;\\n      lookupDirection = 'next';\\n      wrapAround = false;\\n      break;\\n    case 'start':\\n      nextIndexCandidate = 0;\\n      lookupDirection = 'next';\\n      wrapAround = false;\\n      break;\\n    case 'end':\\n      nextIndexCandidate = maxIndex;\\n      lookupDirection = 'previous';\\n      wrapAround = false;\\n      break;\\n    default:\\n      {\\n        const newIndex = previouslyHighlightedIndex + offset;\\n        if (newIndex < 0) {\\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(offset) > 1) {\\n            nextIndexCandidate = 0;\\n            lookupDirection = 'next';\\n          } else {\\n            nextIndexCandidate = maxIndex;\\n            lookupDirection = 'previous';\\n          }\\n        } else if (newIndex > maxIndex) {\\n          if (!wrapAround || Math.abs(offset) > 1) {\\n            nextIndexCandidate = maxIndex;\\n            lookupDirection = 'previous';\\n          } else {\\n            nextIndexCandidate = 0;\\n            lookupDirection = 'next';\\n          }\\n        } else {\\n          nextIndexCandidate = newIndex;\\n          lookupDirection = offset >= 0 ? 'next' : 'previous';\\n        }\\n      }\\n  }\\n  const nextIndex = findValidItemToHighlight(nextIndexCandidate, lookupDirection, items, disabledItemsFocusable, isItemDisabled, wrapAround);\\n\\n  // If there are no valid items to highlight, return the previously highlighted item (if it's still valid).\\n  if (nextIndex === -1 && previouslyHighlightedValue !== null && !isItemDisabled(previouslyHighlightedValue, previouslyHighlightedIndex)) {\\n    return previouslyHighlightedValue;\\n  }\\n  return (_items$nextIndex = items[nextIndex]) != null ? _items$nextIndex : null;\\n}\\n\\n/**\\n * Toggles the selection of an item.\\n *\\n * @param item Item to toggle.\\n * @param selectedValues Already selected items.\\n * @param selectionMode The number of items that can be simultanously selected.\\n * @param itemComparer A custom item comparer function.\\n *\\n * @returns The new array of selected items.\\n */\\nfunction toggleSelection(item, selectedValues, selectionMode, itemComparer) {\\n  if (selectionMode === 'none') {\\n    return [];\\n  }\\n  if (selectionMode === 'single') {\\n    // if the item to select has already been selected, return the original array\\n    if (itemComparer(selectedValues[0], item)) {\\n      return selectedValues;\\n    }\\n    return [item];\\n  }\\n\\n  // The toggled item is selected; remove it from the selection.\\n  if (selectedValues.some(sv => itemComparer(sv, item))) {\\n    return selectedValues.filter(sv => !itemComparer(sv, item));\\n  }\\n\\n  // The toggled item is not selected - add it to the selection.\\n  return [...selectedValues, item];\\n}\\n\\n/**\\n * Handles item selection in a list.\\n *\\n * @param item - The item to be selected.\\n * @param state - The current state of the list.\\n * @param context - The context of the list action.\\n * @returns The new state of the list after the item has been selected, or the original state if the item is disabled.\\n */\\nfunction handleItemSelection(item, state, context) {\\n  const {\\n    itemComparer,\\n    isItemDisabled,\\n    selectionMode,\\n    items\\n  } = context;\\n  const {\\n    selectedValues\\n  } = state;\\n  const itemIndex = items.findIndex(i => itemComparer(item, i));\\n  if (isItemDisabled(item, itemIndex)) {\\n    return state;\\n  }\\n\\n  // if the item is already selected, remove it from the selection, otherwise add it\\n  const newSelectedValues = toggleSelection(item, selectedValues, selectionMode, itemComparer);\\n  return (0, _extends2.default)({}, state, {\\n    selectedValues: newSelectedValues,\\n    highlightedValue: item\\n  });\\n}\\nfunction handleKeyDown(key, state, context) {\\n  const previouslySelectedValue = state.highlightedValue;\\n  const {\\n    orientation,\\n    pageSize\\n  } = context;\\n  switch (key) {\\n    case 'Home':\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', context)\\n      });\\n    case 'End':\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', context)\\n      });\\n    case 'PageUp':\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, context)\\n      });\\n    case 'PageDown':\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, context)\\n      });\\n    case 'ArrowUp':\\n      if (orientation !== 'vertical') {\\n        break;\\n      }\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, context)\\n      });\\n    case 'ArrowDown':\\n      if (orientation !== 'vertical') {\\n        break;\\n      }\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, context)\\n      });\\n    case 'ArrowLeft':\\n      {\\n        if (orientation === 'vertical') {\\n          break;\\n        }\\n        const offset = orientation === 'horizontal-ltr' ? -1 : 1;\\n        return (0, _extends2.default)({}, state, {\\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\\n        });\\n      }\\n    case 'ArrowRight':\\n      {\\n        if (orientation === 'vertical') {\\n          break;\\n        }\\n        const offset = orientation === 'horizontal-ltr' ? 1 : -1;\\n        return (0, _extends2.default)({}, state, {\\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\\n        });\\n      }\\n    case 'Enter':\\n    case ' ':\\n      if (state.highlightedValue === null) {\\n        return state;\\n      }\\n      return handleItemSelection(state.highlightedValue, state, context);\\n    default:\\n      break;\\n  }\\n  return state;\\n}\\nfunction handleBlur(state, context) {\\n  if (context.focusManagement === 'DOM') {\\n    return state;\\n  }\\n  return (0, _extends2.default)({}, state, {\\n    highlightedValue: null\\n  });\\n}\\nfunction textCriteriaMatches(nextFocus, searchString, stringifyItem) {\\n  var _stringifyItem;\\n  const text = (_stringifyItem = stringifyItem(nextFocus)) == null ? void 0 : _stringifyItem.trim().toLowerCase();\\n  if (!text || text.length === 0) {\\n    // Make item not navigable if stringification fails or results in empty string.\\n    return false;\\n  }\\n  return text.indexOf(searchString) === 0;\\n}\\nfunction handleTextNavigation(state, searchString, context) {\\n  const {\\n    items,\\n    isItemDisabled,\\n    disabledItemsFocusable,\\n    getItemAsString\\n  } = context;\\n  const startWithCurrentItem = searchString.length > 1;\\n  let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);\\n  for (let index = 0; index < items.length; index += 1) {\\n    // Return un-mutated state if looped back to the currently highlighted value\\n    if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {\\n      return state;\\n    }\\n    if (textCriteriaMatches(nextItem, searchString, getItemAsString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {\\n      // The nextItem is the element to be highlighted\\n      return (0, _extends2.default)({}, state, {\\n        highlightedValue: nextItem\\n      });\\n    }\\n    // Move to the next element.\\n    nextItem = moveHighlight(nextItem, 1, context);\\n  }\\n\\n  // No item matches the text search criteria\\n  return state;\\n}\\nfunction handleItemsChange(items, previousItems, state, context) {\\n  var _state$selectedValues;\\n  const {\\n    itemComparer,\\n    focusManagement\\n  } = context;\\n  let newHighlightedValue = null;\\n  if (state.highlightedValue != null) {\\n    var _items$find;\\n    newHighlightedValue = (_items$find = items.find(item => itemComparer(item, state.highlightedValue))) != null ? _items$find : null;\\n  } else if (focusManagement === 'DOM' && previousItems.length === 0) {\\n    newHighlightedValue = moveHighlight(null, 'reset', context);\\n  }\\n\\n  // exclude selected values that are no longer in the items list\\n  const selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];\\n  const newSelectedValues = selectedValues.filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));\\n  return (0, _extends2.default)({}, state, {\\n    highlightedValue: newHighlightedValue,\\n    selectedValues: newSelectedValues\\n  });\\n}\\nfunction handleResetHighlight(state, context) {\\n  return (0, _extends2.default)({}, state, {\\n    highlightedValue: moveHighlight(null, 'reset', context)\\n  });\\n}\\nfunction handleHighlightLast(state, context) {\\n  return (0, _extends2.default)({}, state, {\\n    highlightedValue: moveHighlight(null, 'end', context)\\n  });\\n}\\nfunction handleClearSelection(state, context) {\\n  return (0, _extends2.default)({}, state, {\\n    selectedValues: [],\\n    highlightedValue: moveHighlight(null, 'reset', context)\\n  });\\n}\\nfunction listReducer(state, action) {\\n  const {\\n    type,\\n    context\\n  } = action;\\n  switch (type) {\\n    case _listActions.ListActionTypes.keyDown:\\n      return handleKeyDown(action.key, state, context);\\n    case _listActions.ListActionTypes.itemClick:\\n      return handleItemSelection(action.item, state, context);\\n    case _listActions.ListActionTypes.blur:\\n      return handleBlur(state, context);\\n    case _listActions.ListActionTypes.textNavigation:\\n      return handleTextNavigation(state, action.searchString, context);\\n    case _listActions.ListActionTypes.itemsChange:\\n      return handleItemsChange(action.items, action.previousItems, state, context);\\n    case _listActions.ListActionTypes.resetHighlight:\\n      return handleResetHighlight(state, context);\\n    case _listActions.ListActionTypes.highlightLast:\\n      return handleHighlightLast(state, context);\\n    case _listActions.ListActionTypes.clearSelection:\\n      return handleClearSelection(state, context);\\n    default:\\n      return state;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"findValidItemToHighlight\",\"currentIndex\",\"lookupDirection\",\"items\",\"includeDisabledItems\",\"isItemDisabled\",\"wrapAround\",\"length\",\"every\",\"item\",\"itemIndex\",\"nextFocus\",\"nextFocusDisabled\",\"moveHighlight\",\"previouslyHighlightedValue\",\"offset\",\"context\",\"_items$nextIndex\",\"disableListWrap\",\"disabledItemsFocusable\",\"itemComparer\",\"focusManagement\",\"defaultHighlightedIndex\",\"maxIndex\",\"previouslyHighlightedIndex\",\"findIndex\",\"nextIndexCandidate\",\"newIndex\",\"Math\",\"abs\",\"nextIndex\",\"toggleSelection\",\"selectedValues\",\"selectionMode\",\"some\",\"sv\",\"filter\",\"handleItemSelection\",\"state\",\"i\",\"newSelectedValues\",\"_extends2\",\"default\",\"highlightedValue\",\"handleKeyDown\",\"key\",\"previouslySelectedValue\",\"orientation\",\"pageSize\",\"handleItemsChange\",\"previousItems\",\"_state$selectedValues\",\"newHighlightedValue\",\"_items$find\",\"find\",\"selectedValue\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"value\",\"listReducer\",\"action\",\"type\",\"_listActions\",\"ListActionTypes\",\"keyDown\",\"itemClick\",\"blur\",\"textNavigation\",\"searchString\",\"getItemAsString\",\"startWithCurrentItem\",\"nextItem\",\"index\",\"_stringifyItem\",\"text\",\"trim\",\"toLowerCase\",\"indexOf\",\"itemsChange\",\"resetHighlight\",\"highlightLast\",\"clearSelection\"]\n}\n"]