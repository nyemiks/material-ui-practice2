["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/material/node/SwipeableDrawer/SwipeableDrawer.js"],"~:js","shadow$provide.module$node_modules$$mui$material$node$SwipeableDrawer$SwipeableDrawer = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  function _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }\n  function calculateCurrentX(anchor, touches, doc) {\n    return \"right\" === anchor ? doc.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n  }\n  function calculateCurrentY(anchor, touches, containerWindow) {\n    return \"bottom\" === anchor ? containerWindow.innerHeight - touches[0].clientY : touches[0].clientY;\n  }\n  function getMaxTranslate(horizontalSwipe, paperInstance) {\n    return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n  }\n  function computeHasNativeHandler({domTreeShapes, start, current, anchor}) {\n    var JSCompiler_object_inline_scrollPosition_1070 = {x:\"scrollLeft\", y:\"scrollTop\"}, JSCompiler_object_inline_scrollLength_1071 = {x:\"scrollWidth\", y:\"scrollHeight\"}, JSCompiler_object_inline_clientLength_1072 = {x:\"clientWidth\", y:\"clientHeight\"};\n    return domTreeShapes.some(shape => {\n      let goingForward = current >= start;\n      if (\"top\" === anchor || \"left\" === anchor) {\n        goingForward = !goingForward;\n      }\n      const axis = \"left\" === anchor || \"right\" === anchor ? \"x\" : \"y\", scrollPosition = Math.round(shape[JSCompiler_object_inline_scrollPosition_1070[axis]]);\n      shape = scrollPosition + shape[JSCompiler_object_inline_clientLength_1072[axis]] < shape[JSCompiler_object_inline_scrollLength_1071[axis]];\n      return goingForward && shape || !goingForward && 0 < scrollPosition ? !0 : !1;\n    });\n  }\n  \"use client\";\n  var _interopRequireDefault = require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.default = void 0;\n  exports.reset = function() {\n    claimedSwipeInstance = null;\n  };\n  var _extends2 = _interopRequireDefault(require(\"module$node_modules$$babel$runtime$helpers$extends\")), _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose\")), React = _interopRequireWildcard(require(\"module$node_modules$react$index\")), ReactDOM = _interopRequireWildcard(require(\"module$node_modules$react_dom$index\"));\n  global = _interopRequireDefault(require(\"module$node_modules$prop_types$index\"));\n  module = _interopRequireDefault(require(\"module$node_modules$$mui$utils$node$elementTypeAcceptingRef$index\"));\n  var _useThemeProps = _interopRequireDefault(require(\"module$node_modules$$mui$system$useThemeProps$index\")), _base = require(\"module$node_modules$$mui$base$node$index\"), _Drawer = _interopRequireWildcard(require(\"module$node_modules$$mui$material$node$Drawer$Drawer\")), _useForkRef = _interopRequireDefault(require(\"module$node_modules$$mui$material$node$utils$useForkRef\")), _ownerDocument = _interopRequireDefault(require(\"module$node_modules$$mui$material$node$utils$ownerDocument\")), _ownerWindow = \n  _interopRequireDefault(require(\"module$node_modules$$mui$material$node$utils$ownerWindow\")), _useEventCallback = _interopRequireDefault(require(\"module$node_modules$$mui$material$node$utils$useEventCallback\")), _useEnhancedEffect = _interopRequireDefault(require(\"module$node_modules$$mui$material$node$utils$useEnhancedEffect\")), _useTheme = _interopRequireDefault(require(\"module$node_modules$$mui$material$node$styles$useTheme\")), _utils = require(\"module$node_modules$$mui$material$node$transitions$utils\"), \n  _SwipeArea = _interopRequireDefault(require(\"module$node_modules$$mui$material$node$SwipeableDrawer$SwipeArea\")), _jsxRuntime = require(\"module$node_modules$react$jsx_runtime\");\n  const _excluded = [\"BackdropProps\"], _excluded2 = \"anchor disableBackdropTransition disableDiscovery disableSwipeToOpen hideBackdrop hysteresis allowSwipeInChildren minFlingVelocity ModalProps onClose onOpen open PaperProps SwipeAreaProps swipeAreaWidth transitionDuration variant\".split(\" \");\n  let claimedSwipeInstance = null;\n  const iOS = \"undefined\" !== typeof navigator && /iPad|iPhone|iPod/.test(navigator.userAgent);\n  require = React.forwardRef(function(inProps, ref) {\n    var props = (0,_useThemeProps.default)({name:\"MuiSwipeableDrawer\", props:inProps});\n    const theme = (0,_useTheme.default)();\n    inProps = {enter:theme.transitions.duration.enteringScreen, exit:theme.transitions.duration.leavingScreen};\n    const {anchor = \"left\", disableBackdropTransition = !1, disableDiscovery = !1, disableSwipeToOpen = iOS, hideBackdrop, hysteresis = 0.52, allowSwipeInChildren = !1, minFlingVelocity = 450, ModalProps:{BackdropProps} = {}, onClose, onOpen, open = !1, PaperProps = {}, SwipeAreaProps, swipeAreaWidth = 20, transitionDuration = inProps, variant = \"temporary\"} = props;\n    inProps = (0,_objectWithoutPropertiesLoose2.default)(props.ModalProps, _excluded);\n    props = (0,_objectWithoutPropertiesLoose2.default)(props, _excluded2);\n    const [maybeSwiping, setMaybeSwiping] = React.useState(!1), swipeInstance = React.useRef({isSwiping:null}), swipeAreaRef = React.useRef(), backdropRef = React.useRef(), paperRef = React.useRef(), handleRef = (0,_useForkRef.default)(PaperProps.ref, paperRef), touchDetected = React.useRef(!1), calculatedDurationRef = React.useRef();\n    (0,_useEnhancedEffect.default)(() => {\n      calculatedDurationRef.current = null;\n    }, [open]);\n    const setPosition = React.useCallback((translate, options = {}) => {\n      const {mode = null, changeTransition = !0} = options;\n      options = (0,_Drawer.getAnchor)(theme, anchor);\n      var rtlTranslateMultiplier = -1 !== [\"right\", \"bottom\"].indexOf(options) ? 1 : -1, transform = (options = (0,_Drawer.isHorizontal)(anchor)) ? `translate(${rtlTranslateMultiplier * translate}px, 0)` : `translate(0, ${rtlTranslateMultiplier * translate}px)`;\n      rtlTranslateMultiplier = paperRef.current.style;\n      rtlTranslateMultiplier.webkitTransform = transform;\n      rtlTranslateMultiplier.transform = transform;\n      transform = \"\";\n      mode && (transform = theme.transitions.create(\"all\", (0,_utils.getTransitionProps)({easing:void 0, style:void 0, timeout:transitionDuration}, {mode})));\n      changeTransition && (rtlTranslateMultiplier.webkitTransition = transform, rtlTranslateMultiplier.transition = transform);\n      disableBackdropTransition || hideBackdrop || (rtlTranslateMultiplier = backdropRef.current.style, rtlTranslateMultiplier.opacity = 1 - translate / getMaxTranslate(options, paperRef.current), changeTransition && (rtlTranslateMultiplier.webkitTransition = transform, rtlTranslateMultiplier.transition = transform));\n    }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]), handleBodyTouchEnd = (0,_useEventCallback.default)(nativeEvent => {\n      if (touchDetected.current) {\n        if (claimedSwipeInstance = null, touchDetected.current = !1, ReactDOM.flushSync(() => {\n          setMaybeSwiping(!1);\n        }), swipeInstance.current.isSwiping) {\n          swipeInstance.current.isSwiping = null;\n          var anchorRtl = (0,_Drawer.getAnchor)(theme, anchor), horizontal = (0,_Drawer.isHorizontal)(anchor);\n          anchorRtl = horizontal ? calculateCurrentX(anchorRtl, nativeEvent.changedTouches, (0,_ownerDocument.default)(nativeEvent.currentTarget)) : calculateCurrentY(anchorRtl, nativeEvent.changedTouches, (0,_ownerWindow.default)(nativeEvent.currentTarget));\n          var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n          nativeEvent = getMaxTranslate(horizontal, paperRef.current);\n          anchorRtl = Math.min(Math.max(open ? startLocation - anchorRtl : nativeEvent + startLocation - anchorRtl, 0), nativeEvent);\n          startLocation = anchorRtl / nativeEvent;\n          Math.abs(swipeInstance.current.velocity) > minFlingVelocity && (calculatedDurationRef.current = 1000 * Math.abs((nativeEvent - anchorRtl) / swipeInstance.current.velocity));\n          open ? swipeInstance.current.velocity > minFlingVelocity || startLocation > hysteresis ? onClose() : setPosition(0, {mode:\"exit\"}) : swipeInstance.current.velocity < -minFlingVelocity || 1 - startLocation > hysteresis ? onOpen() : setPosition(getMaxTranslate(horizontal, paperRef.current), {mode:\"enter\"});\n        } else {\n          swipeInstance.current.isSwiping = null;\n        }\n      }\n    }), startMaybeSwiping = (force = !1) => {\n      maybeSwiping || (!force && disableDiscovery && allowSwipeInChildren || ReactDOM.flushSync(() => {\n        setMaybeSwiping(!0);\n      }), force = (0,_Drawer.isHorizontal)(anchor), !open && paperRef.current && setPosition(getMaxTranslate(force, paperRef.current) + (disableDiscovery ? 15 : -20), {changeTransition:!1}), swipeInstance.current.velocity = 0, swipeInstance.current.lastTime = null, swipeInstance.current.lastTranslate = null, swipeInstance.current.paperHit = !1, touchDetected.current = !0);\n    }, handleBodyTouchMove = (0,_useEventCallback.default)(nativeEvent => {\n      if (paperRef.current && touchDetected.current && (null === claimedSwipeInstance || claimedSwipeInstance === swipeInstance.current)) {\n        startMaybeSwiping(!0);\n        var anchorRtl = (0,_Drawer.getAnchor)(theme, anchor), horizontalSwipe = (0,_Drawer.isHorizontal)(anchor), currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0,_ownerDocument.default)(nativeEvent.currentTarget));\n        anchorRtl = calculateCurrentY(anchorRtl, nativeEvent.touches, (0,_ownerWindow.default)(nativeEvent.currentTarget));\n        if (open && paperRef.current.contains(nativeEvent.target) && null === claimedSwipeInstance) {\n          for (var element = nativeEvent.target, rootNode = paperRef.current, domTreeShapes = []; element && element !== rootNode.parentElement;) {\n            const style = (0,_ownerWindow.default)(rootNode).getComputedStyle(element);\n            \"absolute\" !== style.getPropertyValue(\"position\") && \"hidden\" !== style.getPropertyValue(\"overflow-x\") && (0 < element.clientWidth && element.scrollWidth > element.clientWidth || 0 < element.clientHeight && element.scrollHeight > element.clientHeight) && domTreeShapes.push(element);\n            element = element.parentElement;\n          }\n          if (computeHasNativeHandler({domTreeShapes, start:horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY, current:horizontalSwipe ? currentX : anchorRtl, anchor})) {\n            claimedSwipeInstance = !0;\n            return;\n          }\n          claimedSwipeInstance = swipeInstance.current;\n        }\n        if (null == swipeInstance.current.isSwiping && (element = Math.abs(currentX - swipeInstance.current.startX), rootNode = Math.abs(anchorRtl - swipeInstance.current.startY), (domTreeShapes = horizontalSwipe ? element > rootNode && 3 < element : rootNode > element && 3 < rootNode) && nativeEvent.cancelable && nativeEvent.preventDefault(), !0 === domTreeShapes || (horizontalSwipe ? 3 < rootNode : 3 < element))) {\n          swipeInstance.current.isSwiping = domTreeShapes;\n          if (!domTreeShapes) {\n            handleBodyTouchEnd(nativeEvent);\n            return;\n          }\n          swipeInstance.current.startX = currentX;\n          swipeInstance.current.startY = anchorRtl;\n          disableDiscovery || open || (horizontalSwipe ? swipeInstance.current.startX -= 20 : swipeInstance.current.startY -= 20);\n        }\n        if (swipeInstance.current.isSwiping) {\n          element = getMaxTranslate(horizontalSwipe, paperRef.current);\n          rootNode = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n          open && !swipeInstance.current.paperHit && (rootNode = Math.min(rootNode, element));\n          domTreeShapes = horizontalSwipe ? currentX : anchorRtl;\n          rootNode = Math.min(Math.max(open ? rootNode - domTreeShapes : element + rootNode - domTreeShapes, 0), element);\n          if (open) {\n            if (swipeInstance.current.paperHit) {\n              0 === rootNode && (swipeInstance.current.startX = currentX, swipeInstance.current.startY = anchorRtl);\n            } else {\n              if (horizontalSwipe ? currentX < element : anchorRtl < element) {\n                swipeInstance.current.paperHit = !0, swipeInstance.current.startX = currentX, swipeInstance.current.startY = anchorRtl;\n              } else {\n                return;\n              }\n            }\n          }\n          null === swipeInstance.current.lastTranslate && (swipeInstance.current.lastTranslate = rootNode, swipeInstance.current.lastTime = performance.now() + 1);\n          horizontalSwipe = (rootNode - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3;\n          swipeInstance.current.velocity = 0.4 * swipeInstance.current.velocity + 0.6 * horizontalSwipe;\n          swipeInstance.current.lastTranslate = rootNode;\n          swipeInstance.current.lastTime = performance.now();\n          nativeEvent.cancelable && nativeEvent.preventDefault();\n          setPosition(rootNode);\n        }\n      }\n    }), handleBodyTouchStart = (0,_useEventCallback.default)(nativeEvent => {\n      if (!nativeEvent.defaultPrevented && !nativeEvent.defaultMuiPrevented && (!open || !hideBackdrop && backdropRef.current.contains(nativeEvent.target) || paperRef.current.contains(nativeEvent.target))) {\n        var anchorRtl = (0,_Drawer.getAnchor)(theme, anchor), horizontalSwipe = (0,_Drawer.isHorizontal)(anchor), currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0,_ownerDocument.default)(nativeEvent.currentTarget));\n        anchorRtl = calculateCurrentY(anchorRtl, nativeEvent.touches, (0,_ownerWindow.default)(nativeEvent.currentTarget));\n        if (!open) {\n          var _paperRef$current;\n          if (disableSwipeToOpen || !(nativeEvent.target === swipeAreaRef.current || null != (_paperRef$current = paperRef.current) && _paperRef$current.contains(nativeEvent.target) && (\"function\" === typeof allowSwipeInChildren ? allowSwipeInChildren(nativeEvent, swipeAreaRef.current, paperRef.current) : allowSwipeInChildren))) {\n            return;\n          }\n          if (horizontalSwipe) {\n            if (currentX > swipeAreaWidth) {\n              return;\n            }\n          } else if (anchorRtl > swipeAreaWidth) {\n            return;\n          }\n        }\n        nativeEvent.defaultMuiPrevented = !0;\n        claimedSwipeInstance = null;\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = anchorRtl;\n        startMaybeSwiping();\n      }\n    });\n    React.useEffect(() => {\n      if (\"temporary\" === variant) {\n        const doc = (0,_ownerDocument.default)(paperRef.current);\n        doc.addEventListener(\"touchstart\", handleBodyTouchStart);\n        doc.addEventListener(\"touchmove\", handleBodyTouchMove, {passive:!open});\n        doc.addEventListener(\"touchend\", handleBodyTouchEnd);\n        return () => {\n          doc.removeEventListener(\"touchstart\", handleBodyTouchStart);\n          doc.removeEventListener(\"touchmove\", handleBodyTouchMove, {passive:!open});\n          doc.removeEventListener(\"touchend\", handleBodyTouchEnd);\n        };\n      }\n    }, [variant, open, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n    React.useEffect(() => () => {\n      claimedSwipeInstance === swipeInstance.current && (claimedSwipeInstance = null);\n    }, []);\n    React.useEffect(() => {\n      open || setMaybeSwiping(!1);\n    }, [open]);\n    return (0,_jsxRuntime.jsxs)(React.Fragment, {children:[(0,_jsxRuntime.jsx)(_Drawer.default, (0,_extends2.default)({open:\"temporary\" === variant && maybeSwiping ? !0 : open, variant, ModalProps:(0,_extends2.default)({BackdropProps:(0,_extends2.default)({}, BackdropProps, {ref:backdropRef})}, \"temporary\" === variant && {keepMounted:!0}, inProps), hideBackdrop, PaperProps:(0,_extends2.default)({}, PaperProps, {style:(0,_extends2.default)({pointerEvents:\"temporary\" !== variant || open || allowSwipeInChildren ? \n    \"\" : \"none\"}, PaperProps.style), ref:handleRef}), anchor, transitionDuration:calculatedDurationRef.current || transitionDuration, onClose, ref}, props)), !disableSwipeToOpen && \"temporary\" === variant && (0,_jsxRuntime.jsx)(_base.NoSsr, {children:(0,_jsxRuntime.jsx)(_SwipeArea.default, (0,_extends2.default)({anchor, ref:swipeAreaRef, width:swipeAreaWidth}, SwipeAreaProps))})]});\n  });\n  require.propTypes = {allowSwipeInChildren:global.default.oneOfType([global.default.func, global.default.bool]), anchor:global.default.oneOf([\"bottom\", \"left\", \"right\", \"top\"]), children:global.default.node, disableBackdropTransition:global.default.bool, disableDiscovery:global.default.bool, disableSwipeToOpen:global.default.bool, hideBackdrop:global.default.bool, hysteresis:global.default.number, minFlingVelocity:global.default.number, ModalProps:global.default.shape({BackdropProps:global.default.shape({component:module.default})}), \n  onClose:global.default.func.isRequired, onOpen:global.default.func.isRequired, open:global.default.bool, PaperProps:global.default.shape({component:module.default, style:global.default.object}), SwipeAreaProps:global.default.object, swipeAreaWidth:global.default.number, transitionDuration:global.default.oneOfType([global.default.number, global.default.shape({appear:global.default.number, enter:global.default.number, exit:global.default.number})]), variant:global.default.oneOf([\"permanent\", \"persistent\", \n  \"temporary\"])};\n  exports.default = require;\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$material$node$SwipeableDrawer$SwipeableDrawer\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.reset = reset;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar ReactDOM = _interopRequireWildcard(require(\"react-dom\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _elementTypeAcceptingRef = _interopRequireDefault(require(\"@mui/utils/elementTypeAcceptingRef\"));\nvar _useThemeProps = _interopRequireDefault(require(\"@mui/system/useThemeProps\"));\nvar _base = require(\"@mui/base\");\nvar _Drawer = _interopRequireWildcard(require(\"../Drawer/Drawer\"));\nvar _useForkRef = _interopRequireDefault(require(\"../utils/useForkRef\"));\nvar _ownerDocument = _interopRequireDefault(require(\"../utils/ownerDocument\"));\nvar _ownerWindow = _interopRequireDefault(require(\"../utils/ownerWindow\"));\nvar _useEventCallback = _interopRequireDefault(require(\"../utils/useEventCallback\"));\nvar _useEnhancedEffect = _interopRequireDefault(require(\"../utils/useEnhancedEffect\"));\nvar _useTheme = _interopRequireDefault(require(\"../styles/useTheme\"));\nvar _utils = require(\"../transitions/utils\");\nvar _SwipeArea = _interopRequireDefault(require(\"./SwipeArea\"));\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nconst _excluded = [\"BackdropProps\"],\n  _excluded2 = [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"allowSwipeInChildren\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"transitionDuration\", \"variant\"]; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst UNCERTAINTY_THRESHOLD = 3; // px\n\n// This is the part of the drawer displayed on touch start.\nconst DRAG_STARTED_SIGNAL = 20; // px\n\n// We can only have one instance at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\nlet claimedSwipeInstance = null;\n\n// Exported for test purposes.\nfunction reset() {\n  claimedSwipeInstance = null;\n}\nfunction calculateCurrentX(anchor, touches, doc) {\n  return anchor === 'right' ? doc.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\nfunction calculateCurrentY(anchor, touches, containerWindow) {\n  return anchor === 'bottom' ? containerWindow.innerHeight - touches[0].clientY : touches[0].clientY;\n}\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\n\n/**\n * @param {Element | null} element\n * @param {Element} rootNode\n */\nfunction getDomTreeShapes(element, rootNode) {\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L129\n  const domTreeShapes = [];\n  while (element && element !== rootNode.parentElement) {\n    const style = (0, _ownerWindow.default)(rootNode).getComputedStyle(element);\n    if (\n    // Ignore the scroll children if the element is absolute positioned.\n    style.getPropertyValue('position') === 'absolute' ||\n    // Ignore the scroll children if the element has an overflowX hidden\n    style.getPropertyValue('overflow-x') === 'hidden') {\n      // noop\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push(element);\n    }\n    element = element.parentElement;\n  }\n  return domTreeShapes;\n}\n\n/**\n * @param {object} param0\n * @param {ReturnType<getDomTreeShapes>} param0.domTreeShapes\n */\nfunction computeHasNativeHandler({\n  domTreeShapes,\n  start,\n  current,\n  anchor\n}) {\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L175\n  const axisProperties = {\n    scrollPosition: {\n      x: 'scrollLeft',\n      y: 'scrollTop'\n    },\n    scrollLength: {\n      x: 'scrollWidth',\n      y: 'scrollHeight'\n    },\n    clientLength: {\n      x: 'clientWidth',\n      y: 'clientHeight'\n    }\n  };\n  return domTreeShapes.some(shape => {\n    // Determine if we are going backward or forward.\n    let goingForward = current >= start;\n    if (anchor === 'top' || anchor === 'left') {\n      goingForward = !goingForward;\n    }\n    const axis = anchor === 'left' || anchor === 'right' ? 'x' : 'y';\n    const scrollPosition = Math.round(shape[axisProperties.scrollPosition[axis]]);\n    const areNotAtStart = scrollPosition > 0;\n    const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\n      return true;\n    }\n    return false;\n  });\n}\nconst iOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);\nconst SwipeableDrawer = /*#__PURE__*/React.forwardRef(function SwipeableDrawer(inProps, ref) {\n  const props = (0, _useThemeProps.default)({\n    name: 'MuiSwipeableDrawer',\n    props: inProps\n  });\n  const theme = (0, _useTheme.default)();\n  const transitionDurationDefault = {\n    enter: theme.transitions.duration.enteringScreen,\n    exit: theme.transitions.duration.leavingScreen\n  };\n  const {\n      anchor = 'left',\n      disableBackdropTransition = false,\n      disableDiscovery = false,\n      disableSwipeToOpen = iOS,\n      hideBackdrop,\n      hysteresis = 0.52,\n      allowSwipeInChildren = false,\n      minFlingVelocity = 450,\n      ModalProps: {\n        BackdropProps\n      } = {},\n      onClose,\n      onOpen,\n      open = false,\n      PaperProps = {},\n      SwipeAreaProps,\n      swipeAreaWidth = 20,\n      transitionDuration = transitionDurationDefault,\n      variant = 'temporary' // Mobile first.\n    } = props,\n    ModalPropsProp = (0, _objectWithoutPropertiesLoose2.default)(props.ModalProps, _excluded),\n    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded2);\n  const [maybeSwiping, setMaybeSwiping] = React.useState(false);\n  const swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  const swipeAreaRef = React.useRef();\n  const backdropRef = React.useRef();\n  const paperRef = React.useRef();\n  const handleRef = (0, _useForkRef.default)(PaperProps.ref, paperRef);\n  const touchDetected = React.useRef(false);\n\n  // Ref for transition duration based on / to match swipe speed\n  const calculatedDurationRef = React.useRef();\n\n  // Use a ref so the open value used is always up to date inside useCallback.\n  (0, _useEnhancedEffect.default)(() => {\n    calculatedDurationRef.current = null;\n  }, [open]);\n  const setPosition = React.useCallback((translate, options = {}) => {\n    const {\n      mode = null,\n      changeTransition = true\n    } = options;\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    const rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n    const transform = horizontalSwipe ? `translate(${rtlTranslateMultiplier * translate}px, 0)` : `translate(0, ${rtlTranslateMultiplier * translate}px)`;\n    const drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    let transition = '';\n    if (mode) {\n      transition = theme.transitions.create('all', (0, _utils.getTransitionProps)({\n        easing: undefined,\n        style: undefined,\n        timeout: transitionDuration\n      }, {\n        mode\n      }));\n    }\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n    if (!disableBackdropTransition && !hideBackdrop) {\n      const backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  const handleBodyTouchEnd = (0, _useEventCallback.default)(nativeEvent => {\n    if (!touchDetected.current) {\n      return;\n    }\n    claimedSwipeInstance = null;\n    touchDetected.current = false;\n    ReactDOM.flushSync(() => {\n      setMaybeSwiping(false);\n    });\n\n    // The swipe wasn't started.\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n    swipeInstance.current.isSwiping = null;\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    const horizontal = (0, _Drawer.isHorizontal)(anchor);\n    let current;\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, nativeEvent.changedTouches, (0, _ownerDocument.default)(nativeEvent.currentTarget));\n    } else {\n      current = calculateCurrentY(anchorRtl, nativeEvent.changedTouches, (0, _ownerWindow.default)(nativeEvent.currentTarget));\n    }\n    const startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    const maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    const currentTranslate = getTranslate(current, startLocation, open, maxTranslate);\n    const translateRatio = currentTranslate / maxTranslate;\n    if (Math.abs(swipeInstance.current.velocity) > minFlingVelocity) {\n      // Calculate transition duration to match swipe speed\n      calculatedDurationRef.current = Math.abs((maxTranslate - currentTranslate) / swipeInstance.current.velocity) * 1000;\n    }\n    if (open) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n      return;\n    }\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  });\n  const startMaybeSwiping = (force = false) => {\n    if (!maybeSwiping) {\n      // on Safari Mobile, if you want to be able to have the 'click' event fired on child elements, nothing in the DOM can be changed.\n      // this is because Safari Mobile will not fire any mouse events (still fires touch though) if the DOM changes during mousemove.\n      // so do this change on first touchmove instead of touchstart\n      if (force || !(disableDiscovery && allowSwipeInChildren)) {\n        ReactDOM.flushSync(() => {\n          setMaybeSwiping(true);\n        });\n      }\n      const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n      if (!open && paperRef.current) {\n        // The ref may be null when a parent component updates while swiping.\n        setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 15 : -DRAG_STARTED_SIGNAL), {\n          changeTransition: false\n        });\n      }\n      swipeInstance.current.velocity = 0;\n      swipeInstance.current.lastTime = null;\n      swipeInstance.current.lastTranslate = null;\n      swipeInstance.current.paperHit = false;\n      touchDetected.current = true;\n    }\n  };\n  const handleBodyTouchMove = (0, _useEventCallback.default)(nativeEvent => {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    }\n\n    // We are not supposed to handle this touch move because the swipe was started in a scrollable container in the drawer\n    if (claimedSwipeInstance !== null && claimedSwipeInstance !== swipeInstance.current) {\n      return;\n    }\n    startMaybeSwiping(true);\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n    const currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0, _ownerDocument.default)(nativeEvent.currentTarget));\n    const currentY = calculateCurrentY(anchorRtl, nativeEvent.touches, (0, _ownerWindow.default)(nativeEvent.currentTarget));\n    if (open && paperRef.current.contains(nativeEvent.target) && claimedSwipeInstance === null) {\n      const domTreeShapes = getDomTreeShapes(nativeEvent.target, paperRef.current);\n      const hasNativeHandler = computeHasNativeHandler({\n        domTreeShapes,\n        start: horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY,\n        current: horizontalSwipe ? currentX : currentY,\n        anchor\n      });\n      if (hasNativeHandler) {\n        claimedSwipeInstance = true;\n        return;\n      }\n      claimedSwipeInstance = swipeInstance.current;\n    }\n\n    // We don't know yet.\n    if (swipeInstance.current.isSwiping == null) {\n      const dx = Math.abs(currentX - swipeInstance.current.startX);\n      const dy = Math.abs(currentY - swipeInstance.current.startY);\n      const definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n      if (definitelySwiping && nativeEvent.cancelable) {\n        nativeEvent.preventDefault();\n      }\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(nativeEvent);\n          return;\n        }\n\n        // Shift the starting point.\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY;\n\n        // Compensate for the part of the drawer displayed on touch start.\n        if (!disableDiscovery && !open) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= DRAG_STARTED_SIGNAL;\n          } else {\n            swipeInstance.current.startY -= DRAG_STARTED_SIGNAL;\n          }\n        }\n      }\n    }\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n    const maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    let startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n    if (open && !swipeInstance.current.paperHit) {\n      startLocation = Math.min(startLocation, maxTranslate);\n    }\n    const translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, open, maxTranslate);\n    if (open) {\n      if (!swipeInstance.current.paperHit) {\n        const paperHit = horizontalSwipe ? currentX < maxTranslate : currentY < maxTranslate;\n        if (paperHit) {\n          swipeInstance.current.paperHit = true;\n          swipeInstance.current.startX = currentX;\n          swipeInstance.current.startY = currentY;\n        } else {\n          return;\n        }\n      } else if (translate === 0) {\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY;\n      }\n    }\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n    const velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3;\n\n    // Low Pass filter.\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now();\n\n    // We are swiping, let's prevent the scroll event on iOS.\n    if (nativeEvent.cancelable) {\n      nativeEvent.preventDefault();\n    }\n    setPosition(translate);\n  });\n  const handleBodyTouchStart = (0, _useEventCallback.default)(nativeEvent => {\n    // We are not supposed to handle this touch move.\n    // Example of use case: ignore the event if there is a Slider.\n    if (nativeEvent.defaultPrevented) {\n      return;\n    }\n\n    // We can only have one node at the time claiming ownership for handling the swipe.\n    if (nativeEvent.defaultMuiPrevented) {\n      return;\n    }\n\n    // At least one element clogs the drawer interaction zone.\n    if (open && (hideBackdrop || !backdropRef.current.contains(nativeEvent.target)) && !paperRef.current.contains(nativeEvent.target)) {\n      return;\n    }\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n    const currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0, _ownerDocument.default)(nativeEvent.currentTarget));\n    const currentY = calculateCurrentY(anchorRtl, nativeEvent.touches, (0, _ownerWindow.default)(nativeEvent.currentTarget));\n    if (!open) {\n      var _paperRef$current;\n      // logic for if swipe should be ignored:\n      // if disableSwipeToOpen\n      // if target != swipeArea, and target is not a child of paper ref\n      // if is a child of paper ref, and `allowSwipeInChildren` does not allow it\n      if (disableSwipeToOpen || !(nativeEvent.target === swipeAreaRef.current || (_paperRef$current = paperRef.current) != null && _paperRef$current.contains(nativeEvent.target) && (typeof allowSwipeInChildren === 'function' ? allowSwipeInChildren(nativeEvent, swipeAreaRef.current, paperRef.current) : allowSwipeInChildren))) {\n        return;\n      }\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n    nativeEvent.defaultMuiPrevented = true;\n    claimedSwipeInstance = null;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    startMaybeSwiping();\n  });\n  React.useEffect(() => {\n    if (variant === 'temporary') {\n      const doc = (0, _ownerDocument.default)(paperRef.current);\n      doc.addEventListener('touchstart', handleBodyTouchStart);\n      // A blocking listener prevents Firefox's navbar to auto-hide on scroll.\n      // It only needs to prevent scrolling on the drawer's content when open.\n      // When closed, the overlay prevents scrolling.\n      doc.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: !open\n      });\n      doc.addEventListener('touchend', handleBodyTouchEnd);\n      return () => {\n        doc.removeEventListener('touchstart', handleBodyTouchStart);\n        doc.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: !open\n        });\n        doc.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n    return undefined;\n  }, [variant, open, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(() => () => {\n    // We need to release the lock.\n    if (claimedSwipeInstance === swipeInstance.current) {\n      claimedSwipeInstance = null;\n    }\n  }, []);\n  React.useEffect(() => {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {\n    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Drawer.default, (0, _extends2.default)({\n      open: variant === 'temporary' && maybeSwiping ? true : open,\n      variant: variant,\n      ModalProps: (0, _extends2.default)({\n        BackdropProps: (0, _extends2.default)({}, BackdropProps, {\n          ref: backdropRef\n        })\n      }, variant === 'temporary' && {\n        keepMounted: true\n      }, ModalPropsProp),\n      hideBackdrop: hideBackdrop,\n      PaperProps: (0, _extends2.default)({}, PaperProps, {\n        style: (0, _extends2.default)({\n          pointerEvents: variant === 'temporary' && !open && !allowSwipeInChildren ? 'none' : ''\n        }, PaperProps.style),\n        ref: handleRef\n      }),\n      anchor: anchor,\n      transitionDuration: calculatedDurationRef.current || transitionDuration,\n      onClose: onClose,\n      ref: ref\n    }, other)), !disableSwipeToOpen && variant === 'temporary' && /*#__PURE__*/(0, _jsxRuntime.jsx)(_base.NoSsr, {\n      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_SwipeArea.default, (0, _extends2.default)({\n        anchor: anchor,\n        ref: swipeAreaRef,\n        width: swipeAreaWidth\n      }, SwipeAreaProps))\n    })]\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * If set to true, the swipe event will open the drawer even if the user begins the swipe on one of the drawer's children.\n   * This can be useful in scenarios where the drawer is partially visible.\n   * You can customize it further with a callback that determines which children the user can drag over to open the drawer\n   * (for example, to ignore other elements that handle touch move events, like sliders).\n   *\n   * @param {TouchEvent} event The 'touchstart' event\n   * @param {HTMLDivElement} swipeArea The swipe area element\n   * @param {HTMLDivElement} paper The drawer's paper element\n   *\n   * @default false\n   */\n  allowSwipeInChildren: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),\n  /**\n   * @ignore\n   */\n  anchor: _propTypes.default.oneOf(['bottom', 'left', 'right', 'top']),\n  /**\n   * The content of the component.\n   */\n  children: _propTypes.default.node,\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   * @default false\n   */\n  disableBackdropTransition: _propTypes.default.bool,\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   * @default false\n   */\n  disableDiscovery: _propTypes.default.bool,\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   * @default typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent)\n   */\n  disableSwipeToOpen: _propTypes.default.bool,\n  /**\n   * @ignore\n   */\n  hideBackdrop: _propTypes.default.bool,\n  /**\n   * Affects how far the drawer must be opened/closed to change its state.\n   * Specified as percent (0-1) of the width of the drawer\n   * @default 0.52\n   */\n  hysteresis: _propTypes.default.number,\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   * @default 450\n   */\n  minFlingVelocity: _propTypes.default.number,\n  /**\n   * @ignore\n   */\n  ModalProps: _propTypes.default /* @typescript-to-proptypes-ignore */.shape({\n    BackdropProps: _propTypes.default.shape({\n      component: _elementTypeAcceptingRef.default\n    })\n  }),\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {React.SyntheticEvent<{}>} event The event source of the callback.\n   */\n  onClose: _propTypes.default.func.isRequired,\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {React.SyntheticEvent<{}>} event The event source of the callback.\n   */\n  onOpen: _propTypes.default.func.isRequired,\n  /**\n   * If `true`, the component is shown.\n   * @default false\n   */\n  open: _propTypes.default.bool,\n  /**\n   * @ignore\n   */\n  PaperProps: _propTypes.default /* @typescript-to-proptypes-ignore */.shape({\n    component: _elementTypeAcceptingRef.default,\n    style: _propTypes.default.object\n  }),\n  /**\n   * The element is used to intercept the touch events on the edge.\n   */\n  SwipeAreaProps: _propTypes.default.object,\n  /**\n   * The width of the left most (or right most) area in `px` that\n   * the drawer can be swiped open from.\n   * @default 20\n   */\n  swipeAreaWidth: _propTypes.default.number,\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   * @default {\n   *   enter: theme.transitions.duration.enteringScreen,\n   *   exit: theme.transitions.duration.leavingScreen,\n   * }\n   */\n  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({\n    appear: _propTypes.default.number,\n    enter: _propTypes.default.number,\n    exit: _propTypes.default.number\n  })]),\n  /**\n   * @ignore\n   */\n  variant: _propTypes.default.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nvar _default = exports.default = SwipeableDrawer;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose","~$module$node_modules$react$jsx_runtime","~$module$node_modules$$mui$material$node$styles$useTheme","~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react_dom$index","~$module$node_modules$$mui$system$useThemeProps$index","~$module$node_modules$$mui$base$node$index","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$module$node_modules$$mui$material$node$SwipeableDrawer$SwipeArea","~$shadow.js","~$module$node_modules$$mui$material$node$utils$useEventCallback","~$module$node_modules$$mui$material$node$utils$useEnhancedEffect","~$module$node_modules$$babel$runtime$helpers$extends","~$module$node_modules$$mui$material$node$utils$ownerDocument","~$module$node_modules$$mui$utils$node$elementTypeAcceptingRef$index","~$module$node_modules$$mui$material$node$utils$ownerWindow","~$module$node_modules$$mui$material$node$Drawer$Drawer","~$module$node_modules$$mui$material$node$utils$useForkRef","~$module$node_modules$$mui$material$node$transitions$utils"]],"~:properties",["^5",["keepMounted","appear","disableDiscovery","easing","width","ModalProps","passive","SwipeAreaProps","onClose","webkitTransition","hysteresis","lastTranslate","disableSwipeToOpen","children","component","x","__esModule","transform","PaperProps","reset","startY","propTypes","anchor","mode","name","startX","style","value","allowSwipeInChildren","BackdropProps","timeout","swipeAreaWidth","start","isSwiping","hideBackdrop","current","paperHit","defaultMuiPrevented","minFlingVelocity","props","disableBackdropTransition","webkitTransform","y","ref","__proto__","exit","open","transition","transitionDuration","enter","default","opacity","changeTransition","domTreeShapes","variant","pointerEvents","lastTime","velocity","onOpen"]],"~:compiled-at",1712152512029,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$material$node$SwipeableDrawer$SwipeableDrawer.js\",\n\"lineCount\":215,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/material/node/SwipeableDrawer/SwipeableDrawer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$material$node$SwipeableDrawer$SwipeableDrawer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = void 0;\\nexports.reset = reset;\\nvar _extends2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/extends\\\"));\\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/objectWithoutPropertiesLoose\\\"));\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar ReactDOM = _interopRequireWildcard(require(\\\"react-dom\\\"));\\nvar _propTypes = _interopRequireDefault(require(\\\"prop-types\\\"));\\nvar _elementTypeAcceptingRef = _interopRequireDefault(require(\\\"@mui/utils/elementTypeAcceptingRef\\\"));\\nvar _useThemeProps = _interopRequireDefault(require(\\\"@mui/system/useThemeProps\\\"));\\nvar _base = require(\\\"@mui/base\\\");\\nvar _Drawer = _interopRequireWildcard(require(\\\"../Drawer/Drawer\\\"));\\nvar _useForkRef = _interopRequireDefault(require(\\\"../utils/useForkRef\\\"));\\nvar _ownerDocument = _interopRequireDefault(require(\\\"../utils/ownerDocument\\\"));\\nvar _ownerWindow = _interopRequireDefault(require(\\\"../utils/ownerWindow\\\"));\\nvar _useEventCallback = _interopRequireDefault(require(\\\"../utils/useEventCallback\\\"));\\nvar _useEnhancedEffect = _interopRequireDefault(require(\\\"../utils/useEnhancedEffect\\\"));\\nvar _useTheme = _interopRequireDefault(require(\\\"../styles/useTheme\\\"));\\nvar _utils = require(\\\"../transitions/utils\\\");\\nvar _SwipeArea = _interopRequireDefault(require(\\\"./SwipeArea\\\"));\\nvar _jsxRuntime = require(\\\"react/jsx-runtime\\\");\\nconst _excluded = [\\\"BackdropProps\\\"],\\n  _excluded2 = [\\\"anchor\\\", \\\"disableBackdropTransition\\\", \\\"disableDiscovery\\\", \\\"disableSwipeToOpen\\\", \\\"hideBackdrop\\\", \\\"hysteresis\\\", \\\"allowSwipeInChildren\\\", \\\"minFlingVelocity\\\", \\\"ModalProps\\\", \\\"onClose\\\", \\\"onOpen\\\", \\\"open\\\", \\\"PaperProps\\\", \\\"SwipeAreaProps\\\", \\\"swipeAreaWidth\\\", \\\"transitionDuration\\\", \\\"variant\\\"]; // This value is closed to what browsers are using internally to\\n// trigger a native scroll.\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\nconst UNCERTAINTY_THRESHOLD = 3; // px\\n\\n// This is the part of the drawer displayed on touch start.\\nconst DRAG_STARTED_SIGNAL = 20; // px\\n\\n// We can only have one instance at the time claiming ownership for handling the swipe.\\n// Otherwise, the UX would be confusing.\\n// That's why we use a singleton here.\\nlet claimedSwipeInstance = null;\\n\\n// Exported for test purposes.\\nfunction reset() {\\n  claimedSwipeInstance = null;\\n}\\nfunction calculateCurrentX(anchor, touches, doc) {\\n  return anchor === 'right' ? doc.body.offsetWidth - touches[0].pageX : touches[0].pageX;\\n}\\nfunction calculateCurrentY(anchor, touches, containerWindow) {\\n  return anchor === 'bottom' ? containerWindow.innerHeight - touches[0].clientY : touches[0].clientY;\\n}\\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\\n}\\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\\n}\\n\\n/**\\n * @param {Element | null} element\\n * @param {Element} rootNode\\n */\\nfunction getDomTreeShapes(element, rootNode) {\\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L129\\n  const domTreeShapes = [];\\n  while (element && element !== rootNode.parentElement) {\\n    const style = (0, _ownerWindow.default)(rootNode).getComputedStyle(element);\\n    if (\\n    // Ignore the scroll children if the element is absolute positioned.\\n    style.getPropertyValue('position') === 'absolute' ||\\n    // Ignore the scroll children if the element has an overflowX hidden\\n    style.getPropertyValue('overflow-x') === 'hidden') {\\n      // noop\\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\\n      // Ignore the nodes that have no width.\\n      // Keep elements with a scroll\\n      domTreeShapes.push(element);\\n    }\\n    element = element.parentElement;\\n  }\\n  return domTreeShapes;\\n}\\n\\n/**\\n * @param {object} param0\\n * @param {ReturnType<getDomTreeShapes>} param0.domTreeShapes\\n */\\nfunction computeHasNativeHandler({\\n  domTreeShapes,\\n  start,\\n  current,\\n  anchor\\n}) {\\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L175\\n  const axisProperties = {\\n    scrollPosition: {\\n      x: 'scrollLeft',\\n      y: 'scrollTop'\\n    },\\n    scrollLength: {\\n      x: 'scrollWidth',\\n      y: 'scrollHeight'\\n    },\\n    clientLength: {\\n      x: 'clientWidth',\\n      y: 'clientHeight'\\n    }\\n  };\\n  return domTreeShapes.some(shape => {\\n    // Determine if we are going backward or forward.\\n    let goingForward = current >= start;\\n    if (anchor === 'top' || anchor === 'left') {\\n      goingForward = !goingForward;\\n    }\\n    const axis = anchor === 'left' || anchor === 'right' ? 'x' : 'y';\\n    const scrollPosition = Math.round(shape[axisProperties.scrollPosition[axis]]);\\n    const areNotAtStart = scrollPosition > 0;\\n    const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\\n      return true;\\n    }\\n    return false;\\n  });\\n}\\nconst iOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);\\nconst SwipeableDrawer = /*#__PURE__*/React.forwardRef(function SwipeableDrawer(inProps, ref) {\\n  const props = (0, _useThemeProps.default)({\\n    name: 'MuiSwipeableDrawer',\\n    props: inProps\\n  });\\n  const theme = (0, _useTheme.default)();\\n  const transitionDurationDefault = {\\n    enter: theme.transitions.duration.enteringScreen,\\n    exit: theme.transitions.duration.leavingScreen\\n  };\\n  const {\\n      anchor = 'left',\\n      disableBackdropTransition = false,\\n      disableDiscovery = false,\\n      disableSwipeToOpen = iOS,\\n      hideBackdrop,\\n      hysteresis = 0.52,\\n      allowSwipeInChildren = false,\\n      minFlingVelocity = 450,\\n      ModalProps: {\\n        BackdropProps\\n      } = {},\\n      onClose,\\n      onOpen,\\n      open = false,\\n      PaperProps = {},\\n      SwipeAreaProps,\\n      swipeAreaWidth = 20,\\n      transitionDuration = transitionDurationDefault,\\n      variant = 'temporary' // Mobile first.\\n    } = props,\\n    ModalPropsProp = (0, _objectWithoutPropertiesLoose2.default)(props.ModalProps, _excluded),\\n    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded2);\\n  const [maybeSwiping, setMaybeSwiping] = React.useState(false);\\n  const swipeInstance = React.useRef({\\n    isSwiping: null\\n  });\\n  const swipeAreaRef = React.useRef();\\n  const backdropRef = React.useRef();\\n  const paperRef = React.useRef();\\n  const handleRef = (0, _useForkRef.default)(PaperProps.ref, paperRef);\\n  const touchDetected = React.useRef(false);\\n\\n  // Ref for transition duration based on / to match swipe speed\\n  const calculatedDurationRef = React.useRef();\\n\\n  // Use a ref so the open value used is always up to date inside useCallback.\\n  (0, _useEnhancedEffect.default)(() => {\\n    calculatedDurationRef.current = null;\\n  }, [open]);\\n  const setPosition = React.useCallback((translate, options = {}) => {\\n    const {\\n      mode = null,\\n      changeTransition = true\\n    } = options;\\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    const rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\\n    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n    const transform = horizontalSwipe ? `translate(${rtlTranslateMultiplier * translate}px, 0)` : `translate(0, ${rtlTranslateMultiplier * translate}px)`;\\n    const drawerStyle = paperRef.current.style;\\n    drawerStyle.webkitTransform = transform;\\n    drawerStyle.transform = transform;\\n    let transition = '';\\n    if (mode) {\\n      transition = theme.transitions.create('all', (0, _utils.getTransitionProps)({\\n        easing: undefined,\\n        style: undefined,\\n        timeout: transitionDuration\\n      }, {\\n        mode\\n      }));\\n    }\\n    if (changeTransition) {\\n      drawerStyle.webkitTransition = transition;\\n      drawerStyle.transition = transition;\\n    }\\n    if (!disableBackdropTransition && !hideBackdrop) {\\n      const backdropStyle = backdropRef.current.style;\\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\\n      if (changeTransition) {\\n        backdropStyle.webkitTransition = transition;\\n        backdropStyle.transition = transition;\\n      }\\n    }\\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\\n  const handleBodyTouchEnd = (0, _useEventCallback.default)(nativeEvent => {\\n    if (!touchDetected.current) {\\n      return;\\n    }\\n    claimedSwipeInstance = null;\\n    touchDetected.current = false;\\n    ReactDOM.flushSync(() => {\\n      setMaybeSwiping(false);\\n    });\\n\\n    // The swipe wasn't started.\\n    if (!swipeInstance.current.isSwiping) {\\n      swipeInstance.current.isSwiping = null;\\n      return;\\n    }\\n    swipeInstance.current.isSwiping = null;\\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    const horizontal = (0, _Drawer.isHorizontal)(anchor);\\n    let current;\\n    if (horizontal) {\\n      current = calculateCurrentX(anchorRtl, nativeEvent.changedTouches, (0, _ownerDocument.default)(nativeEvent.currentTarget));\\n    } else {\\n      current = calculateCurrentY(anchorRtl, nativeEvent.changedTouches, (0, _ownerWindow.default)(nativeEvent.currentTarget));\\n    }\\n    const startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\\n    const maxTranslate = getMaxTranslate(horizontal, paperRef.current);\\n    const currentTranslate = getTranslate(current, startLocation, open, maxTranslate);\\n    const translateRatio = currentTranslate / maxTranslate;\\n    if (Math.abs(swipeInstance.current.velocity) > minFlingVelocity) {\\n      // Calculate transition duration to match swipe speed\\n      calculatedDurationRef.current = Math.abs((maxTranslate - currentTranslate) / swipeInstance.current.velocity) * 1000;\\n    }\\n    if (open) {\\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\\n        onClose();\\n      } else {\\n        // Reset the position, the swipe was aborted.\\n        setPosition(0, {\\n          mode: 'exit'\\n        });\\n      }\\n      return;\\n    }\\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\\n      onOpen();\\n    } else {\\n      // Reset the position, the swipe was aborted.\\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\\n        mode: 'enter'\\n      });\\n    }\\n  });\\n  const startMaybeSwiping = (force = false) => {\\n    if (!maybeSwiping) {\\n      // on Safari Mobile, if you want to be able to have the 'click' event fired on child elements, nothing in the DOM can be changed.\\n      // this is because Safari Mobile will not fire any mouse events (still fires touch though) if the DOM changes during mousemove.\\n      // so do this change on first touchmove instead of touchstart\\n      if (force || !(disableDiscovery && allowSwipeInChildren)) {\\n        ReactDOM.flushSync(() => {\\n          setMaybeSwiping(true);\\n        });\\n      }\\n      const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n      if (!open && paperRef.current) {\\n        // The ref may be null when a parent component updates while swiping.\\n        setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 15 : -DRAG_STARTED_SIGNAL), {\\n          changeTransition: false\\n        });\\n      }\\n      swipeInstance.current.velocity = 0;\\n      swipeInstance.current.lastTime = null;\\n      swipeInstance.current.lastTranslate = null;\\n      swipeInstance.current.paperHit = false;\\n      touchDetected.current = true;\\n    }\\n  };\\n  const handleBodyTouchMove = (0, _useEventCallback.default)(nativeEvent => {\\n    // the ref may be null when a parent component updates while swiping\\n    if (!paperRef.current || !touchDetected.current) {\\n      return;\\n    }\\n\\n    // We are not supposed to handle this touch move because the swipe was started in a scrollable container in the drawer\\n    if (claimedSwipeInstance !== null && claimedSwipeInstance !== swipeInstance.current) {\\n      return;\\n    }\\n    startMaybeSwiping(true);\\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n    const currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0, _ownerDocument.default)(nativeEvent.currentTarget));\\n    const currentY = calculateCurrentY(anchorRtl, nativeEvent.touches, (0, _ownerWindow.default)(nativeEvent.currentTarget));\\n    if (open && paperRef.current.contains(nativeEvent.target) && claimedSwipeInstance === null) {\\n      const domTreeShapes = getDomTreeShapes(nativeEvent.target, paperRef.current);\\n      const hasNativeHandler = computeHasNativeHandler({\\n        domTreeShapes,\\n        start: horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY,\\n        current: horizontalSwipe ? currentX : currentY,\\n        anchor\\n      });\\n      if (hasNativeHandler) {\\n        claimedSwipeInstance = true;\\n        return;\\n      }\\n      claimedSwipeInstance = swipeInstance.current;\\n    }\\n\\n    // We don't know yet.\\n    if (swipeInstance.current.isSwiping == null) {\\n      const dx = Math.abs(currentX - swipeInstance.current.startX);\\n      const dy = Math.abs(currentY - swipeInstance.current.startY);\\n      const definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\\n      if (definitelySwiping && nativeEvent.cancelable) {\\n        nativeEvent.preventDefault();\\n      }\\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\\n        swipeInstance.current.isSwiping = definitelySwiping;\\n        if (!definitelySwiping) {\\n          handleBodyTouchEnd(nativeEvent);\\n          return;\\n        }\\n\\n        // Shift the starting point.\\n        swipeInstance.current.startX = currentX;\\n        swipeInstance.current.startY = currentY;\\n\\n        // Compensate for the part of the drawer displayed on touch start.\\n        if (!disableDiscovery && !open) {\\n          if (horizontalSwipe) {\\n            swipeInstance.current.startX -= DRAG_STARTED_SIGNAL;\\n          } else {\\n            swipeInstance.current.startY -= DRAG_STARTED_SIGNAL;\\n          }\\n        }\\n      }\\n    }\\n    if (!swipeInstance.current.isSwiping) {\\n      return;\\n    }\\n    const maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\\n    let startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\\n    if (open && !swipeInstance.current.paperHit) {\\n      startLocation = Math.min(startLocation, maxTranslate);\\n    }\\n    const translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, open, maxTranslate);\\n    if (open) {\\n      if (!swipeInstance.current.paperHit) {\\n        const paperHit = horizontalSwipe ? currentX < maxTranslate : currentY < maxTranslate;\\n        if (paperHit) {\\n          swipeInstance.current.paperHit = true;\\n          swipeInstance.current.startX = currentX;\\n          swipeInstance.current.startY = currentY;\\n        } else {\\n          return;\\n        }\\n      } else if (translate === 0) {\\n        swipeInstance.current.startX = currentX;\\n        swipeInstance.current.startY = currentY;\\n      }\\n    }\\n    if (swipeInstance.current.lastTranslate === null) {\\n      swipeInstance.current.lastTranslate = translate;\\n      swipeInstance.current.lastTime = performance.now() + 1;\\n    }\\n    const velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3;\\n\\n    // Low Pass filter.\\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\\n    swipeInstance.current.lastTranslate = translate;\\n    swipeInstance.current.lastTime = performance.now();\\n\\n    // We are swiping, let's prevent the scroll event on iOS.\\n    if (nativeEvent.cancelable) {\\n      nativeEvent.preventDefault();\\n    }\\n    setPosition(translate);\\n  });\\n  const handleBodyTouchStart = (0, _useEventCallback.default)(nativeEvent => {\\n    // We are not supposed to handle this touch move.\\n    // Example of use case: ignore the event if there is a Slider.\\n    if (nativeEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    // We can only have one node at the time claiming ownership for handling the swipe.\\n    if (nativeEvent.defaultMuiPrevented) {\\n      return;\\n    }\\n\\n    // At least one element clogs the drawer interaction zone.\\n    if (open && (hideBackdrop || !backdropRef.current.contains(nativeEvent.target)) && !paperRef.current.contains(nativeEvent.target)) {\\n      return;\\n    }\\n    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n    const currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0, _ownerDocument.default)(nativeEvent.currentTarget));\\n    const currentY = calculateCurrentY(anchorRtl, nativeEvent.touches, (0, _ownerWindow.default)(nativeEvent.currentTarget));\\n    if (!open) {\\n      var _paperRef$current;\\n      // logic for if swipe should be ignored:\\n      // if disableSwipeToOpen\\n      // if target != swipeArea, and target is not a child of paper ref\\n      // if is a child of paper ref, and `allowSwipeInChildren` does not allow it\\n      if (disableSwipeToOpen || !(nativeEvent.target === swipeAreaRef.current || (_paperRef$current = paperRef.current) != null && _paperRef$current.contains(nativeEvent.target) && (typeof allowSwipeInChildren === 'function' ? allowSwipeInChildren(nativeEvent, swipeAreaRef.current, paperRef.current) : allowSwipeInChildren))) {\\n        return;\\n      }\\n      if (horizontalSwipe) {\\n        if (currentX > swipeAreaWidth) {\\n          return;\\n        }\\n      } else if (currentY > swipeAreaWidth) {\\n        return;\\n      }\\n    }\\n    nativeEvent.defaultMuiPrevented = true;\\n    claimedSwipeInstance = null;\\n    swipeInstance.current.startX = currentX;\\n    swipeInstance.current.startY = currentY;\\n    startMaybeSwiping();\\n  });\\n  React.useEffect(() => {\\n    if (variant === 'temporary') {\\n      const doc = (0, _ownerDocument.default)(paperRef.current);\\n      doc.addEventListener('touchstart', handleBodyTouchStart);\\n      // A blocking listener prevents Firefox's navbar to auto-hide on scroll.\\n      // It only needs to prevent scrolling on the drawer's content when open.\\n      // When closed, the overlay prevents scrolling.\\n      doc.addEventListener('touchmove', handleBodyTouchMove, {\\n        passive: !open\\n      });\\n      doc.addEventListener('touchend', handleBodyTouchEnd);\\n      return () => {\\n        doc.removeEventListener('touchstart', handleBodyTouchStart);\\n        doc.removeEventListener('touchmove', handleBodyTouchMove, {\\n          passive: !open\\n        });\\n        doc.removeEventListener('touchend', handleBodyTouchEnd);\\n      };\\n    }\\n    return undefined;\\n  }, [variant, open, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\\n  React.useEffect(() => () => {\\n    // We need to release the lock.\\n    if (claimedSwipeInstance === swipeInstance.current) {\\n      claimedSwipeInstance = null;\\n    }\\n  }, []);\\n  React.useEffect(() => {\\n    if (!open) {\\n      setMaybeSwiping(false);\\n    }\\n  }, [open]);\\n  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {\\n    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Drawer.default, (0, _extends2.default)({\\n      open: variant === 'temporary' && maybeSwiping ? true : open,\\n      variant: variant,\\n      ModalProps: (0, _extends2.default)({\\n        BackdropProps: (0, _extends2.default)({}, BackdropProps, {\\n          ref: backdropRef\\n        })\\n      }, variant === 'temporary' && {\\n        keepMounted: true\\n      }, ModalPropsProp),\\n      hideBackdrop: hideBackdrop,\\n      PaperProps: (0, _extends2.default)({}, PaperProps, {\\n        style: (0, _extends2.default)({\\n          pointerEvents: variant === 'temporary' && !open && !allowSwipeInChildren ? 'none' : ''\\n        }, PaperProps.style),\\n        ref: handleRef\\n      }),\\n      anchor: anchor,\\n      transitionDuration: calculatedDurationRef.current || transitionDuration,\\n      onClose: onClose,\\n      ref: ref\\n    }, other)), !disableSwipeToOpen && variant === 'temporary' && /*#__PURE__*/(0, _jsxRuntime.jsx)(_base.NoSsr, {\\n      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_SwipeArea.default, (0, _extends2.default)({\\n        anchor: anchor,\\n        ref: swipeAreaRef,\\n        width: swipeAreaWidth\\n      }, SwipeAreaProps))\\n    })]\\n  });\\n});\\nprocess.env.NODE_ENV !== \\\"production\\\" ? SwipeableDrawer.propTypes /* remove-proptypes */ = {\\n  // \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 Warning \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n  // \\u2502 These PropTypes are generated from the TypeScript type definitions. \\u2502\\n  // \\u2502    To update them, edit the d.ts file and run `pnpm proptypes`.     \\u2502\\n  // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n  /**\\n   * If set to true, the swipe event will open the drawer even if the user begins the swipe on one of the drawer's children.\\n   * This can be useful in scenarios where the drawer is partially visible.\\n   * You can customize it further with a callback that determines which children the user can drag over to open the drawer\\n   * (for example, to ignore other elements that handle touch move events, like sliders).\\n   *\\n   * @param {TouchEvent} event The 'touchstart' event\\n   * @param {HTMLDivElement} swipeArea The swipe area element\\n   * @param {HTMLDivElement} paper The drawer's paper element\\n   *\\n   * @default false\\n   */\\n  allowSwipeInChildren: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),\\n  /**\\n   * @ignore\\n   */\\n  anchor: _propTypes.default.oneOf(['bottom', 'left', 'right', 'top']),\\n  /**\\n   * The content of the component.\\n   */\\n  children: _propTypes.default.node,\\n  /**\\n   * Disable the backdrop transition.\\n   * This can improve the FPS on low-end devices.\\n   * @default false\\n   */\\n  disableBackdropTransition: _propTypes.default.bool,\\n  /**\\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\\n   * to promote accidental discovery of the swipe gesture.\\n   * @default false\\n   */\\n  disableDiscovery: _propTypes.default.bool,\\n  /**\\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\\n   * @default typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent)\\n   */\\n  disableSwipeToOpen: _propTypes.default.bool,\\n  /**\\n   * @ignore\\n   */\\n  hideBackdrop: _propTypes.default.bool,\\n  /**\\n   * Affects how far the drawer must be opened/closed to change its state.\\n   * Specified as percent (0-1) of the width of the drawer\\n   * @default 0.52\\n   */\\n  hysteresis: _propTypes.default.number,\\n  /**\\n   * Defines, from which (average) velocity on, the swipe is\\n   * defined as complete although hysteresis isn't reached.\\n   * Good threshold is between 250 - 1000 px/s\\n   * @default 450\\n   */\\n  minFlingVelocity: _propTypes.default.number,\\n  /**\\n   * @ignore\\n   */\\n  ModalProps: _propTypes.default /* @typescript-to-proptypes-ignore */.shape({\\n    BackdropProps: _propTypes.default.shape({\\n      component: _elementTypeAcceptingRef.default\\n    })\\n  }),\\n  /**\\n   * Callback fired when the component requests to be closed.\\n   *\\n   * @param {React.SyntheticEvent<{}>} event The event source of the callback.\\n   */\\n  onClose: _propTypes.default.func.isRequired,\\n  /**\\n   * Callback fired when the component requests to be opened.\\n   *\\n   * @param {React.SyntheticEvent<{}>} event The event source of the callback.\\n   */\\n  onOpen: _propTypes.default.func.isRequired,\\n  /**\\n   * If `true`, the component is shown.\\n   * @default false\\n   */\\n  open: _propTypes.default.bool,\\n  /**\\n   * @ignore\\n   */\\n  PaperProps: _propTypes.default /* @typescript-to-proptypes-ignore */.shape({\\n    component: _elementTypeAcceptingRef.default,\\n    style: _propTypes.default.object\\n  }),\\n  /**\\n   * The element is used to intercept the touch events on the edge.\\n   */\\n  SwipeAreaProps: _propTypes.default.object,\\n  /**\\n   * The width of the left most (or right most) area in `px` that\\n   * the drawer can be swiped open from.\\n   * @default 20\\n   */\\n  swipeAreaWidth: _propTypes.default.number,\\n  /**\\n   * The duration for the transition, in milliseconds.\\n   * You may specify a single timeout for all transitions, or individually with an object.\\n   * @default {\\n   *   enter: theme.transitions.duration.enteringScreen,\\n   *   exit: theme.transitions.duration.leavingScreen,\\n   * }\\n   */\\n  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({\\n    appear: _propTypes.default.number,\\n    enter: _propTypes.default.number,\\n    exit: _propTypes.default.number\\n  })]),\\n  /**\\n   * @ignore\\n   */\\n  variant: _propTypes.default.oneOf(['permanent', 'persistent', 'temporary'])\\n} : void 0;\\nvar _default = exports.default = SwipeableDrawer;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"_interopRequireWildcard\",\"__esModule\",\"default\",\"has\",\"get\",\"n\",\"__proto__\",\"a\",\"Object\",\"defineProperty\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"call\",\"i\",\"set\",\"calculateCurrentX\",\"anchor\",\"touches\",\"doc\",\"body\",\"offsetWidth\",\"pageX\",\"calculateCurrentY\",\"containerWindow\",\"innerHeight\",\"clientY\",\"getMaxTranslate\",\"horizontalSwipe\",\"paperInstance\",\"clientWidth\",\"clientHeight\",\"computeHasNativeHandler\",\"domTreeShapes\",\"start\",\"current\",\"x\",\"y\",\"some\",\"shape\",\"goingForward\",\"axis\",\"scrollPosition\",\"Math\",\"round\",\"areNotAtEnd\",\"clientLength\",\"scrollLength\",\"_interopRequireDefault\",\"value\",\"reset\",\"claimedSwipeInstance\",\"_extends2\",\"_objectWithoutPropertiesLoose2\",\"React\",\"ReactDOM\",\"_propTypes\",\"_elementTypeAcceptingRef\",\"_useThemeProps\",\"_base\",\"_Drawer\",\"_useForkRef\",\"_ownerDocument\",\"_ownerWindow\",\"_useEventCallback\",\"_useEnhancedEffect\",\"_useTheme\",\"_utils\",\"_SwipeArea\",\"_jsxRuntime\",\"_excluded\",\"_excluded2\",\"iOS\",\"navigator\",\"test\",\"userAgent\",\"SwipeableDrawer\",\"forwardRef\",\"inProps\",\"ref\",\"props\",\"name\",\"theme\",\"transitionDurationDefault\",\"enter\",\"transitions\",\"duration\",\"enteringScreen\",\"exit\",\"leavingScreen\",\"disableBackdropTransition\",\"disableDiscovery\",\"disableSwipeToOpen\",\"hideBackdrop\",\"hysteresis\",\"allowSwipeInChildren\",\"minFlingVelocity\",\"BackdropProps\",\"onClose\",\"onOpen\",\"open\",\"PaperProps\",\"SwipeAreaProps\",\"swipeAreaWidth\",\"transitionDuration\",\"variant\",\"ModalPropsProp\",\"ModalProps\",\"other\",\"maybeSwiping\",\"setMaybeSwiping\",\"useState\",\"swipeInstance\",\"useRef\",\"isSwiping\",\"swipeAreaRef\",\"backdropRef\",\"paperRef\",\"handleRef\",\"touchDetected\",\"calculatedDurationRef\",\"setPosition\",\"useCallback\",\"translate\",\"options\",\"mode\",\"changeTransition\",\"anchorRtl\",\"getAnchor\",\"rtlTranslateMultiplier\",\"indexOf\",\"transform\",\"isHorizontal\",\"drawerStyle\",\"style\",\"webkitTransform\",\"transition\",\"create\",\"getTransitionProps\",\"easing\",\"undefined\",\"timeout\",\"webkitTransition\",\"backdropStyle\",\"opacity\",\"handleBodyTouchEnd\",\"nativeEvent\",\"flushSync\",\"horizontal\",\"changedTouches\",\"currentTarget\",\"startLocation\",\"startX\",\"startY\",\"maxTranslate\",\"currentTranslate\",\"min\",\"max\",\"translateRatio\",\"abs\",\"velocity\",\"startMaybeSwiping\",\"force\",\"DRAG_STARTED_SIGNAL\",\"lastTime\",\"lastTranslate\",\"paperHit\",\"handleBodyTouchMove\",\"currentX\",\"currentY\",\"contains\",\"target\",\"element\",\"rootNode\",\"parentElement\",\"getComputedStyle\",\"getPropertyValue\",\"scrollWidth\",\"scrollHeight\",\"push\",\"hasNativeHandler\",\"dx\",\"dy\",\"definitelySwiping\",\"UNCERTAINTY_THRESHOLD\",\"cancelable\",\"preventDefault\",\"performance\",\"now\",\"handleBodyTouchStart\",\"defaultPrevented\",\"defaultMuiPrevented\",\"_paperRef$current\",\"useEffect\",\"addEventListener\",\"passive\",\"removeEventListener\",\"jsxs\",\"Fragment\",\"children\",\"jsx\",\"keepMounted\",\"pointerEvents\",\"NoSsr\",\"width\",\"propTypes\",\"oneOfType\",\"func\",\"bool\",\"oneOf\",\"node\",\"number\",\"component\",\"isRequired\",\"object\",\"appear\"]\n}\n"]