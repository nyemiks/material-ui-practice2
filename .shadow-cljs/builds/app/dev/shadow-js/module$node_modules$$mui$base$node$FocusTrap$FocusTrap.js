["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/base/node/FocusTrap/FocusTrap.js"],"~:js","shadow$provide.module$node_modules$$mui$base$node$FocusTrap$FocusTrap = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  function defaultGetTabbable(root) {\n    const regularTabNodes = [], orderedTabNodes = [];\n    Array.from(root.querySelectorAll('input,select,textarea,a[href],button,[tabindex],audio[controls],video[controls],[contenteditable]:not([contenteditable\\x3d\"false\"])')).forEach((node, i) => {\n      var JSCompiler_inline_result = parseInt(node.getAttribute(\"tabindex\") || \"\", 10);\n      JSCompiler_inline_result = Number.isNaN(JSCompiler_inline_result) ? \"true\" === node.contentEditable || (\"AUDIO\" === node.nodeName || \"VIDEO\" === node.nodeName || \"DETAILS\" === node.nodeName) && null === node.getAttribute(\"tabindex\") ? 0 : node.tabIndex : JSCompiler_inline_result;\n      var JSCompiler_temp;\n      (JSCompiler_temp = -1 === JSCompiler_inline_result) || ((JSCompiler_temp = node.disabled || \"INPUT\" === node.tagName && \"hidden\" === node.type) || (\"INPUT\" === node.tagName && \"radio\" === node.type && node.name ? ((JSCompiler_temp = node.ownerDocument.querySelector(`input[type=\"radio\"]${`[name=\"${node.name}\"]:checked`}`)) || (JSCompiler_temp = node.ownerDocument.querySelector(`input[type=\"radio\"]${`[name=\"${node.name}\"]`}`)), JSCompiler_temp = JSCompiler_temp !== node) : JSCompiler_temp = !1), \n      JSCompiler_temp = !!JSCompiler_temp);\n      JSCompiler_temp || (0 === JSCompiler_inline_result ? regularTabNodes.push(node) : orderedTabNodes.push({documentOrder:i, tabIndex:JSCompiler_inline_result, node}));\n    });\n    return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);\n  }\n  function defaultIsEnabled() {\n    return !0;\n  }\n  function FocusTrap(props) {\n    const {children, disableAutoFocus = !1, disableEnforceFocus = !1, disableRestoreFocus = !1, getTabbable = defaultGetTabbable, isEnabled = defaultIsEnabled, open} = props, ignoreNextEnforceFocus = React.useRef(!1), sentinelStart = React.useRef(null), sentinelEnd = React.useRef(null), nodeToRestore = React.useRef(null), reactFocusEventTarget = React.useRef(null), activated = React.useRef(!1), rootRef = React.useRef(null);\n    props = (0,_utils.unstable_useForkRef)(children.ref, rootRef);\n    const lastKeydown = React.useRef(null);\n    React.useEffect(() => {\n      open && rootRef.current && (activated.current = !disableAutoFocus);\n    }, [disableAutoFocus, open]);\n    React.useEffect(() => {\n      if (open && rootRef.current) {\n        var doc = (0,_utils.unstable_ownerDocument)(rootRef.current);\n        rootRef.current.contains(doc.activeElement) || (rootRef.current.hasAttribute(\"tabIndex\") || (console.error('MUI: The modal content node does not accept focus.\\nFor the benefit of assistive technologies, the tabIndex of the node is being set to \"-1\".'), rootRef.current.setAttribute(\"tabIndex\", \"-1\")), activated.current && rootRef.current.focus());\n        return () => {\n          disableRestoreFocus || (nodeToRestore.current && nodeToRestore.current.focus && (ignoreNextEnforceFocus.current = !0, nodeToRestore.current.focus()), nodeToRestore.current = null);\n        };\n      }\n    }, [open]);\n    React.useEffect(() => {\n      if (open && rootRef.current) {\n        var doc = (0,_utils.unstable_ownerDocument)(rootRef.current), loopFocus = nativeEvent => {\n          lastKeydown.current = nativeEvent;\n          !disableEnforceFocus && isEnabled() && \"Tab\" === nativeEvent.key && doc.activeElement === rootRef.current && nativeEvent.shiftKey && (ignoreNextEnforceFocus.current = !0, sentinelEnd.current && sentinelEnd.current.focus());\n        }, contain = () => {\n          var rootElement = rootRef.current;\n          if (null !== rootElement) {\n            if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {\n              ignoreNextEnforceFocus.current = !1;\n            } else {\n              if (!(rootElement.contains(doc.activeElement) || disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current)) {\n                if (doc.activeElement !== reactFocusEventTarget.current) {\n                  reactFocusEventTarget.current = null;\n                } else if (null !== reactFocusEventTarget.current) {\n                  return;\n                }\n                if (activated.current) {\n                  var tabbable = [];\n                  if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {\n                    tabbable = getTabbable(rootRef.current);\n                  }\n                  if (0 < tabbable.length) {\n                    var _lastKeydown$current, _lastKeydown$current2;\n                    rootElement = !(null == (_lastKeydown$current = lastKeydown.current) || !_lastKeydown$current.shiftKey || \"Tab\" !== (null == (_lastKeydown$current2 = lastKeydown.current) ? void 0 : _lastKeydown$current2.key));\n                    _lastKeydown$current = tabbable[0];\n                    tabbable = tabbable[tabbable.length - 1];\n                    \"string\" !== typeof _lastKeydown$current && \"string\" !== typeof tabbable && (rootElement ? tabbable.focus() : _lastKeydown$current.focus());\n                  } else {\n                    rootElement.focus();\n                  }\n                }\n              }\n            }\n          }\n        };\n        doc.addEventListener(\"focusin\", contain);\n        doc.addEventListener(\"keydown\", loopFocus, !0);\n        var interval = setInterval(() => {\n          doc.activeElement && \"BODY\" === doc.activeElement.tagName && contain();\n        }, 50);\n        return () => {\n          clearInterval(interval);\n          doc.removeEventListener(\"focusin\", contain);\n          doc.removeEventListener(\"keydown\", loopFocus, !0);\n        };\n      }\n    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);\n    const handleFocusSentinel = event => {\n      null === nodeToRestore.current && (nodeToRestore.current = event.relatedTarget);\n      activated.current = !0;\n    };\n    return (0,_jsxRuntime.jsxs)(React.Fragment, {children:[(0,_jsxRuntime.jsx)(\"div\", {tabIndex:open ? 0 : -1, onFocus:handleFocusSentinel, ref:sentinelStart, \"data-testid\":\"sentinelStart\"}), React.cloneElement(children, {ref:props, onFocus:event => {\n      null === nodeToRestore.current && (nodeToRestore.current = event.relatedTarget);\n      activated.current = !0;\n      reactFocusEventTarget.current = event.target;\n      const childrenPropsHandler = children.props.onFocus;\n      childrenPropsHandler && childrenPropsHandler(event);\n    }}), (0,_jsxRuntime.jsx)(\"div\", {tabIndex:open ? 0 : -1, onFocus:handleFocusSentinel, ref:sentinelEnd, \"data-testid\":\"sentinelEnd\"})]});\n  }\n  \"use client\";\n  global = require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.FocusTrap = FocusTrap;\n  var React = function(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }(require(\"module$node_modules$react$index\"));\n  exports = global(require(\"module$node_modules$prop_types$index\"));\n  var _utils = require(\"module$node_modules$$mui$utils$node$index\"), _jsxRuntime = require(\"module$node_modules$react$jsx_runtime\");\n  FocusTrap.propTypes = {children:_utils.elementAcceptingRef, disableAutoFocus:exports.default.bool, disableEnforceFocus:exports.default.bool, disableRestoreFocus:exports.default.bool, getTabbable:exports.default.func, isEnabled:exports.default.func, open:exports.default.bool.isRequired};\n  FocusTrap.propTypes = (0,_utils.exactProp)(FocusTrap.propTypes);\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$base$node$FocusTrap$FocusTrap\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\n/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex */\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FocusTrap = FocusTrap;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _utils = require(\"@mui/utils\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n// Inspired by https://github.com/focus-trap/tabbable\nconst candidatesSelector = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])'].join(',');\nfunction getTabIndex(node) {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);\n  if (!Number.isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=661108&q=contenteditable%20tabindex&can=2\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n  if (node.contentEditable === 'true' || (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n  return node.tabIndex;\n}\nfunction isNonTabbableRadio(node) {\n  if (node.tagName !== 'INPUT' || node.type !== 'radio') {\n    return false;\n  }\n  if (!node.name) {\n    return false;\n  }\n  const getRadio = selector => node.ownerDocument.querySelector(`input[type=\"radio\"]${selector}`);\n  let roving = getRadio(`[name=\"${node.name}\"]:checked`);\n  if (!roving) {\n    roving = getRadio(`[name=\"${node.name}\"]`);\n  }\n  return roving !== node;\n}\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || node.tagName === 'INPUT' && node.type === 'hidden' || isNonTabbableRadio(node)) {\n    return false;\n  }\n  return true;\n}\nfunction defaultGetTabbable(root) {\n  const regularTabNodes = [];\n  const orderedTabNodes = [];\n  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {\n    const nodeTabIndex = getTabIndex(node);\n    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {\n      return;\n    }\n    if (nodeTabIndex === 0) {\n      regularTabNodes.push(node);\n    } else {\n      orderedTabNodes.push({\n        documentOrder: i,\n        tabIndex: nodeTabIndex,\n        node: node\n      });\n    }\n  });\n  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);\n}\nfunction defaultIsEnabled() {\n  return true;\n}\n\n/**\n * Utility component that locks focus inside the component.\n *\n * Demos:\n *\n * - [Focus Trap](https://mui.com/base-ui/react-focus-trap/)\n *\n * API:\n *\n * - [FocusTrap API](https://mui.com/base-ui/react-focus-trap/components-api/#focus-trap)\n */\nfunction FocusTrap(props) {\n  const {\n    children,\n    disableAutoFocus = false,\n    disableEnforceFocus = false,\n    disableRestoreFocus = false,\n    getTabbable = defaultGetTabbable,\n    isEnabled = defaultIsEnabled,\n    open\n  } = props;\n  const ignoreNextEnforceFocus = React.useRef(false);\n  const sentinelStart = React.useRef(null);\n  const sentinelEnd = React.useRef(null);\n  const nodeToRestore = React.useRef(null);\n  const reactFocusEventTarget = React.useRef(null);\n  // This variable is useful when disableAutoFocus is true.\n  // It waits for the active element to move into the component to activate.\n  const activated = React.useRef(false);\n  const rootRef = React.useRef(null);\n  // @ts-expect-error TODO upstream fix\n  const handleRef = (0, _utils.unstable_useForkRef)(children.ref, rootRef);\n  const lastKeydown = React.useRef(null);\n  React.useEffect(() => {\n    // We might render an empty child.\n    if (!open || !rootRef.current) {\n      return;\n    }\n    activated.current = !disableAutoFocus;\n  }, [disableAutoFocus, open]);\n  React.useEffect(() => {\n    // We might render an empty child.\n    if (!open || !rootRef.current) {\n      return;\n    }\n    const doc = (0, _utils.unstable_ownerDocument)(rootRef.current);\n    if (!rootRef.current.contains(doc.activeElement)) {\n      if (!rootRef.current.hasAttribute('tabIndex')) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(['MUI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to \"-1\".'].join('\\n'));\n        }\n        rootRef.current.setAttribute('tabIndex', '-1');\n      }\n      if (activated.current) {\n        rootRef.current.focus();\n      }\n    }\n    return () => {\n      // restoreLastFocus()\n      if (!disableRestoreFocus) {\n        // In IE11 it is possible for document.activeElement to be null resulting\n        // in nodeToRestore.current being null.\n        // Not all elements in IE11 have a focus method.\n        // Once IE11 support is dropped the focus() call can be unconditional.\n        if (nodeToRestore.current && nodeToRestore.current.focus) {\n          ignoreNextEnforceFocus.current = true;\n          nodeToRestore.current.focus();\n        }\n        nodeToRestore.current = null;\n      }\n    };\n    // Missing `disableRestoreFocus` which is fine.\n    // We don't support changing that prop on an open FocusTrap\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [open]);\n  React.useEffect(() => {\n    // We might render an empty child.\n    if (!open || !rootRef.current) {\n      return;\n    }\n    const doc = (0, _utils.unstable_ownerDocument)(rootRef.current);\n    const loopFocus = nativeEvent => {\n      lastKeydown.current = nativeEvent;\n      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== 'Tab') {\n        return;\n      }\n\n      // Make sure the next tab starts from the right place.\n      // doc.activeElement refers to the origin.\n      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {\n        // We need to ignore the next contain as\n        // it will try to move the focus back to the rootRef element.\n        ignoreNextEnforceFocus.current = true;\n        if (sentinelEnd.current) {\n          sentinelEnd.current.focus();\n        }\n      }\n    };\n    const contain = () => {\n      const rootElement = rootRef.current;\n\n      // Cleanup functions are executed lazily in React 17.\n      // Contain can be called between the component being unmounted and its cleanup function being run.\n      if (rootElement === null) {\n        return;\n      }\n      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {\n        ignoreNextEnforceFocus.current = false;\n        return;\n      }\n\n      // The focus is already inside\n      if (rootElement.contains(doc.activeElement)) {\n        return;\n      }\n\n      // The disableEnforceFocus is set and the focus is outside of the focus trap (and sentinel nodes)\n      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {\n        return;\n      }\n\n      // if the focus event is not coming from inside the children's react tree, reset the refs\n      if (doc.activeElement !== reactFocusEventTarget.current) {\n        reactFocusEventTarget.current = null;\n      } else if (reactFocusEventTarget.current !== null) {\n        return;\n      }\n      if (!activated.current) {\n        return;\n      }\n      let tabbable = [];\n      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {\n        tabbable = getTabbable(rootRef.current);\n      }\n\n      // one of the sentinel nodes was focused, so move the focus\n      // to the first/last tabbable element inside the focus trap\n      if (tabbable.length > 0) {\n        var _lastKeydown$current, _lastKeydown$current2;\n        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === 'Tab');\n        const focusNext = tabbable[0];\n        const focusPrevious = tabbable[tabbable.length - 1];\n        if (typeof focusNext !== 'string' && typeof focusPrevious !== 'string') {\n          if (isShiftTab) {\n            focusPrevious.focus();\n          } else {\n            focusNext.focus();\n          }\n        }\n        // no tabbable elements in the trap focus or the focus was outside of the focus trap\n      } else {\n        rootElement.focus();\n      }\n    };\n    doc.addEventListener('focusin', contain);\n    doc.addEventListener('keydown', loopFocus, true);\n\n    // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area.\n    // for example https://bugzilla.mozilla.org/show_bug.cgi?id=559561.\n    // Instead, we can look if the active element was restored on the BODY element.\n    //\n    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:\n    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.\n    const interval = setInterval(() => {\n      if (doc.activeElement && doc.activeElement.tagName === 'BODY') {\n        contain();\n      }\n    }, 50);\n    return () => {\n      clearInterval(interval);\n      doc.removeEventListener('focusin', contain);\n      doc.removeEventListener('keydown', loopFocus, true);\n    };\n  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);\n  const onFocus = event => {\n    if (nodeToRestore.current === null) {\n      nodeToRestore.current = event.relatedTarget;\n    }\n    activated.current = true;\n    reactFocusEventTarget.current = event.target;\n    const childrenPropsHandler = children.props.onFocus;\n    if (childrenPropsHandler) {\n      childrenPropsHandler(event);\n    }\n  };\n  const handleFocusSentinel = event => {\n    if (nodeToRestore.current === null) {\n      nodeToRestore.current = event.relatedTarget;\n    }\n    activated.current = true;\n  };\n  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {\n    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(\"div\", {\n      tabIndex: open ? 0 : -1,\n      onFocus: handleFocusSentinel,\n      ref: sentinelStart,\n      \"data-testid\": \"sentinelStart\"\n    }), /*#__PURE__*/React.cloneElement(children, {\n      ref: handleRef,\n      onFocus\n    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(\"div\", {\n      tabIndex: open ? 0 : -1,\n      onFocus: handleFocusSentinel,\n      ref: sentinelEnd,\n      \"data-testid\": \"sentinelEnd\"\n    })]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? FocusTrap.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * A single child content element.\n   */\n  children: _utils.elementAcceptingRef,\n  /**\n   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and\n   * replace it to the last focused element when it closes.\n   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.\n   *\n   * Generally this should never be set to `true` as it makes the focus trap less\n   * accessible to assistive technologies, like screen readers.\n   * @default false\n   */\n  disableAutoFocus: _propTypes.default.bool,\n  /**\n   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.\n   *\n   * Generally this should never be set to `true` as it makes the focus trap less\n   * accessible to assistive technologies, like screen readers.\n   * @default false\n   */\n  disableEnforceFocus: _propTypes.default.bool,\n  /**\n   * If `true`, the focus trap will not restore focus to previously focused element once\n   * focus trap is hidden or unmounted.\n   * @default false\n   */\n  disableRestoreFocus: _propTypes.default.bool,\n  /**\n   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.\n   * For instance, you can provide the \"tabbable\" npm dependency.\n   * @param {HTMLElement} root\n   */\n  getTabbable: _propTypes.default.func,\n  /**\n   * This prop extends the `open` prop.\n   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.\n   * This prop should be memoized.\n   * It can be used to support multiple focus trap mounted at the same time.\n   * @default function defaultIsEnabled(): boolean {\n   *   return true;\n   * }\n   */\n  isEnabled: _propTypes.default.func,\n  /**\n   * If `true`, focus is locked.\n   */\n  open: _propTypes.default.bool.isRequired\n} : void 0;\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line\n  FocusTrap['propTypes' + ''] = (0, _utils.exactProp)(FocusTrap.propTypes);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$jsx_runtime","~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$$mui$utils$node$index"]],"~:properties",["^5",["FocusTrap","getTabbable","documentOrder","tabIndex","children","__esModule","propTypes","disableRestoreFocus","value","onFocus","current","ref","disableEnforceFocus","__proto__","disableAutoFocus","open","default","node","isEnabled"]],"~:compiled-at",1712152511053,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$base$node$FocusTrap$FocusTrap.js\",\n\"lineCount\":130,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/base/node/FocusTrap/FocusTrap.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$base$node$FocusTrap$FocusTrap\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\n/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex */\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.FocusTrap = FocusTrap;\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar _propTypes = _interopRequireDefault(require(\\\"prop-types\\\"));\\nvar _utils = require(\\\"@mui/utils\\\");\\nvar _jsxRuntime = require(\\\"react/jsx-runtime\\\");\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\n// Inspired by https://github.com/focus-trap/tabbable\\nconst candidatesSelector = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\\\"false\\\"])'].join(',');\\nfunction getTabIndex(node) {\\n  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);\\n  if (!Number.isNaN(tabindexAttr)) {\\n    return tabindexAttr;\\n  }\\n\\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=661108&q=contenteditable%20tabindex&can=2\\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\\n  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\\n  //  yet they are still part of the regular tab order; in FF, they get a default\\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\\n  //  order, consider their tab index to be 0.\\n  if (node.contentEditable === 'true' || (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\\n    return 0;\\n  }\\n  return node.tabIndex;\\n}\\nfunction isNonTabbableRadio(node) {\\n  if (node.tagName !== 'INPUT' || node.type !== 'radio') {\\n    return false;\\n  }\\n  if (!node.name) {\\n    return false;\\n  }\\n  const getRadio = selector => node.ownerDocument.querySelector(`input[type=\\\"radio\\\"]${selector}`);\\n  let roving = getRadio(`[name=\\\"${node.name}\\\"]:checked`);\\n  if (!roving) {\\n    roving = getRadio(`[name=\\\"${node.name}\\\"]`);\\n  }\\n  return roving !== node;\\n}\\nfunction isNodeMatchingSelectorFocusable(node) {\\n  if (node.disabled || node.tagName === 'INPUT' && node.type === 'hidden' || isNonTabbableRadio(node)) {\\n    return false;\\n  }\\n  return true;\\n}\\nfunction defaultGetTabbable(root) {\\n  const regularTabNodes = [];\\n  const orderedTabNodes = [];\\n  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {\\n    const nodeTabIndex = getTabIndex(node);\\n    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {\\n      return;\\n    }\\n    if (nodeTabIndex === 0) {\\n      regularTabNodes.push(node);\\n    } else {\\n      orderedTabNodes.push({\\n        documentOrder: i,\\n        tabIndex: nodeTabIndex,\\n        node: node\\n      });\\n    }\\n  });\\n  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);\\n}\\nfunction defaultIsEnabled() {\\n  return true;\\n}\\n\\n/**\\n * Utility component that locks focus inside the component.\\n *\\n * Demos:\\n *\\n * - [Focus Trap](https://mui.com/base-ui/react-focus-trap/)\\n *\\n * API:\\n *\\n * - [FocusTrap API](https://mui.com/base-ui/react-focus-trap/components-api/#focus-trap)\\n */\\nfunction FocusTrap(props) {\\n  const {\\n    children,\\n    disableAutoFocus = false,\\n    disableEnforceFocus = false,\\n    disableRestoreFocus = false,\\n    getTabbable = defaultGetTabbable,\\n    isEnabled = defaultIsEnabled,\\n    open\\n  } = props;\\n  const ignoreNextEnforceFocus = React.useRef(false);\\n  const sentinelStart = React.useRef(null);\\n  const sentinelEnd = React.useRef(null);\\n  const nodeToRestore = React.useRef(null);\\n  const reactFocusEventTarget = React.useRef(null);\\n  // This variable is useful when disableAutoFocus is true.\\n  // It waits for the active element to move into the component to activate.\\n  const activated = React.useRef(false);\\n  const rootRef = React.useRef(null);\\n  // @ts-expect-error TODO upstream fix\\n  const handleRef = (0, _utils.unstable_useForkRef)(children.ref, rootRef);\\n  const lastKeydown = React.useRef(null);\\n  React.useEffect(() => {\\n    // We might render an empty child.\\n    if (!open || !rootRef.current) {\\n      return;\\n    }\\n    activated.current = !disableAutoFocus;\\n  }, [disableAutoFocus, open]);\\n  React.useEffect(() => {\\n    // We might render an empty child.\\n    if (!open || !rootRef.current) {\\n      return;\\n    }\\n    const doc = (0, _utils.unstable_ownerDocument)(rootRef.current);\\n    if (!rootRef.current.contains(doc.activeElement)) {\\n      if (!rootRef.current.hasAttribute('tabIndex')) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          console.error(['MUI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to \\\"-1\\\".'].join('\\\\n'));\\n        }\\n        rootRef.current.setAttribute('tabIndex', '-1');\\n      }\\n      if (activated.current) {\\n        rootRef.current.focus();\\n      }\\n    }\\n    return () => {\\n      // restoreLastFocus()\\n      if (!disableRestoreFocus) {\\n        // In IE11 it is possible for document.activeElement to be null resulting\\n        // in nodeToRestore.current being null.\\n        // Not all elements in IE11 have a focus method.\\n        // Once IE11 support is dropped the focus() call can be unconditional.\\n        if (nodeToRestore.current && nodeToRestore.current.focus) {\\n          ignoreNextEnforceFocus.current = true;\\n          nodeToRestore.current.focus();\\n        }\\n        nodeToRestore.current = null;\\n      }\\n    };\\n    // Missing `disableRestoreFocus` which is fine.\\n    // We don't support changing that prop on an open FocusTrap\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, [open]);\\n  React.useEffect(() => {\\n    // We might render an empty child.\\n    if (!open || !rootRef.current) {\\n      return;\\n    }\\n    const doc = (0, _utils.unstable_ownerDocument)(rootRef.current);\\n    const loopFocus = nativeEvent => {\\n      lastKeydown.current = nativeEvent;\\n      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== 'Tab') {\\n        return;\\n      }\\n\\n      // Make sure the next tab starts from the right place.\\n      // doc.activeElement refers to the origin.\\n      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {\\n        // We need to ignore the next contain as\\n        // it will try to move the focus back to the rootRef element.\\n        ignoreNextEnforceFocus.current = true;\\n        if (sentinelEnd.current) {\\n          sentinelEnd.current.focus();\\n        }\\n      }\\n    };\\n    const contain = () => {\\n      const rootElement = rootRef.current;\\n\\n      // Cleanup functions are executed lazily in React 17.\\n      // Contain can be called between the component being unmounted and its cleanup function being run.\\n      if (rootElement === null) {\\n        return;\\n      }\\n      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {\\n        ignoreNextEnforceFocus.current = false;\\n        return;\\n      }\\n\\n      // The focus is already inside\\n      if (rootElement.contains(doc.activeElement)) {\\n        return;\\n      }\\n\\n      // The disableEnforceFocus is set and the focus is outside of the focus trap (and sentinel nodes)\\n      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {\\n        return;\\n      }\\n\\n      // if the focus event is not coming from inside the children's react tree, reset the refs\\n      if (doc.activeElement !== reactFocusEventTarget.current) {\\n        reactFocusEventTarget.current = null;\\n      } else if (reactFocusEventTarget.current !== null) {\\n        return;\\n      }\\n      if (!activated.current) {\\n        return;\\n      }\\n      let tabbable = [];\\n      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {\\n        tabbable = getTabbable(rootRef.current);\\n      }\\n\\n      // one of the sentinel nodes was focused, so move the focus\\n      // to the first/last tabbable element inside the focus trap\\n      if (tabbable.length > 0) {\\n        var _lastKeydown$current, _lastKeydown$current2;\\n        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === 'Tab');\\n        const focusNext = tabbable[0];\\n        const focusPrevious = tabbable[tabbable.length - 1];\\n        if (typeof focusNext !== 'string' && typeof focusPrevious !== 'string') {\\n          if (isShiftTab) {\\n            focusPrevious.focus();\\n          } else {\\n            focusNext.focus();\\n          }\\n        }\\n        // no tabbable elements in the trap focus or the focus was outside of the focus trap\\n      } else {\\n        rootElement.focus();\\n      }\\n    };\\n    doc.addEventListener('focusin', contain);\\n    doc.addEventListener('keydown', loopFocus, true);\\n\\n    // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area.\\n    // for example https://bugzilla.mozilla.org/show_bug.cgi?id=559561.\\n    // Instead, we can look if the active element was restored on the BODY element.\\n    //\\n    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:\\n    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.\\n    const interval = setInterval(() => {\\n      if (doc.activeElement && doc.activeElement.tagName === 'BODY') {\\n        contain();\\n      }\\n    }, 50);\\n    return () => {\\n      clearInterval(interval);\\n      doc.removeEventListener('focusin', contain);\\n      doc.removeEventListener('keydown', loopFocus, true);\\n    };\\n  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);\\n  const onFocus = event => {\\n    if (nodeToRestore.current === null) {\\n      nodeToRestore.current = event.relatedTarget;\\n    }\\n    activated.current = true;\\n    reactFocusEventTarget.current = event.target;\\n    const childrenPropsHandler = children.props.onFocus;\\n    if (childrenPropsHandler) {\\n      childrenPropsHandler(event);\\n    }\\n  };\\n  const handleFocusSentinel = event => {\\n    if (nodeToRestore.current === null) {\\n      nodeToRestore.current = event.relatedTarget;\\n    }\\n    activated.current = true;\\n  };\\n  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {\\n    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(\\\"div\\\", {\\n      tabIndex: open ? 0 : -1,\\n      onFocus: handleFocusSentinel,\\n      ref: sentinelStart,\\n      \\\"data-testid\\\": \\\"sentinelStart\\\"\\n    }), /*#__PURE__*/React.cloneElement(children, {\\n      ref: handleRef,\\n      onFocus\\n    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(\\\"div\\\", {\\n      tabIndex: open ? 0 : -1,\\n      onFocus: handleFocusSentinel,\\n      ref: sentinelEnd,\\n      \\\"data-testid\\\": \\\"sentinelEnd\\\"\\n    })]\\n  });\\n}\\nprocess.env.NODE_ENV !== \\\"production\\\" ? FocusTrap.propTypes /* remove-proptypes */ = {\\n  // \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 Warning \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n  // \\u2502 These PropTypes are generated from the TypeScript type definitions. \\u2502\\n  // \\u2502 To update them, edit the TypeScript types and run `pnpm proptypes`. \\u2502\\n  // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n  /**\\n   * A single child content element.\\n   */\\n  children: _utils.elementAcceptingRef,\\n  /**\\n   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and\\n   * replace it to the last focused element when it closes.\\n   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.\\n   *\\n   * Generally this should never be set to `true` as it makes the focus trap less\\n   * accessible to assistive technologies, like screen readers.\\n   * @default false\\n   */\\n  disableAutoFocus: _propTypes.default.bool,\\n  /**\\n   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.\\n   *\\n   * Generally this should never be set to `true` as it makes the focus trap less\\n   * accessible to assistive technologies, like screen readers.\\n   * @default false\\n   */\\n  disableEnforceFocus: _propTypes.default.bool,\\n  /**\\n   * If `true`, the focus trap will not restore focus to previously focused element once\\n   * focus trap is hidden or unmounted.\\n   * @default false\\n   */\\n  disableRestoreFocus: _propTypes.default.bool,\\n  /**\\n   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.\\n   * For instance, you can provide the \\\"tabbable\\\" npm dependency.\\n   * @param {HTMLElement} root\\n   */\\n  getTabbable: _propTypes.default.func,\\n  /**\\n   * This prop extends the `open` prop.\\n   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.\\n   * This prop should be memoized.\\n   * It can be used to support multiple focus trap mounted at the same time.\\n   * @default function defaultIsEnabled(): boolean {\\n   *   return true;\\n   * }\\n   */\\n  isEnabled: _propTypes.default.func,\\n  /**\\n   * If `true`, focus is locked.\\n   */\\n  open: _propTypes.default.bool.isRequired\\n} : void 0;\\nif (process.env.NODE_ENV !== 'production') {\\n  // eslint-disable-next-line\\n  FocusTrap['propTypes' + ''] = (0, _utils.exactProp)(FocusTrap.propTypes);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"defaultGetTabbable\",\"root\",\"regularTabNodes\",\"orderedTabNodes\",\"Array\",\"from\",\"querySelectorAll\",\"candidatesSelector\",\"forEach\",\"node\",\"i\",\"tabindexAttr\",\"parseInt\",\"getAttribute\",\"Number\",\"isNaN\",\"contentEditable\",\"nodeName\",\"tabIndex\",\"tagName\",\"type\",\"name\",\"roving\",\"ownerDocument\",\"querySelector\",\"selector\",\"nodeTabIndex\",\"push\",\"documentOrder\",\"sort\",\"a\",\"b\",\"map\",\"concat\",\"defaultIsEnabled\",\"FocusTrap\",\"props\",\"children\",\"disableAutoFocus\",\"disableEnforceFocus\",\"disableRestoreFocus\",\"getTabbable\",\"isEnabled\",\"open\",\"ignoreNextEnforceFocus\",\"React\",\"useRef\",\"sentinelStart\",\"sentinelEnd\",\"nodeToRestore\",\"reactFocusEventTarget\",\"activated\",\"rootRef\",\"handleRef\",\"_utils\",\"unstable_useForkRef\",\"ref\",\"lastKeydown\",\"useEffect\",\"current\",\"doc\",\"unstable_ownerDocument\",\"contains\",\"activeElement\",\"hasAttribute\",\"console\",\"error\",\"setAttribute\",\"focus\",\"loopFocus\",\"nativeEvent\",\"key\",\"shiftKey\",\"contain\",\"rootElement\",\"hasFocus\",\"tabbable\",\"length\",\"_lastKeydown$current\",\"_lastKeydown$current2\",\"isShiftTab\",\"focusNext\",\"focusPrevious\",\"addEventListener\",\"interval\",\"setInterval\",\"clearInterval\",\"removeEventListener\",\"handleFocusSentinel\",\"event\",\"relatedTarget\",\"_jsxRuntime\",\"jsxs\",\"Fragment\",\"jsx\",\"onFocus\",\"cloneElement\",\"target\",\"childrenPropsHandler\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"value\",\"_interopRequireWildcard\",\"__esModule\",\"default\",\"has\",\"get\",\"n\",\"__proto__\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"call\",\"set\",\"_propTypes\",\"propTypes\",\"elementAcceptingRef\",\"bool\",\"func\",\"isRequired\",\"exactProp\"]\n}\n"]