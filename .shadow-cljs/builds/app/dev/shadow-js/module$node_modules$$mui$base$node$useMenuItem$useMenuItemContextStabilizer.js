["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/base/node/useMenuItem/useMenuItemContextStabilizer.js"],"~:js","shadow$provide.module$node_modules$$mui$base$node$useMenuItem$useMenuItemContextStabilizer = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  \"use client\";\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.useMenuItemContextStabilizer = function(id) {\n    const listContext = React.useContext(_useList.ListContext);\n    if (!listContext) {\n      throw Error(\"MenuItem: ListContext was not found.\");\n    }\n    const itemId = (0,_utils.unstable_useId)(id), {getItemState, dispatch} = listContext;\n    id = null != itemId ? getItemState(itemId) : {focusable:!0, highlighted:!1, selected:!1};\n    const {highlighted, selected, focusable} = id, localGetItemState = React.useCallback(itemValue => {\n      if (itemValue !== itemId) {\n        throw Error([\"Base UI MenuItem: Tried to access the state of another MenuItem.\", `itemValue: ${itemValue} | id: ${itemId}`, \"This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization.\"].join(\"/n\"));\n      }\n      return {highlighted, selected, focusable};\n    }, [highlighted, selected, focusable, itemId]);\n    return {contextValue:React.useMemo(() => ({dispatch, getItemState:localGetItemState}), [dispatch, localGetItemState]), id:itemId};\n  };\n  var React = function(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }(require(\"module$node_modules$react$index\")), _utils = require(\"module$node_modules$$mui$utils$node$index\"), _useList = require(\"module$node_modules$$mui$base$node$useList$index\");\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$base$node$useMenuItem$useMenuItemContextStabilizer\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useMenuItemContextStabilizer = useMenuItemContextStabilizer;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _utils = require(\"@mui/utils\");\nvar _useList = require(\"../useList\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n/**\n * Stabilizes the ListContext value for the MenuItem component, so it doesn't change when sibling items update.\n *\n * @param id The id of the MenuItem. If undefined, it will be generated with useId.\n * @returns The stable ListContext value and the id of the MenuItem.\n *\n * Demos:\n *\n * - [Menu](https://mui.com/base-ui/react-menu/#hooks)\n *\n * API:\n *\n * - [useMenuItemContextStabilizer API](https://mui.com/base-ui/react-menu/hooks-api/#use-menu-item-context-stabilizer)\n */\nfunction useMenuItemContextStabilizer(id) {\n  const listContext = React.useContext(_useList.ListContext);\n  if (!listContext) {\n    throw new Error('MenuItem: ListContext was not found.');\n  }\n  const itemId = (0, _utils.unstable_useId)(id);\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  let itemState;\n  if (itemId != null) {\n    itemState = getItemState(itemId);\n  } else {\n    itemState = {\n      focusable: true,\n      highlighted: false,\n      selected: false\n    };\n  }\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = itemState;\n\n  // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== itemId) {\n      throw new Error(['Base UI MenuItem: Tried to access the state of another MenuItem.', `itemValue: ${itemValue} | id: ${itemId}`, 'This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization.'].join('/n'));\n    }\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, itemId]);\n\n  // Create a local (per MenuItem) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes MenuItems re-render only when their state actually change, not when any MenuItem's state changes.\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue,\n    id: itemId\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$mui$base$node$useList$index","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$$mui$utils$node$index"]],"~:properties",["^5",["selected","dispatch","useMenuItemContextStabilizer","__esModule","highlighted","id","value","contextValue","getItemState","__proto__","default","focusable"]],"~:compiled-at",1712152511241,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$base$node$useMenuItem$useMenuItemContextStabilizer.js\",\n\"lineCount\":48,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/base/node/useMenuItem/useMenuItemContextStabilizer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$base$node$useMenuItem$useMenuItemContextStabilizer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.useMenuItemContextStabilizer = useMenuItemContextStabilizer;\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar _utils = require(\\\"@mui/utils\\\");\\nvar _useList = require(\\\"../useList\\\");\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\n/**\\n * Stabilizes the ListContext value for the MenuItem component, so it doesn't change when sibling items update.\\n *\\n * @param id The id of the MenuItem. If undefined, it will be generated with useId.\\n * @returns The stable ListContext value and the id of the MenuItem.\\n *\\n * Demos:\\n *\\n * - [Menu](https://mui.com/base-ui/react-menu/#hooks)\\n *\\n * API:\\n *\\n * - [useMenuItemContextStabilizer API](https://mui.com/base-ui/react-menu/hooks-api/#use-menu-item-context-stabilizer)\\n */\\nfunction useMenuItemContextStabilizer(id) {\\n  const listContext = React.useContext(_useList.ListContext);\\n  if (!listContext) {\\n    throw new Error('MenuItem: ListContext was not found.');\\n  }\\n  const itemId = (0, _utils.unstable_useId)(id);\\n  const {\\n    getItemState,\\n    dispatch\\n  } = listContext;\\n  let itemState;\\n  if (itemId != null) {\\n    itemState = getItemState(itemId);\\n  } else {\\n    itemState = {\\n      focusable: true,\\n      highlighted: false,\\n      selected: false\\n    };\\n  }\\n  const {\\n    highlighted,\\n    selected,\\n    focusable\\n  } = itemState;\\n\\n  // The local version of getItemState can be only called with the current Option's value.\\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\\n  const localGetItemState = React.useCallback(itemValue => {\\n    if (itemValue !== itemId) {\\n      throw new Error(['Base UI MenuItem: Tried to access the state of another MenuItem.', `itemValue: ${itemValue} | id: ${itemId}`, 'This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization.'].join('/n'));\\n    }\\n    return {\\n      highlighted,\\n      selected,\\n      focusable\\n    };\\n  }, [highlighted, selected, focusable, itemId]);\\n\\n  // Create a local (per MenuItem) instance of the ListContext that changes only when\\n  // the getItemState's return value changes.\\n  // This makes MenuItems re-render only when their state actually change, not when any MenuItem's state changes.\\n  const localContextValue = React.useMemo(() => ({\\n    dispatch,\\n    getItemState: localGetItemState\\n  }), [dispatch, localGetItemState]);\\n  return {\\n    contextValue: localContextValue,\\n    id: itemId\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"Object\",\"defineProperty\",\"value\",\"useMenuItemContextStabilizer\",\"id\",\"listContext\",\"React\",\"useContext\",\"_useList\",\"ListContext\",\"Error\",\"itemId\",\"_utils\",\"unstable_useId\",\"getItemState\",\"dispatch\",\"itemState\",\"focusable\",\"highlighted\",\"selected\",\"localGetItemState\",\"useCallback\",\"itemValue\",\"join\",\"contextValue\",\"useMemo\",\"localContextValue\",\"_interopRequireWildcard\",\"__esModule\",\"default\",\"has\",\"get\",\"n\",\"__proto__\",\"a\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"call\",\"i\",\"set\"]\n}\n"]