["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js"],"~:js","shadow$provide.module$node_modules$$floating_ui$dom$dist$floating_ui_dom_umd = function(global, require, module, exports) {\n  (function(global, factory) {\n    \"object\" === typeof exports && \"undefined\" !== typeof module ? factory(exports, require(\"module$node_modules$$floating_ui$core$dist$floating_ui_core_umd\")) : \"function\" === typeof define && define.amd ? define([\"exports\", \"@floating-ui/core\"], factory) : (global = \"undefined\" !== typeof globalThis ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));\n  })(this, function(exports, core) {\n    function getNodeName(node) {\n      return isNode(node) ? (node.nodeName || \"\").toLowerCase() : \"#document\";\n    }\n    function getWindow(node) {\n      var _node$ownerDocument;\n      return (null == node || null == (_node$ownerDocument = node.ownerDocument) ? void 0 : _node$ownerDocument.defaultView) || window;\n    }\n    function getDocumentElement(node) {\n      var _ref;\n      return null == (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) ? void 0 : _ref.documentElement;\n    }\n    function isNode(value) {\n      return value instanceof Node || value instanceof getWindow(value).Node;\n    }\n    function isElement(value) {\n      return value instanceof Element || value instanceof getWindow(value).Element;\n    }\n    function isHTMLElement(value) {\n      return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n    }\n    function isShadowRoot(value) {\n      return \"undefined\" === typeof ShadowRoot ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n    }\n    function isOverflowElement(element) {\n      const {overflow, overflowX, overflowY, display} = getComputedStyle(element);\n      return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n    }\n    function isContainingBlock(element) {\n      const webkit = isWebKit(), css = getComputedStyle(element);\n      return \"none\" !== css.transform || \"none\" !== css.perspective || (css.containerType ? \"normal\" !== css.containerType : !1) || !webkit && (css.backdropFilter ? \"none\" !== css.backdropFilter : !1) || !webkit && (css.filter ? \"none\" !== css.filter : !1) || [\"transform\", \"perspective\", \"filter\"].some(value => (css.willChange || \"\").includes(value)) || [\"paint\", \"layout\", \"strict\", \"content\"].some(value => (css.contain || \"\").includes(value));\n    }\n    function isWebKit() {\n      return \"undefined\" !== typeof CSS && CSS.supports ? CSS.supports(\"-webkit-backdrop-filter\", \"none\") : !1;\n    }\n    function isLastTraversableNode(node) {\n      return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n    }\n    function getComputedStyle(element) {\n      return getWindow(element).getComputedStyle(element);\n    }\n    function getNodeScroll(element) {\n      return isElement(element) ? {scrollLeft:element.scrollLeft, scrollTop:element.scrollTop} : {scrollLeft:element.pageXOffset, scrollTop:element.pageYOffset};\n    }\n    function getParentNode(node) {\n      if (\"html\" === getNodeName(node)) {\n        return node;\n      }\n      node = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);\n      return isShadowRoot(node) ? node.host : node;\n    }\n    function getNearestOverflowAncestor(node) {\n      const parentNode = getParentNode(node);\n      return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);\n    }\n    function getOverflowAncestors(node, list, traverseIframes) {\n      var _node$ownerDocument2;\n      void 0 === list && (list = []);\n      void 0 === traverseIframes && (traverseIframes = !0);\n      const scrollableAncestor = getNearestOverflowAncestor(node);\n      node = scrollableAncestor === (null == (_node$ownerDocument2 = node.ownerDocument) ? void 0 : _node$ownerDocument2.body);\n      _node$ownerDocument2 = getWindow(scrollableAncestor);\n      return node ? list.concat(_node$ownerDocument2, _node$ownerDocument2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], _node$ownerDocument2.frameElement && traverseIframes ? getOverflowAncestors(_node$ownerDocument2.frameElement) : []) : list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n    }\n    function getCssDimensions(element) {\n      var css = getComputedStyle(element);\n      let width = parseFloat(css.width) || 0;\n      css = parseFloat(css.height) || 0;\n      var hasOffset = isHTMLElement(element);\n      const offsetWidth = hasOffset ? element.offsetWidth : width;\n      element = hasOffset ? element.offsetHeight : css;\n      if (hasOffset = round(width) !== offsetWidth || round(css) !== element) {\n        width = offsetWidth, css = element;\n      }\n      return {width, height:css, $:hasOffset};\n    }\n    function unwrapElement(element) {\n      return isElement(element) ? element : element.contextElement;\n    }\n    function getScale(element) {\n      var domElement = unwrapElement(element);\n      if (!isHTMLElement(domElement)) {\n        return {x:1, y:1};\n      }\n      element = domElement.getBoundingClientRect();\n      const {width, height, $} = getCssDimensions(domElement);\n      domElement = ($ ? round(element.width) : element.width) / width;\n      element = ($ ? round(element.height) : element.height) / height;\n      domElement && Number.isFinite(domElement) || (domElement = 1);\n      element && Number.isFinite(element) || (element = 1);\n      return {x:domElement, y:element};\n    }\n    function getVisualOffsets(element) {\n      element = getWindow(element);\n      return isWebKit() && element.visualViewport ? {x:element.visualViewport.offsetLeft, y:element.visualViewport.offsetTop} : noOffsets;\n    }\n    function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n      void 0 === includeScale && (includeScale = !1);\n      void 0 === isFixedStrategy && (isFixedStrategy = !1);\n      var clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element), scale = {x:1, y:1};\n      includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));\n      element = isFixedStrategy;\n      void 0 === element && (element = !1);\n      element = !offsetParent || element && offsetParent !== getWindow(domElement) ? !1 : element;\n      includeScale = element ? getVisualOffsets(domElement) : {x:0, y:0};\n      element = (clientRect.left + includeScale.x) / scale.x;\n      includeScale = (clientRect.top + includeScale.y) / scale.y;\n      isFixedStrategy = clientRect.width / scale.x;\n      clientRect = clientRect.height / scale.y;\n      if (domElement) {\n        scale = getWindow(domElement);\n        domElement = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n        var currentWin = scale;\n        for (scale = currentWin.frameElement; scale && offsetParent && domElement !== currentWin;) {\n          currentWin = getScale(scale);\n          var iframeRect = scale.getBoundingClientRect();\n          const css = getComputedStyle(scale), left = iframeRect.left + (scale.clientLeft + parseFloat(css.paddingLeft)) * currentWin.x;\n          iframeRect = iframeRect.top + (scale.clientTop + parseFloat(css.paddingTop)) * currentWin.y;\n          element *= currentWin.x;\n          includeScale *= currentWin.y;\n          isFixedStrategy *= currentWin.x;\n          clientRect *= currentWin.y;\n          element += left;\n          includeScale += iframeRect;\n          currentWin = getWindow(scale);\n          scale = currentWin.frameElement;\n        }\n      }\n      return core.rectToClientRect({width:isFixedStrategy, height:clientRect, x:element, y:includeScale});\n    }\n    function isTopLayer(floating) {\n      return topLayerSelectors.some(selector => {\n        try {\n          return floating.matches(selector);\n        } catch (e) {\n          return !1;\n        }\n      });\n    }\n    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n      if (\"viewport\" === clippingAncestor) {\n        clippingAncestor = getWindow(element);\n        var html = getDocumentElement(element);\n        clippingAncestor = clippingAncestor.visualViewport;\n        element = html.clientWidth;\n        html = html.clientHeight;\n        var x = 0, y = 0;\n        if (clippingAncestor) {\n          element = clippingAncestor.width;\n          html = clippingAncestor.height;\n          var visualViewportBased = isWebKit();\n          if (!visualViewportBased || visualViewportBased && \"fixed\" === strategy) {\n            x = clippingAncestor.offsetLeft, y = clippingAncestor.offsetTop;\n          }\n        }\n        strategy = {width:element, height:html, x, y};\n      } else {\n        \"document\" === clippingAncestor ? (visualViewportBased = getDocumentElement(element), strategy = getDocumentElement(visualViewportBased), x = getNodeScroll(visualViewportBased), clippingAncestor = visualViewportBased.ownerDocument.body, element = max(strategy.scrollWidth, strategy.clientWidth, clippingAncestor.scrollWidth, clippingAncestor.clientWidth), html = max(strategy.scrollHeight, strategy.clientHeight, clippingAncestor.scrollHeight, clippingAncestor.clientHeight), y = -x.scrollLeft, \n        visualViewportBased = getBoundingClientRect(getDocumentElement(visualViewportBased)).left + getNodeScroll(visualViewportBased).scrollLeft, y += visualViewportBased, x = -x.scrollTop, \"rtl\" === getComputedStyle(clippingAncestor).direction && (y += max(strategy.clientWidth, clippingAncestor.clientWidth) - element), strategy = {width:element, height:html, x:y, y:x}) : isElement(clippingAncestor) ? (element = getBoundingClientRect(clippingAncestor, !0, \"fixed\" === strategy), strategy = element.top + \n        clippingAncestor.clientTop, element = element.left + clippingAncestor.clientLeft, html = isHTMLElement(clippingAncestor) ? getScale(clippingAncestor) : {x:1, y:1}, strategy = {width:clippingAncestor.clientWidth * html.x, height:clippingAncestor.clientHeight * html.y, x:element * html.x, y:strategy * html.y}) : (strategy = getVisualOffsets(element), strategy = {...clippingAncestor, x:clippingAncestor.x - strategy.x, y:clippingAncestor.y - strategy.y});\n      }\n      return core.rectToClientRect(strategy);\n    }\n    function hasFixedPositionAncestor(element, stopNode) {\n      element = getParentNode(element);\n      return element === stopNode || !isElement(element) || isLastTraversableNode(element) ? !1 : \"fixed\" === getComputedStyle(element).position || hasFixedPositionAncestor(element, stopNode);\n    }\n    function getClippingElementAncestors(element, cache) {\n      var cachedResult = cache.get(element);\n      if (cachedResult) {\n        return cachedResult;\n      }\n      cachedResult = getOverflowAncestors(element, [], !1).filter(el => isElement(el) && \"body\" !== getNodeName(el));\n      let currentContainingBlockComputedStyle = null;\n      const elementIsFixed = \"fixed\" === getComputedStyle(element).position;\n      let currentNode = elementIsFixed ? getParentNode(element) : element;\n      for (; isElement(currentNode) && !isLastTraversableNode(currentNode);) {\n        const computedStyle = getComputedStyle(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);\n        currentNodeIsContaining || \"fixed\" !== computedStyle.position || (currentContainingBlockComputedStyle = null);\n        (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && \"static\" === computedStyle.position && currentContainingBlockComputedStyle && [\"absolute\", \"fixed\"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? cachedResult = cachedResult.filter(ancestor => ancestor !== currentNode) : currentContainingBlockComputedStyle = \n        computedStyle;\n        currentNode = getParentNode(currentNode);\n      }\n      cache.set(element, cachedResult);\n      return cachedResult;\n    }\n    function getTrueOffsetParent(element, polyfill) {\n      return isHTMLElement(element) && \"fixed\" !== getComputedStyle(element).position ? polyfill ? polyfill(element) : element.offsetParent : null;\n    }\n    function getOffsetParent(element, polyfill) {\n      const window = getWindow(element);\n      if (!isHTMLElement(element) || isTopLayer(element)) {\n        return window;\n      }\n      let offsetParent = getTrueOffsetParent(element, polyfill);\n      for (; offsetParent && [\"table\", \"td\", \"th\"].includes(getNodeName(offsetParent)) && \"static\" === getComputedStyle(offsetParent).position;) {\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n      }\n      if (offsetParent && (\"html\" === getNodeName(offsetParent) || \"body\" === getNodeName(offsetParent) && \"static\" === getComputedStyle(offsetParent).position && !isContainingBlock(offsetParent))) {\n        return window;\n      }\n      if (!(polyfill = offsetParent)) {\n        a: {\n          for (element = getParentNode(element); isHTMLElement(element) && !isLastTraversableNode(element);) {\n            if (isContainingBlock(element)) {\n              polyfill = element;\n              break a;\n            }\n            element = getParentNode(element);\n          }\n          polyfill = null;\n        }\n      }\n      return polyfill || window;\n    }\n    function observeMove(element, onMove) {\n      function cleanup() {\n        var _io;\n        clearTimeout(timeoutId);\n        null == (_io = io) || _io.disconnect();\n        io = null;\n      }\n      function refresh(skip, threshold) {\n        function handleObserve(entries) {\n          entries = entries[0].intersectionRatio;\n          if (entries !== threshold) {\n            if (!isFirstUpdate) {\n              return refresh();\n            }\n            entries ? refresh(!1, entries) : timeoutId = setTimeout(() => {\n              refresh(!1, 1e-7);\n            }, 100);\n          }\n          isFirstUpdate = !1;\n        }\n        void 0 === skip && (skip = !1);\n        void 0 === threshold && (threshold = 1);\n        cleanup();\n        const {left, top, width, height} = element.getBoundingClientRect();\n        skip || onMove();\n        if (width && height) {\n          skip = floor(top);\n          var insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top + height)), insetLeft = floor(left);\n          skip = {rootMargin:-skip + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\", threshold:max(0, min(1, threshold)) || 1};\n          var isFirstUpdate = !0;\n          try {\n            io = new IntersectionObserver(handleObserve, {...skip, root:root.ownerDocument});\n          } catch (e) {\n            io = new IntersectionObserver(handleObserve, skip);\n          }\n          io.observe(element);\n        }\n      }\n      let io = null, timeoutId;\n      const root = getDocumentElement(element);\n      refresh(!0);\n      return cleanup;\n    }\n    const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, noOffsets = {x:0, y:0}, topLayerSelectors = [\":popover-open\", \":modal\"], platform = {convertOffsetParentRelativeRectToViewportRelativeRect:function(_ref) {\n      let {elements, rect, offsetParent, strategy} = _ref;\n      _ref = \"fixed\" === strategy;\n      const documentElement = getDocumentElement(offsetParent);\n      var topLayer = elements ? isTopLayer(elements.floating) : !1;\n      if (offsetParent === documentElement || topLayer && _ref) {\n        return rect;\n      }\n      topLayer = {scrollLeft:0, scrollTop:0};\n      let scale = {x:1, y:1};\n      var JSCompiler_object_inline_x_1058 = 0, JSCompiler_object_inline_y_1059 = 0;\n      const isOffsetParentAnElement = isHTMLElement(offsetParent);\n      if (isOffsetParentAnElement || !isOffsetParentAnElement && !_ref) {\n        if (\"body\" !== getNodeName(offsetParent) || isOverflowElement(documentElement)) {\n          topLayer = getNodeScroll(offsetParent);\n        }\n        isHTMLElement(offsetParent) && (_ref = getBoundingClientRect(offsetParent), scale = getScale(offsetParent), JSCompiler_object_inline_x_1058 = _ref.x + offsetParent.clientLeft, JSCompiler_object_inline_y_1059 = _ref.y + offsetParent.clientTop);\n      }\n      return {width:rect.width * scale.x, height:rect.height * scale.y, x:rect.x * scale.x - topLayer.scrollLeft * scale.x + JSCompiler_object_inline_x_1058, y:rect.y * scale.y - topLayer.scrollTop * scale.y + JSCompiler_object_inline_y_1059};\n    }, getDocumentElement, getClippingRect:function(_ref) {\n      let {element, boundary, rootBoundary, strategy} = _ref;\n      _ref = [...(\"clippingAncestors\" === boundary ? getClippingElementAncestors(element, this._c) : [].concat(boundary)), rootBoundary];\n      _ref = _ref.reduce((accRect, clippingAncestor) => {\n        clippingAncestor = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = max(clippingAncestor.top, accRect.top);\n        accRect.right = min(clippingAncestor.right, accRect.right);\n        accRect.bottom = min(clippingAncestor.bottom, accRect.bottom);\n        accRect.left = max(clippingAncestor.left, accRect.left);\n        return accRect;\n      }, getClientRectFromClippingAncestor(element, _ref[0], strategy));\n      return {width:_ref.right - _ref.left, height:_ref.bottom - _ref.top, x:_ref.left, y:_ref.top};\n    }, getOffsetParent, getElementRects:async function(data) {\n      const getDimensionsFn = this.getDimensions;\n      var element = data.reference, offsetParent = await (this.getOffsetParent || getOffsetParent)(data.floating), strategy = data.strategy, isOffsetParentAnElement = isHTMLElement(offsetParent);\n      const documentElement = getDocumentElement(offsetParent);\n      strategy = \"fixed\" === strategy;\n      element = getBoundingClientRect(element, !0, strategy, offsetParent);\n      let scroll = {scrollLeft:0, scrollTop:0};\n      var JSCompiler_object_inline_x_1187 = 0, JSCompiler_object_inline_y_1188 = 0;\n      if (isOffsetParentAnElement || !isOffsetParentAnElement && !strategy) {\n        if (\"body\" !== getNodeName(offsetParent) || isOverflowElement(documentElement)) {\n          scroll = getNodeScroll(offsetParent);\n        }\n        isOffsetParentAnElement ? (isOffsetParentAnElement = getBoundingClientRect(offsetParent, !0, strategy, offsetParent), JSCompiler_object_inline_x_1187 = isOffsetParentAnElement.x + offsetParent.clientLeft, JSCompiler_object_inline_y_1188 = isOffsetParentAnElement.y + offsetParent.clientTop) : documentElement && (JSCompiler_object_inline_x_1187 = getBoundingClientRect(getDocumentElement(documentElement)).left + getNodeScroll(documentElement).scrollLeft);\n      }\n      return {reference:{x:element.left + scroll.scrollLeft - JSCompiler_object_inline_x_1187, y:element.top + scroll.scrollTop - JSCompiler_object_inline_y_1188, width:element.width, height:element.height}, floating:{x:0, y:0, ...(await getDimensionsFn(data.floating))}};\n    }, getClientRects:function(element) {\n      return Array.from(element.getClientRects());\n    }, getDimensions:function(element) {\n      const {width, height} = getCssDimensions(element);\n      return {width, height};\n    }, getScale, isElement, isRTL:function(element) {\n      return \"rtl\" === getComputedStyle(element).direction;\n    }}, autoPlacement = core.autoPlacement, shift = core.shift, flip = core.flip, size = core.size, hide = core.hide, arrow = core.arrow, inline = core.inline, limitShift = core.limitShift;\n    Object.defineProperty(exports, \"detectOverflow\", {enumerable:!0, get:function() {\n      return core.detectOverflow;\n    }});\n    Object.defineProperty(exports, \"offset\", {enumerable:!0, get:function() {\n      return core.offset;\n    }});\n    exports.arrow = arrow;\n    exports.autoPlacement = autoPlacement;\n    exports.autoUpdate = function(reference, floating, update, options) {\n      function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        !prevRefRect || nextRefRect.x === prevRefRect.x && nextRefRect.y === prevRefRect.y && nextRefRect.width === prevRefRect.width && nextRefRect.height === prevRefRect.height || update();\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n      }\n      void 0 === options && (options = {});\n      const {ancestorScroll = !0, ancestorResize = !0, elementResize = \"function\" === typeof ResizeObserver, layoutShift = \"function\" === typeof IntersectionObserver, animationFrame = !1} = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n      ancestors.forEach(ancestor => {\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {passive:!0});\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n      });\n      const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n      let reobserveFrame = -1, resizeObserver = null;\n      elementResize && (resizeObserver = new ResizeObserver(_ref => {\n        [_ref] = _ref;\n        _ref && _ref.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          null == (_resizeObserver = resizeObserver) || _resizeObserver.observe(floating);\n        }));\n        update();\n      }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));\n      let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n      animationFrame && frameLoop();\n      update();\n      return () => {\n        var _resizeObserver2;\n        ancestors.forEach(ancestor => {\n          ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n          ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        null == cleanupIo || cleanupIo();\n        null == (_resizeObserver2 = resizeObserver) || _resizeObserver2.disconnect();\n        resizeObserver = null;\n        animationFrame && cancelAnimationFrame(frameId);\n      };\n    };\n    exports.computePosition = (reference, floating, options) => {\n      const cache = new Map();\n      options = {platform, ...options};\n      return core.computePosition(reference, floating, {...options, platform:{...options.platform, _c:cache}});\n    };\n    exports.flip = flip;\n    exports.getOverflowAncestors = getOverflowAncestors;\n    exports.hide = hide;\n    exports.inline = inline;\n    exports.limitShift = limitShift;\n    exports.platform = platform;\n    exports.shift = shift;\n    exports.size = size;\n  });\n};\n","~:source","shadow$provide[\"module$node_modules$$floating_ui$dom$dist$floating_ui_dom_umd\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/core')) :\n  typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/core'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));\n})(this, (function (exports, core) { 'use strict';\n\n  /**\n   * Custom positioning reference element.\n   * @see https://floating-ui.com/docs/virtual-elements\n   */\n\n  const min = Math.min;\n  const max = Math.max;\n  const round = Math.round;\n  const floor = Math.floor;\n  const createCoords = v => ({\n    x: v,\n    y: v\n  });\n\n  function getNodeName(node) {\n    if (isNode(node)) {\n      return (node.nodeName || '').toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return '#document';\n  }\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n  function getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n  }\n  function isNode(value) {\n    return value instanceof Node || value instanceof getWindow(value).Node;\n  }\n  function isElement(value) {\n    return value instanceof Element || value instanceof getWindow(value).Element;\n  }\n  function isHTMLElement(value) {\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n  }\n  function isShadowRoot(value) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n  }\n  function isOverflowElement(element) {\n    const {\n      overflow,\n      overflowX,\n      overflowY,\n      display\n    } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].includes(getNodeName(element));\n  }\n  function isContainingBlock(element) {\n    const webkit = isWebKit();\n    const css = getComputedStyle(element);\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n  }\n  function getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      if (isContainingBlock(currentNode)) {\n        return currentNode;\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    return null;\n  }\n  function isWebKit() {\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\n    return CSS.supports('-webkit-backdrop-filter', 'none');\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function getNodeScroll(element) {\n    if (isElement(element)) {\n      return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      };\n    }\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n  function getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n      return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n      return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n  }\n  function getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n      list = [];\n    }\n    if (traverseIframes === void 0) {\n      traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n  }\n\n  function getCssDimensions(element) {\n    const css = getComputedStyle(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = isHTMLElement(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n    if (shouldFallback) {\n      width = offsetWidth;\n      height = offsetHeight;\n    }\n    return {\n      width,\n      height,\n      $: shouldFallback\n    };\n  }\n\n  function unwrapElement(element) {\n    return !isElement(element) ? element.contextElement : element;\n  }\n\n  function getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!isHTMLElement(domElement)) {\n      return createCoords(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const {\n      width,\n      height,\n      $\n    } = getCssDimensions(domElement);\n    let x = ($ ? round(rect.width) : rect.width) / width;\n    let y = ($ ? round(rect.height) : rect.height) / height;\n\n    // 0, NaN, or Infinity should always fallback to 1.\n\n    if (!x || !Number.isFinite(x)) {\n      x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n      y = 1;\n    }\n    return {\n      x,\n      y\n    };\n  }\n\n  const noOffsets = /*#__PURE__*/createCoords(0);\n  function getVisualOffsets(element) {\n    const win = getWindow(element);\n    if (!isWebKit() || !win.visualViewport) {\n      return noOffsets;\n    }\n    return {\n      x: win.visualViewport.offsetLeft,\n      y: win.visualViewport.offsetTop\n    };\n  }\n  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n      return false;\n    }\n    return isFixed;\n  }\n\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = createCoords(1);\n    if (includeScale) {\n      if (offsetParent) {\n        if (isElement(offsetParent)) {\n          scale = getScale(offsetParent);\n        }\n      } else {\n        scale = getScale(element);\n      }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n      const win = getWindow(domElement);\n      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n      let currentWin = win;\n      let currentIFrame = currentWin.frameElement;\n      while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n        const iframeScale = getScale(currentIFrame);\n        const iframeRect = currentIFrame.getBoundingClientRect();\n        const css = getComputedStyle(currentIFrame);\n        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n        x *= iframeScale.x;\n        y *= iframeScale.y;\n        width *= iframeScale.x;\n        height *= iframeScale.y;\n        x += left;\n        y += top;\n        currentWin = getWindow(currentIFrame);\n        currentIFrame = currentWin.frameElement;\n      }\n    }\n    return core.rectToClientRect({\n      width,\n      height,\n      x,\n      y\n    });\n  }\n\n  const topLayerSelectors = [':popover-open', ':modal'];\n  function isTopLayer(floating) {\n    return topLayerSelectors.some(selector => {\n      try {\n        return floating.matches(selector);\n      } catch (e) {\n        return false;\n      }\n    });\n  }\n\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let {\n      elements,\n      rect,\n      offsetParent,\n      strategy\n    } = _ref;\n    const isFixed = strategy === 'fixed';\n    const documentElement = getDocumentElement(offsetParent);\n    const topLayer = elements ? isTopLayer(elements.floating) : false;\n    if (offsetParent === documentElement || topLayer && isFixed) {\n      return rect;\n    }\n    let scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    let scale = createCoords(1);\n    const offsets = createCoords(0);\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        const offsetRect = getBoundingClientRect(offsetParent);\n        scale = getScale(offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      }\n    }\n    return {\n      width: rect.width * scale.x,\n      height: rect.height * scale.y,\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n  }\n\n  function getClientRects(element) {\n    return Array.from(element.getClientRects());\n  }\n\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n  }\n\n  // Gets the entire size of the scrollable document area, even extending outside\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n  function getDocumentRect(element) {\n    const html = getDocumentElement(element);\n    const scroll = getNodeScroll(element);\n    const body = element.ownerDocument.body;\n    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if (getComputedStyle(body).direction === 'rtl') {\n      x += max(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n\n  function getViewportRect(element, strategy) {\n    const win = getWindow(element);\n    const html = getDocumentElement(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      const visualViewportBased = isWebKit();\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n\n  // Returns the inner client rect, subtracting scrollbars if present.\n  function getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === 'viewport') {\n      rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === 'document') {\n      rect = getDocumentRect(getDocumentElement(element));\n    } else if (isElement(clippingAncestor)) {\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n      const visualOffsets = getVisualOffsets(element);\n      rect = {\n        ...clippingAncestor,\n        x: clippingAncestor.x - visualOffsets.x,\n        y: clippingAncestor.y - visualOffsets.y\n      };\n    }\n    return core.rectToClientRect(rect);\n  }\n  function hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = getParentNode(element);\n    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n      return false;\n    }\n    return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n  }\n\n  // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n  // clipping (or hiding) child elements. This returns all clipping ancestors\n  // of the given element up the tree.\n  function getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = getComputedStyle(element).position === 'fixed';\n    let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      const computedStyle = getComputedStyle(currentNode);\n      const currentNodeIsContaining = isContainingBlock(currentNode);\n      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n        currentContainingBlockComputedStyle = null;\n      }\n      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n  }\n\n  // Gets the maximum area that the element is visible in due to any number of\n  // clipping ancestors.\n  function getClippingRect(_ref) {\n    let {\n      element,\n      boundary,\n      rootBoundary,\n      strategy\n    } = _ref;\n    const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n      width: clippingRect.right - clippingRect.left,\n      height: clippingRect.bottom - clippingRect.top,\n      x: clippingRect.left,\n      y: clippingRect.top\n    };\n  }\n\n  function getDimensions(element) {\n    const {\n      width,\n      height\n    } = getCssDimensions(element);\n    return {\n      width,\n      height\n    };\n  }\n\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    const isFixed = strategy === 'fixed';\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    const offsets = createCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isOffsetParentAnElement) {\n        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    const x = rect.left + scroll.scrollLeft - offsets.x;\n    const y = rect.top + scroll.scrollTop - offsets.y;\n    return {\n      x,\n      y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  function getTrueOffsetParent(element, polyfill) {\n    if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n    if (polyfill) {\n      return polyfill(element);\n    }\n    return element.offsetParent;\n  }\n\n  // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n  function getOffsetParent(element, polyfill) {\n    const window = getWindow(element);\n    if (!isHTMLElement(element) || isTopLayer(element)) {\n      return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n\n  const getElementRects = async function (data) {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(data.floating))\n      }\n    };\n  };\n\n  function isRTL(element) {\n    return getComputedStyle(element).direction === 'rtl';\n  }\n\n  const platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement,\n    isRTL\n  };\n\n  // https://samthor.au/2021/observing-dom/\n  function observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = getDocumentElement(element);\n    function cleanup() {\n      var _io;\n      clearTimeout(timeoutId);\n      (_io = io) == null || _io.disconnect();\n      io = null;\n    }\n    function refresh(skip, threshold) {\n      if (skip === void 0) {\n        skip = false;\n      }\n      if (threshold === void 0) {\n        threshold = 1;\n      }\n      cleanup();\n      const {\n        left,\n        top,\n        width,\n        height\n      } = element.getBoundingClientRect();\n      if (!skip) {\n        onMove();\n      }\n      if (!width || !height) {\n        return;\n      }\n      const insetTop = floor(top);\n      const insetRight = floor(root.clientWidth - (left + width));\n      const insetBottom = floor(root.clientHeight - (top + height));\n      const insetLeft = floor(left);\n      const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n      const options = {\n        rootMargin,\n        threshold: max(0, min(1, threshold)) || 1\n      };\n      let isFirstUpdate = true;\n      function handleObserve(entries) {\n        const ratio = entries[0].intersectionRatio;\n        if (ratio !== threshold) {\n          if (!isFirstUpdate) {\n            return refresh();\n          }\n          if (!ratio) {\n            timeoutId = setTimeout(() => {\n              refresh(false, 1e-7);\n            }, 100);\n          } else {\n            refresh(false, ratio);\n          }\n        }\n        isFirstUpdate = false;\n      }\n\n      // Older browsers don't support a `document` as the root and will throw an\n      // error.\n      try {\n        io = new IntersectionObserver(handleObserve, {\n          ...options,\n          // Handle <iframe>s\n          root: root.ownerDocument\n        });\n      } catch (e) {\n        io = new IntersectionObserver(handleObserve, options);\n      }\n      io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n  }\n\n  /**\n   * Automatically updates the position of the floating element when necessary.\n   * Should only be called when the floating element is mounted on the DOM or\n   * visible on the screen.\n   * @returns cleanup function that should be invoked when the floating element is\n   * removed from the DOM or hidden from the screen.\n   * @see https://floating-ui.com/docs/autoUpdate\n   */\n  function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      ancestorScroll = true,\n      ancestorResize = true,\n      elementResize = typeof ResizeObserver === 'function',\n      layoutShift = typeof IntersectionObserver === 'function',\n      animationFrame = false\n    } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n      ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n      resizeObserver = new ResizeObserver(_ref => {\n        let [firstEntry] = _ref;\n        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n          // Prevent update loops when using the `size` middleware.\n          // https://github.com/floating-ui/floating-ui/issues/1740\n          resizeObserver.unobserve(floating);\n          cancelAnimationFrame(reobserveFrame);\n          reobserveFrame = requestAnimationFrame(() => {\n            var _resizeObserver;\n            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n          });\n        }\n        update();\n      });\n      if (referenceEl && !animationFrame) {\n        resizeObserver.observe(referenceEl);\n      }\n      resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n      frameLoop();\n    }\n    function frameLoop() {\n      const nextRefRect = getBoundingClientRect(reference);\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n        update();\n      }\n      prevRefRect = nextRefRect;\n      frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return () => {\n      var _resizeObserver2;\n      ancestors.forEach(ancestor => {\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\n        ancestorResize && ancestor.removeEventListener('resize', update);\n      });\n      cleanupIo == null || cleanupIo();\n      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n      resizeObserver = null;\n      if (animationFrame) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }\n\n  /**\n   * Optimizes the visibility of the floating element by choosing the placement\n   * that has the most space available automatically, without needing to specify a\n   * preferred placement. Alternative to `flip`.\n   * @see https://floating-ui.com/docs/autoPlacement\n   */\n  const autoPlacement = core.autoPlacement;\n\n  /**\n   * Optimizes the visibility of the floating element by shifting it in order to\n   * keep it in view when it will overflow the clipping boundary.\n   * @see https://floating-ui.com/docs/shift\n   */\n  const shift = core.shift;\n\n  /**\n   * Optimizes the visibility of the floating element by flipping the `placement`\n   * in order to keep it in view when the preferred placement(s) will overflow the\n   * clipping boundary. Alternative to `autoPlacement`.\n   * @see https://floating-ui.com/docs/flip\n   */\n  const flip = core.flip;\n\n  /**\n   * Provides data that allows you to change the size of the floating element \n   * for instance, prevent it from overflowing the clipping boundary or match the\n   * width of the reference element.\n   * @see https://floating-ui.com/docs/size\n   */\n  const size = core.size;\n\n  /**\n   * Provides data to hide the floating element in applicable situations, such as\n   * when it is not in the same clipping context as the reference element.\n   * @see https://floating-ui.com/docs/hide\n   */\n  const hide = core.hide;\n\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  const arrow = core.arrow;\n\n  /**\n   * Provides improved positioning for inline reference elements that can span\n   * over multiple lines, such as hyperlinks or range selections.\n   * @see https://floating-ui.com/docs/inline\n   */\n  const inline = core.inline;\n\n  /**\n   * Built-in `limiter` that will stop `shift()` at a certain point.\n   */\n  const limitShift = core.limitShift;\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a given reference element.\n   */\n  const computePosition = (reference, floating, options) => {\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n      platform,\n      ...options\n    };\n    const platformWithCache = {\n      ...mergedOptions.platform,\n      _c: cache\n    };\n    return core.computePosition(reference, floating, {\n      ...mergedOptions,\n      platform: platformWithCache\n    });\n  };\n\n  Object.defineProperty(exports, \"detectOverflow\", {\n    enumerable: true,\n    get: function () { return core.detectOverflow; }\n  });\n  Object.defineProperty(exports, \"offset\", {\n    enumerable: true,\n    get: function () { return core.offset; }\n  });\n  exports.arrow = arrow;\n  exports.autoPlacement = autoPlacement;\n  exports.autoUpdate = autoUpdate;\n  exports.computePosition = computePosition;\n  exports.flip = flip;\n  exports.getOverflowAncestors = getOverflowAncestors;\n  exports.hide = hide;\n  exports.inline = inline;\n  exports.limitShift = limitShift;\n  exports.platform = platform;\n  exports.shift = shift;\n  exports.size = size;\n\n}));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$floating_ui$core$dist$floating_ui_core_umd"]],"~:properties",["^5",["width","convertOffsetParentRelativeRectToViewportRelativeRect","right","getOverflowAncestors","passive","top","FloatingUIDOM","hide","getDimensions","getOffsetParent","offset","getElementRects","height","arrow","rootMargin","autoUpdate","scrollLeft","inline","x","root","flip","limitShift","floating","enumerable","shift","getClippingRect","getScale","getDocumentElement","threshold","isElement","getClientRects","reference","y","computePosition","isRTL","bottom","_c","size","scrollTop","get","platform","$","left","detectOverflow","autoPlacement"]],"~:compiled-at",1712152511121,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$floating_ui$dom$dist$floating_ui_dom_umd.js\",\n\"lineCount\":377,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$floating_ui$dom$dist$floating_ui_dom_umd\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/core')) :\\n  typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/core'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));\\n})(this, (function (exports, core) { 'use strict';\\n\\n  /**\\n   * Custom positioning reference element.\\n   * @see https://floating-ui.com/docs/virtual-elements\\n   */\\n\\n  const min = Math.min;\\n  const max = Math.max;\\n  const round = Math.round;\\n  const floor = Math.floor;\\n  const createCoords = v => ({\\n    x: v,\\n    y: v\\n  });\\n\\n  function getNodeName(node) {\\n    if (isNode(node)) {\\n      return (node.nodeName || '').toLowerCase();\\n    }\\n    // Mocked nodes in testing environments may not be instances of Node. By\\n    // returning `#document` an infinite loop won't occur.\\n    // https://github.com/floating-ui/floating-ui/issues/2317\\n    return '#document';\\n  }\\n  function getWindow(node) {\\n    var _node$ownerDocument;\\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\\n  }\\n  function getDocumentElement(node) {\\n    var _ref;\\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\\n  }\\n  function isNode(value) {\\n    return value instanceof Node || value instanceof getWindow(value).Node;\\n  }\\n  function isElement(value) {\\n    return value instanceof Element || value instanceof getWindow(value).Element;\\n  }\\n  function isHTMLElement(value) {\\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\\n  }\\n  function isShadowRoot(value) {\\n    // Browsers without `ShadowRoot` support.\\n    if (typeof ShadowRoot === 'undefined') {\\n      return false;\\n    }\\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\\n  }\\n  function isOverflowElement(element) {\\n    const {\\n      overflow,\\n      overflowX,\\n      overflowY,\\n      display\\n    } = getComputedStyle(element);\\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\\n  }\\n  function isTableElement(element) {\\n    return ['table', 'td', 'th'].includes(getNodeName(element));\\n  }\\n  function isContainingBlock(element) {\\n    const webkit = isWebKit();\\n    const css = getComputedStyle(element);\\n\\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\\n    return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\\n  }\\n  function getContainingBlock(element) {\\n    let currentNode = getParentNode(element);\\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\\n      if (isContainingBlock(currentNode)) {\\n        return currentNode;\\n      }\\n      currentNode = getParentNode(currentNode);\\n    }\\n    return null;\\n  }\\n  function isWebKit() {\\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\\n    return CSS.supports('-webkit-backdrop-filter', 'none');\\n  }\\n  function isLastTraversableNode(node) {\\n    return ['html', 'body', '#document'].includes(getNodeName(node));\\n  }\\n  function getComputedStyle(element) {\\n    return getWindow(element).getComputedStyle(element);\\n  }\\n  function getNodeScroll(element) {\\n    if (isElement(element)) {\\n      return {\\n        scrollLeft: element.scrollLeft,\\n        scrollTop: element.scrollTop\\n      };\\n    }\\n    return {\\n      scrollLeft: element.pageXOffset,\\n      scrollTop: element.pageYOffset\\n    };\\n  }\\n  function getParentNode(node) {\\n    if (getNodeName(node) === 'html') {\\n      return node;\\n    }\\n    const result =\\n    // Step into the shadow DOM of the parent of a slotted node.\\n    node.assignedSlot ||\\n    // DOM Element detected.\\n    node.parentNode ||\\n    // ShadowRoot detected.\\n    isShadowRoot(node) && node.host ||\\n    // Fallback.\\n    getDocumentElement(node);\\n    return isShadowRoot(result) ? result.host : result;\\n  }\\n  function getNearestOverflowAncestor(node) {\\n    const parentNode = getParentNode(node);\\n    if (isLastTraversableNode(parentNode)) {\\n      return node.ownerDocument ? node.ownerDocument.body : node.body;\\n    }\\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\\n      return parentNode;\\n    }\\n    return getNearestOverflowAncestor(parentNode);\\n  }\\n  function getOverflowAncestors(node, list, traverseIframes) {\\n    var _node$ownerDocument2;\\n    if (list === void 0) {\\n      list = [];\\n    }\\n    if (traverseIframes === void 0) {\\n      traverseIframes = true;\\n    }\\n    const scrollableAncestor = getNearestOverflowAncestor(node);\\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\\n    const win = getWindow(scrollableAncestor);\\n    if (isBody) {\\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\\n    }\\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\\n  }\\n\\n  function getCssDimensions(element) {\\n    const css = getComputedStyle(element);\\n    // In testing environments, the `width` and `height` properties are empty\\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\\n    let width = parseFloat(css.width) || 0;\\n    let height = parseFloat(css.height) || 0;\\n    const hasOffset = isHTMLElement(element);\\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\\n    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\\n    if (shouldFallback) {\\n      width = offsetWidth;\\n      height = offsetHeight;\\n    }\\n    return {\\n      width,\\n      height,\\n      $: shouldFallback\\n    };\\n  }\\n\\n  function unwrapElement(element) {\\n    return !isElement(element) ? element.contextElement : element;\\n  }\\n\\n  function getScale(element) {\\n    const domElement = unwrapElement(element);\\n    if (!isHTMLElement(domElement)) {\\n      return createCoords(1);\\n    }\\n    const rect = domElement.getBoundingClientRect();\\n    const {\\n      width,\\n      height,\\n      $\\n    } = getCssDimensions(domElement);\\n    let x = ($ ? round(rect.width) : rect.width) / width;\\n    let y = ($ ? round(rect.height) : rect.height) / height;\\n\\n    // 0, NaN, or Infinity should always fallback to 1.\\n\\n    if (!x || !Number.isFinite(x)) {\\n      x = 1;\\n    }\\n    if (!y || !Number.isFinite(y)) {\\n      y = 1;\\n    }\\n    return {\\n      x,\\n      y\\n    };\\n  }\\n\\n  const noOffsets = /*#__PURE__*/createCoords(0);\\n  function getVisualOffsets(element) {\\n    const win = getWindow(element);\\n    if (!isWebKit() || !win.visualViewport) {\\n      return noOffsets;\\n    }\\n    return {\\n      x: win.visualViewport.offsetLeft,\\n      y: win.visualViewport.offsetTop\\n    };\\n  }\\n  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\\n    if (isFixed === void 0) {\\n      isFixed = false;\\n    }\\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\\n      return false;\\n    }\\n    return isFixed;\\n  }\\n\\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\\n    if (includeScale === void 0) {\\n      includeScale = false;\\n    }\\n    if (isFixedStrategy === void 0) {\\n      isFixedStrategy = false;\\n    }\\n    const clientRect = element.getBoundingClientRect();\\n    const domElement = unwrapElement(element);\\n    let scale = createCoords(1);\\n    if (includeScale) {\\n      if (offsetParent) {\\n        if (isElement(offsetParent)) {\\n          scale = getScale(offsetParent);\\n        }\\n      } else {\\n        scale = getScale(element);\\n      }\\n    }\\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\\n    let width = clientRect.width / scale.x;\\n    let height = clientRect.height / scale.y;\\n    if (domElement) {\\n      const win = getWindow(domElement);\\n      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\\n      let currentWin = win;\\n      let currentIFrame = currentWin.frameElement;\\n      while (currentIFrame && offsetParent && offsetWin !== currentWin) {\\n        const iframeScale = getScale(currentIFrame);\\n        const iframeRect = currentIFrame.getBoundingClientRect();\\n        const css = getComputedStyle(currentIFrame);\\n        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\\n        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\\n        x *= iframeScale.x;\\n        y *= iframeScale.y;\\n        width *= iframeScale.x;\\n        height *= iframeScale.y;\\n        x += left;\\n        y += top;\\n        currentWin = getWindow(currentIFrame);\\n        currentIFrame = currentWin.frameElement;\\n      }\\n    }\\n    return core.rectToClientRect({\\n      width,\\n      height,\\n      x,\\n      y\\n    });\\n  }\\n\\n  const topLayerSelectors = [':popover-open', ':modal'];\\n  function isTopLayer(floating) {\\n    return topLayerSelectors.some(selector => {\\n      try {\\n        return floating.matches(selector);\\n      } catch (e) {\\n        return false;\\n      }\\n    });\\n  }\\n\\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\\n    let {\\n      elements,\\n      rect,\\n      offsetParent,\\n      strategy\\n    } = _ref;\\n    const isFixed = strategy === 'fixed';\\n    const documentElement = getDocumentElement(offsetParent);\\n    const topLayer = elements ? isTopLayer(elements.floating) : false;\\n    if (offsetParent === documentElement || topLayer && isFixed) {\\n      return rect;\\n    }\\n    let scroll = {\\n      scrollLeft: 0,\\n      scrollTop: 0\\n    };\\n    let scale = createCoords(1);\\n    const offsets = createCoords(0);\\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\\n        scroll = getNodeScroll(offsetParent);\\n      }\\n      if (isHTMLElement(offsetParent)) {\\n        const offsetRect = getBoundingClientRect(offsetParent);\\n        scale = getScale(offsetParent);\\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\\n        offsets.y = offsetRect.y + offsetParent.clientTop;\\n      }\\n    }\\n    return {\\n      width: rect.width * scale.x,\\n      height: rect.height * scale.y,\\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\\n    };\\n  }\\n\\n  function getClientRects(element) {\\n    return Array.from(element.getClientRects());\\n  }\\n\\n  function getWindowScrollBarX(element) {\\n    // If <html> has a CSS width greater than the viewport, then this will be\\n    // incorrect for RTL.\\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\\n  }\\n\\n  // Gets the entire size of the scrollable document area, even extending outside\\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\\n  function getDocumentRect(element) {\\n    const html = getDocumentElement(element);\\n    const scroll = getNodeScroll(element);\\n    const body = element.ownerDocument.body;\\n    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\\n    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\\n    const y = -scroll.scrollTop;\\n    if (getComputedStyle(body).direction === 'rtl') {\\n      x += max(html.clientWidth, body.clientWidth) - width;\\n    }\\n    return {\\n      width,\\n      height,\\n      x,\\n      y\\n    };\\n  }\\n\\n  function getViewportRect(element, strategy) {\\n    const win = getWindow(element);\\n    const html = getDocumentElement(element);\\n    const visualViewport = win.visualViewport;\\n    let width = html.clientWidth;\\n    let height = html.clientHeight;\\n    let x = 0;\\n    let y = 0;\\n    if (visualViewport) {\\n      width = visualViewport.width;\\n      height = visualViewport.height;\\n      const visualViewportBased = isWebKit();\\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\\n        x = visualViewport.offsetLeft;\\n        y = visualViewport.offsetTop;\\n      }\\n    }\\n    return {\\n      width,\\n      height,\\n      x,\\n      y\\n    };\\n  }\\n\\n  // Returns the inner client rect, subtracting scrollbars if present.\\n  function getInnerBoundingClientRect(element, strategy) {\\n    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\\n    const top = clientRect.top + element.clientTop;\\n    const left = clientRect.left + element.clientLeft;\\n    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\\n    const width = element.clientWidth * scale.x;\\n    const height = element.clientHeight * scale.y;\\n    const x = left * scale.x;\\n    const y = top * scale.y;\\n    return {\\n      width,\\n      height,\\n      x,\\n      y\\n    };\\n  }\\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\\n    let rect;\\n    if (clippingAncestor === 'viewport') {\\n      rect = getViewportRect(element, strategy);\\n    } else if (clippingAncestor === 'document') {\\n      rect = getDocumentRect(getDocumentElement(element));\\n    } else if (isElement(clippingAncestor)) {\\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\\n    } else {\\n      const visualOffsets = getVisualOffsets(element);\\n      rect = {\\n        ...clippingAncestor,\\n        x: clippingAncestor.x - visualOffsets.x,\\n        y: clippingAncestor.y - visualOffsets.y\\n      };\\n    }\\n    return core.rectToClientRect(rect);\\n  }\\n  function hasFixedPositionAncestor(element, stopNode) {\\n    const parentNode = getParentNode(element);\\n    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\\n      return false;\\n    }\\n    return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\\n  }\\n\\n  // A \\\"clipping ancestor\\\" is an `overflow` element with the characteristic of\\n  // clipping (or hiding) child elements. This returns all clipping ancestors\\n  // of the given element up the tree.\\n  function getClippingElementAncestors(element, cache) {\\n    const cachedResult = cache.get(element);\\n    if (cachedResult) {\\n      return cachedResult;\\n    }\\n    let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\\n    let currentContainingBlockComputedStyle = null;\\n    const elementIsFixed = getComputedStyle(element).position === 'fixed';\\n    let currentNode = elementIsFixed ? getParentNode(element) : element;\\n\\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\\n      const computedStyle = getComputedStyle(currentNode);\\n      const currentNodeIsContaining = isContainingBlock(currentNode);\\n      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\\n        currentContainingBlockComputedStyle = null;\\n      }\\n      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\\n      if (shouldDropCurrentNode) {\\n        // Drop non-containing blocks.\\n        result = result.filter(ancestor => ancestor !== currentNode);\\n      } else {\\n        // Record last containing block for next iteration.\\n        currentContainingBlockComputedStyle = computedStyle;\\n      }\\n      currentNode = getParentNode(currentNode);\\n    }\\n    cache.set(element, result);\\n    return result;\\n  }\\n\\n  // Gets the maximum area that the element is visible in due to any number of\\n  // clipping ancestors.\\n  function getClippingRect(_ref) {\\n    let {\\n      element,\\n      boundary,\\n      rootBoundary,\\n      strategy\\n    } = _ref;\\n    const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\\n    const clippingAncestors = [...elementClippingAncestors, rootBoundary];\\n    const firstClippingAncestor = clippingAncestors[0];\\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\\n      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\\n      accRect.top = max(rect.top, accRect.top);\\n      accRect.right = min(rect.right, accRect.right);\\n      accRect.bottom = min(rect.bottom, accRect.bottom);\\n      accRect.left = max(rect.left, accRect.left);\\n      return accRect;\\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\\n    return {\\n      width: clippingRect.right - clippingRect.left,\\n      height: clippingRect.bottom - clippingRect.top,\\n      x: clippingRect.left,\\n      y: clippingRect.top\\n    };\\n  }\\n\\n  function getDimensions(element) {\\n    const {\\n      width,\\n      height\\n    } = getCssDimensions(element);\\n    return {\\n      width,\\n      height\\n    };\\n  }\\n\\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\\n    const documentElement = getDocumentElement(offsetParent);\\n    const isFixed = strategy === 'fixed';\\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\\n    let scroll = {\\n      scrollLeft: 0,\\n      scrollTop: 0\\n    };\\n    const offsets = createCoords(0);\\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\\n        scroll = getNodeScroll(offsetParent);\\n      }\\n      if (isOffsetParentAnElement) {\\n        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\\n        offsets.y = offsetRect.y + offsetParent.clientTop;\\n      } else if (documentElement) {\\n        offsets.x = getWindowScrollBarX(documentElement);\\n      }\\n    }\\n    const x = rect.left + scroll.scrollLeft - offsets.x;\\n    const y = rect.top + scroll.scrollTop - offsets.y;\\n    return {\\n      x,\\n      y,\\n      width: rect.width,\\n      height: rect.height\\n    };\\n  }\\n\\n  function getTrueOffsetParent(element, polyfill) {\\n    if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\\n      return null;\\n    }\\n    if (polyfill) {\\n      return polyfill(element);\\n    }\\n    return element.offsetParent;\\n  }\\n\\n  // Gets the closest ancestor positioned element. Handles some edge cases,\\n  // such as table ancestors and cross browser bugs.\\n  function getOffsetParent(element, polyfill) {\\n    const window = getWindow(element);\\n    if (!isHTMLElement(element) || isTopLayer(element)) {\\n      return window;\\n    }\\n    let offsetParent = getTrueOffsetParent(element, polyfill);\\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\\n    }\\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\\n      return window;\\n    }\\n    return offsetParent || getContainingBlock(element) || window;\\n  }\\n\\n  const getElementRects = async function (data) {\\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\\n    const getDimensionsFn = this.getDimensions;\\n    return {\\n      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\\n      floating: {\\n        x: 0,\\n        y: 0,\\n        ...(await getDimensionsFn(data.floating))\\n      }\\n    };\\n  };\\n\\n  function isRTL(element) {\\n    return getComputedStyle(element).direction === 'rtl';\\n  }\\n\\n  const platform = {\\n    convertOffsetParentRelativeRectToViewportRelativeRect,\\n    getDocumentElement,\\n    getClippingRect,\\n    getOffsetParent,\\n    getElementRects,\\n    getClientRects,\\n    getDimensions,\\n    getScale,\\n    isElement,\\n    isRTL\\n  };\\n\\n  // https://samthor.au/2021/observing-dom/\\n  function observeMove(element, onMove) {\\n    let io = null;\\n    let timeoutId;\\n    const root = getDocumentElement(element);\\n    function cleanup() {\\n      var _io;\\n      clearTimeout(timeoutId);\\n      (_io = io) == null || _io.disconnect();\\n      io = null;\\n    }\\n    function refresh(skip, threshold) {\\n      if (skip === void 0) {\\n        skip = false;\\n      }\\n      if (threshold === void 0) {\\n        threshold = 1;\\n      }\\n      cleanup();\\n      const {\\n        left,\\n        top,\\n        width,\\n        height\\n      } = element.getBoundingClientRect();\\n      if (!skip) {\\n        onMove();\\n      }\\n      if (!width || !height) {\\n        return;\\n      }\\n      const insetTop = floor(top);\\n      const insetRight = floor(root.clientWidth - (left + width));\\n      const insetBottom = floor(root.clientHeight - (top + height));\\n      const insetLeft = floor(left);\\n      const rootMargin = -insetTop + \\\"px \\\" + -insetRight + \\\"px \\\" + -insetBottom + \\\"px \\\" + -insetLeft + \\\"px\\\";\\n      const options = {\\n        rootMargin,\\n        threshold: max(0, min(1, threshold)) || 1\\n      };\\n      let isFirstUpdate = true;\\n      function handleObserve(entries) {\\n        const ratio = entries[0].intersectionRatio;\\n        if (ratio !== threshold) {\\n          if (!isFirstUpdate) {\\n            return refresh();\\n          }\\n          if (!ratio) {\\n            timeoutId = setTimeout(() => {\\n              refresh(false, 1e-7);\\n            }, 100);\\n          } else {\\n            refresh(false, ratio);\\n          }\\n        }\\n        isFirstUpdate = false;\\n      }\\n\\n      // Older browsers don't support a `document` as the root and will throw an\\n      // error.\\n      try {\\n        io = new IntersectionObserver(handleObserve, {\\n          ...options,\\n          // Handle <iframe>s\\n          root: root.ownerDocument\\n        });\\n      } catch (e) {\\n        io = new IntersectionObserver(handleObserve, options);\\n      }\\n      io.observe(element);\\n    }\\n    refresh(true);\\n    return cleanup;\\n  }\\n\\n  /**\\n   * Automatically updates the position of the floating element when necessary.\\n   * Should only be called when the floating element is mounted on the DOM or\\n   * visible on the screen.\\n   * @returns cleanup function that should be invoked when the floating element is\\n   * removed from the DOM or hidden from the screen.\\n   * @see https://floating-ui.com/docs/autoUpdate\\n   */\\n  function autoUpdate(reference, floating, update, options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    const {\\n      ancestorScroll = true,\\n      ancestorResize = true,\\n      elementResize = typeof ResizeObserver === 'function',\\n      layoutShift = typeof IntersectionObserver === 'function',\\n      animationFrame = false\\n    } = options;\\n    const referenceEl = unwrapElement(reference);\\n    const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\\n    ancestors.forEach(ancestor => {\\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\\n        passive: true\\n      });\\n      ancestorResize && ancestor.addEventListener('resize', update);\\n    });\\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\\n    let reobserveFrame = -1;\\n    let resizeObserver = null;\\n    if (elementResize) {\\n      resizeObserver = new ResizeObserver(_ref => {\\n        let [firstEntry] = _ref;\\n        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\\n          // Prevent update loops when using the `size` middleware.\\n          // https://github.com/floating-ui/floating-ui/issues/1740\\n          resizeObserver.unobserve(floating);\\n          cancelAnimationFrame(reobserveFrame);\\n          reobserveFrame = requestAnimationFrame(() => {\\n            var _resizeObserver;\\n            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\\n          });\\n        }\\n        update();\\n      });\\n      if (referenceEl && !animationFrame) {\\n        resizeObserver.observe(referenceEl);\\n      }\\n      resizeObserver.observe(floating);\\n    }\\n    let frameId;\\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\\n    if (animationFrame) {\\n      frameLoop();\\n    }\\n    function frameLoop() {\\n      const nextRefRect = getBoundingClientRect(reference);\\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\\n        update();\\n      }\\n      prevRefRect = nextRefRect;\\n      frameId = requestAnimationFrame(frameLoop);\\n    }\\n    update();\\n    return () => {\\n      var _resizeObserver2;\\n      ancestors.forEach(ancestor => {\\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\\n        ancestorResize && ancestor.removeEventListener('resize', update);\\n      });\\n      cleanupIo == null || cleanupIo();\\n      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\\n      resizeObserver = null;\\n      if (animationFrame) {\\n        cancelAnimationFrame(frameId);\\n      }\\n    };\\n  }\\n\\n  /**\\n   * Optimizes the visibility of the floating element by choosing the placement\\n   * that has the most space available automatically, without needing to specify a\\n   * preferred placement. Alternative to `flip`.\\n   * @see https://floating-ui.com/docs/autoPlacement\\n   */\\n  const autoPlacement = core.autoPlacement;\\n\\n  /**\\n   * Optimizes the visibility of the floating element by shifting it in order to\\n   * keep it in view when it will overflow the clipping boundary.\\n   * @see https://floating-ui.com/docs/shift\\n   */\\n  const shift = core.shift;\\n\\n  /**\\n   * Optimizes the visibility of the floating element by flipping the `placement`\\n   * in order to keep it in view when the preferred placement(s) will overflow the\\n   * clipping boundary. Alternative to `autoPlacement`.\\n   * @see https://floating-ui.com/docs/flip\\n   */\\n  const flip = core.flip;\\n\\n  /**\\n   * Provides data that allows you to change the size of the floating element \\u2014\\n   * for instance, prevent it from overflowing the clipping boundary or match the\\n   * width of the reference element.\\n   * @see https://floating-ui.com/docs/size\\n   */\\n  const size = core.size;\\n\\n  /**\\n   * Provides data to hide the floating element in applicable situations, such as\\n   * when it is not in the same clipping context as the reference element.\\n   * @see https://floating-ui.com/docs/hide\\n   */\\n  const hide = core.hide;\\n\\n  /**\\n   * Provides data to position an inner element of the floating element so that it\\n   * appears centered to the reference element.\\n   * @see https://floating-ui.com/docs/arrow\\n   */\\n  const arrow = core.arrow;\\n\\n  /**\\n   * Provides improved positioning for inline reference elements that can span\\n   * over multiple lines, such as hyperlinks or range selections.\\n   * @see https://floating-ui.com/docs/inline\\n   */\\n  const inline = core.inline;\\n\\n  /**\\n   * Built-in `limiter` that will stop `shift()` at a certain point.\\n   */\\n  const limitShift = core.limitShift;\\n\\n  /**\\n   * Computes the `x` and `y` coordinates that will place the floating element\\n   * next to a given reference element.\\n   */\\n  const computePosition = (reference, floating, options) => {\\n    // This caches the expensive `getClippingElementAncestors` function so that\\n    // multiple lifecycle resets re-use the same result. It only lives for a\\n    // single call. If other functions become expensive, we can add them as well.\\n    const cache = new Map();\\n    const mergedOptions = {\\n      platform,\\n      ...options\\n    };\\n    const platformWithCache = {\\n      ...mergedOptions.platform,\\n      _c: cache\\n    };\\n    return core.computePosition(reference, floating, {\\n      ...mergedOptions,\\n      platform: platformWithCache\\n    });\\n  };\\n\\n  Object.defineProperty(exports, \\\"detectOverflow\\\", {\\n    enumerable: true,\\n    get: function () { return core.detectOverflow; }\\n  });\\n  Object.defineProperty(exports, \\\"offset\\\", {\\n    enumerable: true,\\n    get: function () { return core.offset; }\\n  });\\n  exports.arrow = arrow;\\n  exports.autoPlacement = autoPlacement;\\n  exports.autoUpdate = autoUpdate;\\n  exports.computePosition = computePosition;\\n  exports.flip = flip;\\n  exports.getOverflowAncestors = getOverflowAncestors;\\n  exports.hide = hide;\\n  exports.inline = inline;\\n  exports.limitShift = limitShift;\\n  exports.platform = platform;\\n  exports.shift = shift;\\n  exports.size = size;\\n\\n}));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"FloatingUIDOM\",\"FloatingUICore\",\"core\",\"getNodeName\",\"node\",\"isNode\",\"toLowerCase\",\"nodeName\",\"getWindow\",\"_node$ownerDocument\",\"ownerDocument\",\"defaultView\",\"window\",\"getDocumentElement\",\"_ref\",\"document\",\"documentElement\",\"value\",\"Node\",\"isElement\",\"Element\",\"isHTMLElement\",\"HTMLElement\",\"isShadowRoot\",\"ShadowRoot\",\"isOverflowElement\",\"element\",\"overflow\",\"overflowX\",\"overflowY\",\"display\",\"getComputedStyle\",\"test\",\"includes\",\"isContainingBlock\",\"webkit\",\"isWebKit\",\"css\",\"transform\",\"perspective\",\"containerType\",\"backdropFilter\",\"filter\",\"some\",\"willChange\",\"contain\",\"CSS\",\"supports\",\"isLastTraversableNode\",\"getNodeScroll\",\"scrollLeft\",\"scrollTop\",\"pageXOffset\",\"pageYOffset\",\"getParentNode\",\"result\",\"assignedSlot\",\"parentNode\",\"host\",\"getNearestOverflowAncestor\",\"body\",\"getOverflowAncestors\",\"list\",\"traverseIframes\",\"_node$ownerDocument2\",\"scrollableAncestor\",\"isBody\",\"win\",\"concat\",\"visualViewport\",\"frameElement\",\"getCssDimensions\",\"width\",\"parseFloat\",\"height\",\"hasOffset\",\"offsetWidth\",\"offsetHeight\",\"shouldFallback\",\"round\",\"$\",\"unwrapElement\",\"contextElement\",\"getScale\",\"domElement\",\"x\",\"v\",\"y\",\"rect\",\"getBoundingClientRect\",\"Number\",\"isFinite\",\"getVisualOffsets\",\"offsetLeft\",\"offsetTop\",\"noOffsets\",\"includeScale\",\"isFixedStrategy\",\"offsetParent\",\"clientRect\",\"scale\",\"isFixed\",\"visualOffsets\",\"left\",\"top\",\"offsetWin\",\"currentWin\",\"currentIFrame\",\"iframeScale\",\"iframeRect\",\"clientLeft\",\"paddingLeft\",\"clientTop\",\"paddingTop\",\"rectToClientRect\",\"isTopLayer\",\"floating\",\"topLayerSelectors\",\"selector\",\"matches\",\"e\",\"getClientRectFromClippingAncestor\",\"clippingAncestor\",\"strategy\",\"html\",\"clientWidth\",\"clientHeight\",\"visualViewportBased\",\"scroll\",\"max\",\"scrollWidth\",\"scrollHeight\",\"direction\",\"hasFixedPositionAncestor\",\"stopNode\",\"position\",\"getClippingElementAncestors\",\"cache\",\"cachedResult\",\"get\",\"el\",\"currentContainingBlockComputedStyle\",\"elementIsFixed\",\"currentNode\",\"computedStyle\",\"currentNodeIsContaining\",\"shouldDropCurrentNode\",\"ancestor\",\"set\",\"getTrueOffsetParent\",\"polyfill\",\"getOffsetParent\",\"observeMove\",\"onMove\",\"cleanup\",\"_io\",\"clearTimeout\",\"timeoutId\",\"io\",\"disconnect\",\"refresh\",\"skip\",\"threshold\",\"handleObserve\",\"entries\",\"ratio\",\"intersectionRatio\",\"isFirstUpdate\",\"setTimeout\",\"insetTop\",\"floor\",\"insetRight\",\"root\",\"insetBottom\",\"insetLeft\",\"options\",\"rootMargin\",\"min\",\"IntersectionObserver\",\"observe\",\"Math\",\"platform\",\"convertOffsetParentRelativeRectToViewportRelativeRect\",\"elements\",\"topLayer\",\"isOffsetParentAnElement\",\"offsetRect\",\"getClippingRect\",\"boundary\",\"rootBoundary\",\"clippingAncestors\",\"elementClippingAncestors\",\"_c\",\"clippingRect\",\"reduce\",\"accRect\",\"right\",\"bottom\",\"firstClippingAncestor\",\"getElementRects\",\"data\",\"getDimensionsFn\",\"getDimensions\",\"reference\",\"getClientRects\",\"Array\",\"from\",\"isRTL\",\"autoPlacement\",\"shift\",\"flip\",\"size\",\"hide\",\"arrow\",\"inline\",\"limitShift\",\"Object\",\"defineProperty\",\"enumerable\",\"detectOverflow\",\"offset\",\"autoUpdate\",\"update\",\"frameLoop\",\"nextRefRect\",\"prevRefRect\",\"frameId\",\"requestAnimationFrame\",\"ancestorScroll\",\"ancestorResize\",\"elementResize\",\"ResizeObserver\",\"layoutShift\",\"animationFrame\",\"referenceEl\",\"ancestors\",\"forEach\",\"addEventListener\",\"passive\",\"cleanupIo\",\"reobserveFrame\",\"resizeObserver\",\"firstEntry\",\"target\",\"unobserve\",\"cancelAnimationFrame\",\"_resizeObserver\",\"_resizeObserver2\",\"removeEventListener\",\"computePosition\",\"Map\",\"mergedOptions\",\"platformWithCache\"]\n}\n"]