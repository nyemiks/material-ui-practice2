["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@floating-ui/core/dist/floating-ui.core.umd.js"],"~:js","shadow$provide.module$node_modules$$floating_ui$core$dist$floating_ui_core_umd = function(global, require, module, exports) {\n  (function(global, factory) {\n    \"object\" === typeof exports && \"undefined\" !== typeof module ? factory(exports) : \"function\" === typeof define && define.amd ? define([\"exports\"], factory) : (global = \"undefined\" !== typeof globalThis ? globalThis : global || self, factory(global.FloatingUICore = {}));\n  })(this, function(exports) {\n    function evaluate(value, param) {\n      return \"function\" === typeof value ? value(param) : value;\n    }\n    function getSide(placement) {\n      return placement.split(\"-\")[0];\n    }\n    function getAlignment(placement) {\n      return placement.split(\"-\")[1];\n    }\n    function getOppositeAxis(axis) {\n      return \"x\" === axis ? \"y\" : \"x\";\n    }\n    function getAxisLength(axis) {\n      return \"y\" === axis ? \"height\" : \"width\";\n    }\n    function getSideAxis(placement) {\n      return [\"top\", \"bottom\"].includes(getSide(placement)) ? \"y\" : \"x\";\n    }\n    function getAlignmentSides(placement, rects, rtl) {\n      void 0 === rtl && (rtl = !1);\n      const alignment = getAlignment(placement), alignmentAxis = getOppositeAxis(getSideAxis(placement));\n      placement = getAxisLength(alignmentAxis);\n      rtl = \"x\" === alignmentAxis ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : \"start\" === alignment ? \"bottom\" : \"top\";\n      rects.reference[placement] > rects.floating[placement] && (rtl = getOppositePlacement(rtl));\n      return [rtl, getOppositePlacement(rtl)];\n    }\n    function getExpandedPlacements(placement) {\n      const oppositePlacement = getOppositePlacement(placement);\n      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n    }\n    function getOppositeAlignmentPlacement(placement) {\n      return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n    }\n    function getSideList(side, isStart, rtl) {\n      const lr = [\"left\", \"right\"], rl = [\"right\", \"left\"], tb = [\"top\", \"bottom\"], bt = [\"bottom\", \"top\"];\n      switch(side) {\n        case \"top\":\n        case \"bottom\":\n          return rtl ? isStart ? rl : lr : isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n          return isStart ? tb : bt;\n        default:\n          return [];\n      }\n    }\n    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n      const alignment = getAlignment(placement);\n      placement = getSideList(getSide(placement), \"start\" === direction, rtl);\n      alignment && (placement = placement.map(side => side + \"-\" + alignment), flipAlignment && (placement = placement.concat(placement.map(getOppositeAlignmentPlacement))));\n      return placement;\n    }\n    function getOppositePlacement(placement) {\n      return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n    }\n    function getPaddingObject(padding) {\n      return \"number\" !== typeof padding ? {top:0, right:0, bottom:0, left:0, ...padding} : {top:padding, right:padding, bottom:padding, left:padding};\n    }\n    function rectToClientRect(rect) {\n      return {...rect, top:rect.y, left:rect.x, right:rect.x + rect.width, bottom:rect.y + rect.height};\n    }\n    function computeCoordsFromPlacement(_ref, placement, rtl) {\n      let {reference, floating} = _ref;\n      var sideAxis = getSideAxis(placement);\n      _ref = getOppositeAxis(getSideAxis(placement));\n      var alignLength = getAxisLength(_ref), side = getSide(placement);\n      sideAxis = \"y\" === sideAxis;\n      const commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2;\n      alignLength = reference[alignLength] / 2 - floating[alignLength] / 2;\n      switch(side) {\n        case \"top\":\n          side = {x:commonX, y:reference.y - floating.height};\n          break;\n        case \"bottom\":\n          side = {x:commonX, y:reference.y + reference.height};\n          break;\n        case \"right\":\n          side = {x:reference.x + reference.width, y:commonY};\n          break;\n        case \"left\":\n          side = {x:reference.x - floating.width, y:commonY};\n          break;\n        default:\n          side = {x:reference.x, y:reference.y};\n      }\n      switch(getAlignment(placement)) {\n        case \"start\":\n          side[_ref] -= alignLength * (rtl && sideAxis ? -1 : 1);\n          break;\n        case \"end\":\n          side[_ref] += alignLength * (rtl && sideAxis ? -1 : 1);\n      }\n      return side;\n    }\n    async function detectOverflow(state, options) {\n      var _await$platform$isEle;\n      void 0 === options && (options = {});\n      const {x, y, platform, rects, elements, strategy} = state, {boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = !1, padding = 0} = evaluate(options, state);\n      state = getPaddingObject(padding);\n      var element = elements[altBoundary ? \"floating\" === elementContext ? \"reference\" : \"floating\" : elementContext];\n      options = rectToClientRect(await platform.getClippingRect({element:(null != (_await$platform$isEle = await (null == platform.isElement ? void 0 : platform.isElement(element))) ? _await$platform$isEle : 1) ? element : element.contextElement || await (null == platform.getDocumentElement ? void 0 : platform.getDocumentElement(elements.floating)), boundary, rootBoundary, strategy}));\n      element = \"floating\" === elementContext ? {...rects.floating, x, y} : rects.reference;\n      const offsetParent = await (null == platform.getOffsetParent ? void 0 : platform.getOffsetParent(elements.floating));\n      _await$platform$isEle = await (null == platform.isElement ? void 0 : platform.isElement(offsetParent)) ? await (null == platform.getScale ? void 0 : platform.getScale(offsetParent)) || {x:1, y:1} : {x:1, y:1};\n      element = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({elements, rect:element, offsetParent, strategy}) : element);\n      return {top:(options.top - element.top + state.top) / _await$platform$isEle.y, bottom:(element.bottom - options.bottom + state.bottom) / _await$platform$isEle.y, left:(options.left - element.left + state.left) / _await$platform$isEle.x, right:(element.right - options.right + state.right) / _await$platform$isEle.x};\n    }\n    function getPlacementList(alignment, autoAlignment, allowedPlacements) {\n      return (alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement)).filter(placement => alignment ? getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : !1) : !0);\n    }\n    function getSideOffsets(overflow, rect) {\n      return {top:overflow.top - rect.height, right:overflow.right - rect.width, bottom:overflow.bottom - rect.height, left:overflow.left - rect.width};\n    }\n    function isAnySideFullyClipped(overflow) {\n      return sides.some(side => 0 <= overflow[side]);\n    }\n    function getBoundingRect(rects) {\n      const minX = min(...rects.map(rect => rect.left)), minY = min(...rects.map(rect => rect.top)), maxX = max(...rects.map(rect => rect.right));\n      rects = max(...rects.map(rect => rect.bottom));\n      return {x:minX, y:minY, width:maxX - minX, height:rects - minY};\n    }\n    function getRectsByLine(rects) {\n      rects = rects.slice().sort((a, b) => a.y - b.y);\n      const groups = [];\n      let prevRect = null;\n      for (let i = 0; i < rects.length; i++) {\n        const rect = rects[i];\n        !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect);\n        prevRect = rect;\n      }\n      return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n    }\n    async function convertValueToCoords(state, options) {\n      const {placement, platform, elements} = state;\n      var rtl = await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating)), side = getSide(placement);\n      const alignment = getAlignment(placement), isVertical = \"y\" === getSideAxis(placement);\n      side = [\"left\", \"top\"].includes(side) ? -1 : 1;\n      rtl = rtl && isVertical ? -1 : 1;\n      state = evaluate(options, state);\n      let {mainAxis, crossAxis, alignmentAxis} = \"number\" === typeof state ? {mainAxis:state, crossAxis:0, alignmentAxis:null} : {mainAxis:0, crossAxis:0, alignmentAxis:null, ...state};\n      alignment && \"number\" === typeof alignmentAxis && (crossAxis = \"end\" === alignment ? -1 * alignmentAxis : alignmentAxis);\n      return isVertical ? {x:crossAxis * rtl, y:mainAxis * side} : {x:mainAxis * side, y:crossAxis * rtl};\n    }\n    const sides = [\"top\", \"right\", \"bottom\", \"left\"], alignments = [\"start\", \"end\"], placements = sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []), min = Math.min, max = Math.max, oppositeSideMap = {left:\"right\", right:\"left\", bottom:\"top\", top:\"bottom\"}, oppositeAlignmentMap = {start:\"end\", end:\"start\"};\n    exports.arrow = options => ({name:\"arrow\", options, async fn(state) {\n      const {x, y, placement, rects, platform, elements, middlewareData} = state, {element, padding = 0} = evaluate(options, state) || {};\n      if (null == element) {\n        return {};\n      }\n      var paddingObject = getPaddingObject(padding);\n      state = {x, y};\n      const axis = getOppositeAxis(getSideAxis(placement));\n      var length = getAxisLength(axis), arrowDimensions = await platform.getDimensions(element), isYAxis = \"y\" === axis, minProp = isYAxis ? \"top\" : \"left\", maxProp = isYAxis ? \"bottom\" : \"right\", clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\", endDiff = rects.reference[length] + rects.reference[axis] - state[axis] - rects.floating[length];\n      const startDiff = state[axis] - rects.reference[axis], arrowOffsetParent = await (null == platform.getOffsetParent ? void 0 : platform.getOffsetParent(element));\n      (isYAxis = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0) && await (null == platform.isElement ? void 0 : platform.isElement(arrowOffsetParent)) || (isYAxis = elements.floating[clientProp] || rects.floating[length]);\n      clientProp = endDiff / 2 - startDiff / 2;\n      endDiff = isYAxis / 2 - arrowDimensions[length] / 2 - 1;\n      minProp = min(paddingObject[minProp], endDiff);\n      maxProp = min(paddingObject[maxProp], endDiff);\n      paddingObject = isYAxis - arrowDimensions[length] - maxProp;\n      isYAxis = isYAxis / 2 - arrowDimensions[length] / 2 + clientProp;\n      clientProp = max(minProp, min(isYAxis, paddingObject));\n      arrowDimensions = (length = !middlewareData.arrow && null != getAlignment(placement) && isYAxis !== clientProp && 0 > rects.reference[length] / 2 - (isYAxis < minProp ? minProp : maxProp) - arrowDimensions[length] / 2) ? isYAxis < minProp ? isYAxis - minProp : isYAxis - paddingObject : 0;\n      return {[axis]:state[axis] + arrowDimensions, data:{[axis]:clientProp, centerOffset:isYAxis - clientProp - arrowDimensions, ...(length && {alignmentOffset:arrowDimensions})}, reset:length};\n    }});\n    exports.autoPlacement = function(options) {\n      void 0 === options && (options = {});\n      return {name:\"autoPlacement\", options, async fn(state) {\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n        const {rects, middlewareData, placement, platform, elements} = state, {crossAxis = !1, alignment, allowedPlacements = placements, autoAlignment = !0, ...detectOverflowOptions} = evaluate(options, state);\n        var placements$1 = void 0 !== alignment || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements, overflow = await detectOverflow(state, detectOverflowOptions);\n        state = (null == (_middlewareData$autoP = middlewareData.autoPlacement) ? void 0 : _middlewareData$autoP.index) || 0;\n        _middlewareData$autoP = placements$1[state];\n        if (null == _middlewareData$autoP) {\n          return {};\n        }\n        var alignmentSides = getAlignmentSides(_middlewareData$autoP, rects, await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating)));\n        if (placement !== _middlewareData$autoP) {\n          return {reset:{placement:placements$1[0]}};\n        }\n        alignmentSides = [overflow[getSide(_middlewareData$autoP)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n        overflow = [...((null == (_middlewareData$autoP2 = middlewareData.autoPlacement) ? void 0 : _middlewareData$autoP2.overflows) || []), {placement:_middlewareData$autoP, overflows:alignmentSides}];\n        if (_middlewareData$autoP2 = placements$1[state + 1]) {\n          return {data:{index:state + 1, overflows:overflow}, reset:{placement:_middlewareData$autoP2}};\n        }\n        _middlewareData$autoP2 = overflow.map(d => {\n          const alignment = getAlignment(d.placement);\n          return [d.placement, alignment && crossAxis ? d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) : d.overflows[0], d.overflows];\n        }).sort((a, b) => a[1] - b[1]);\n        placements$1 = (null == (_placementsThatFitOnE = _middlewareData$autoP2.filter(d => d[2].slice(0, getAlignment(d[0]) ? 2 : 3).every(v => 0 >= v))[0]) ? void 0 : _placementsThatFitOnE[0]) || _middlewareData$autoP2[0][0];\n        return placements$1 !== placement ? {data:{index:state + 1, overflows:overflow}, reset:{placement:placements$1}} : {};\n      }};\n    };\n    exports.computePosition = async(reference, floating, config) => {\n      const {placement = \"bottom\", strategy = \"absolute\", middleware = [], platform} = config;\n      config = middleware.filter(Boolean);\n      const rtl = await (null == platform.isRTL ? void 0 : platform.isRTL(floating));\n      let rects = await platform.getElementRects({reference, floating, strategy}), {x, y} = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;\n      for (let i = 0; i < config.length; i++) {\n        const {name, fn} = config[i], {x:nextX, y:nextY, data, reset} = await fn({x, y, initialPlacement:placement, placement:statefulPlacement, strategy, middlewareData, rects, platform, elements:{reference, floating}});\n        x = null != nextX ? nextX : x;\n        y = null != nextY ? nextY : y;\n        middlewareData = {...middlewareData, [name]:{...middlewareData[name], ...data}};\n        reset && 50 >= resetCount && (resetCount++, \"object\" === typeof reset && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = !0 === reset.rects ? await platform.getElementRects({reference, floating, strategy}) : reset.rects), {x, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i = -1);\n      }\n      return {x, y, placement:statefulPlacement, strategy, middlewareData};\n    };\n    exports.detectOverflow = detectOverflow;\n    exports.flip = function(options) {\n      void 0 === options && (options = {});\n      return {name:\"flip\", options, async fn(state) {\n        var _middlewareData$arrow, _middlewareData$flip;\n        const {placement, middlewareData, rects, initialPlacement, platform, elements} = state, {mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !0, fallbackPlacements:specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = !0, ...detectOverflowOptions} = evaluate(options, state);\n        if (null != (_middlewareData$arrow = middlewareData.arrow) && _middlewareData$arrow.alignmentOffset) {\n          return {};\n        }\n        _middlewareData$arrow = getSide(placement);\n        var isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const rtl = await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating));\n        isBasePlacement = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        specifiedFallbackPlacements || \"none\" === fallbackAxisSideDirection || isBasePlacement.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n        isBasePlacement = [initialPlacement, ...isBasePlacement];\n        const overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];\n        state = (null == (_middlewareData$flip = middlewareData.flip) ? void 0 : _middlewareData$flip.overflows) || [];\n        checkMainAxis && overflows.push(overflow[_middlewareData$arrow]);\n        checkCrossAxis && (_middlewareData$flip = getAlignmentSides(placement, rects, rtl), overflows.push(overflow[_middlewareData$flip[0]], overflow[_middlewareData$flip[1]]));\n        state = [...state, {placement, overflows}];\n        if (!overflows.every(side => 0 >= side)) {\n          var _middlewareData$flip2, _overflowsData$filter;\n          _middlewareData$flip = ((null == (_middlewareData$flip2 = middlewareData.flip) ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n          if (_middlewareData$flip2 = isBasePlacement[_middlewareData$flip]) {\n            return {data:{index:_middlewareData$flip, overflows:state}, reset:{placement:_middlewareData$flip2}};\n          }\n          _middlewareData$flip2 = null == (_overflowsData$filter = state.filter(d => 0 >= d.overflows[0]).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) ? void 0 : _overflowsData$filter.placement;\n          if (!_middlewareData$flip2) {\n            switch(fallbackStrategy) {\n              case \"bestFit\":\n                var _overflowsData$map$so;\n                (_overflowsData$filter = null == (_overflowsData$map$so = state.map(d => [d.placement, d.overflows.filter(overflow => 0 < overflow).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) ? void 0 : _overflowsData$map$so[0]) && (_middlewareData$flip2 = _overflowsData$filter);\n                break;\n              case \"initialPlacement\":\n                _middlewareData$flip2 = initialPlacement;\n            }\n          }\n          if (placement !== _middlewareData$flip2) {\n            return {reset:{placement:_middlewareData$flip2}};\n          }\n        }\n        return {};\n      }};\n    };\n    exports.hide = function(options) {\n      void 0 === options && (options = {});\n      return {name:\"hide\", options, async fn(state) {\n        var {rects} = state;\n        const {strategy = \"referenceHidden\", ...detectOverflowOptions} = evaluate(options, state);\n        switch(strategy) {\n          case \"referenceHidden\":\n            return state = await detectOverflow(state, {...detectOverflowOptions, elementContext:\"reference\"}), rects = getSideOffsets(state, rects.reference), {data:{referenceHiddenOffsets:rects, referenceHidden:isAnySideFullyClipped(rects)}};\n          case \"escaped\":\n            return state = await detectOverflow(state, {...detectOverflowOptions, altBoundary:!0}), rects = getSideOffsets(state, rects.floating), {data:{escapedOffsets:rects, escaped:isAnySideFullyClipped(rects)}};\n          default:\n            return {};\n        }\n      }};\n    };\n    exports.inline = function(options) {\n      void 0 === options && (options = {});\n      return {name:\"inline\", options, async fn(state) {\n        const {placement, elements, rects, platform, strategy} = state, {padding = 2, x, y} = evaluate(options, state);\n        state = Array.from(await (null == platform.getClientRects ? void 0 : platform.getClientRects(elements.reference)) || []);\n        const clientRects = getRectsByLine(state), fallback = rectToClientRect(getBoundingRect(state)), paddingObject = getPaddingObject(padding);\n        state = await platform.getElementRects({reference:{getBoundingClientRect:function() {\n          if (2 === clientRects.length && clientRects[0].left > clientRects[1].right && null != x && null != y) {\n            return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n          }\n          if (2 <= clientRects.length) {\n            if (\"y\" === getSideAxis(placement)) {\n              var firstRect = clientRects[0];\n              const lastRect = clientRects[clientRects.length - 1], isTop = \"top\" === getSide(placement);\n              var top = firstRect.top, bottom = lastRect.bottom;\n              const left = isTop ? firstRect.left : lastRect.left;\n              firstRect = isTop ? firstRect.right : lastRect.right;\n              return {top, bottom, left, right:firstRect, width:firstRect - left, height:bottom - top, x:left, y:top};\n            }\n            const isLeftSide = \"left\" === getSide(placement), maxRight = max(...clientRects.map(rect => rect.right)), minLeft = min(...clientRects.map(rect => rect.left));\n            bottom = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n            top = bottom[0].top;\n            bottom = bottom[bottom.length - 1].bottom;\n            return {top, bottom, left:minLeft, right:maxRight, width:maxRight - minLeft, height:bottom - top, x:minLeft, y:top};\n          }\n          return fallback;\n        }}, floating:elements.floating, strategy});\n        return rects.reference.x !== state.reference.x || rects.reference.y !== state.reference.y || rects.reference.width !== state.reference.width || rects.reference.height !== state.reference.height ? {reset:{rects:state}} : {};\n      }};\n    };\n    exports.limitShift = function(options) {\n      void 0 === options && (options = {});\n      return {options, fn(state) {\n        const {x, y, placement, rects, middlewareData} = state, {offset = 0, mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !0} = evaluate(options, state);\n        var coords = {x, y};\n        const crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        coords = coords[crossAxis];\n        state = evaluate(offset, state);\n        state = \"number\" === typeof state ? {mainAxis:state, crossAxis:0} : {mainAxis:0, crossAxis:0, ...state};\n        if (checkMainAxis) {\n          var len$jscomp$0 = \"y\" === mainAxis ? \"height\" : \"width\", limitMin = rects.reference[mainAxis] - rects.floating[len$jscomp$0] + state.mainAxis;\n          len$jscomp$0 = rects.reference[mainAxis] + rects.reference[len$jscomp$0] - state.mainAxis;\n          mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > len$jscomp$0 && (mainAxisCoord = len$jscomp$0);\n        }\n        if (checkCrossAxis) {\n          var _middlewareData$offse, _middlewareData$offse2;\n          const len = \"y\" === mainAxis ? \"width\" : \"height\";\n          limitMin = [\"top\", \"left\"].includes(getSide(placement));\n          len$jscomp$0 = rects.reference[crossAxis] - rects.floating[len] + (limitMin ? (null == (_middlewareData$offse = middlewareData.offset) ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (limitMin ? 0 : state.crossAxis);\n          _middlewareData$offse = rects.reference[crossAxis] + rects.reference[len] + (limitMin ? 0 : (null == (_middlewareData$offse2 = middlewareData.offset) ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (limitMin ? state.crossAxis : 0);\n          coords < len$jscomp$0 ? coords = len$jscomp$0 : coords > _middlewareData$offse && (coords = _middlewareData$offse);\n        }\n        return {[mainAxis]:mainAxisCoord, [crossAxis]:coords};\n      }};\n    };\n    exports.offset = function(options) {\n      void 0 === options && (options = 0);\n      return {name:\"offset\", options, async fn(state) {\n        var _middlewareData$offse, _middlewareData$arrow;\n        const {x, y, placement, middlewareData} = state;\n        state = await convertValueToCoords(state, options);\n        return placement === (null == (_middlewareData$offse = middlewareData.offset) ? void 0 : _middlewareData$offse.placement) && null != (_middlewareData$arrow = middlewareData.arrow) && _middlewareData$arrow.alignmentOffset ? {} : {x:x + state.x, y:y + state.y, data:{...state, placement}};\n      }};\n    };\n    exports.rectToClientRect = rectToClientRect;\n    exports.shift = function(options) {\n      void 0 === options && (options = {});\n      return {name:\"shift\", options, async fn(state) {\n        const {x, y, placement} = state, {mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !1, limiter = {fn:_ref => {\n          let {x, y} = _ref;\n          return {x, y};\n        }}, ...detectOverflowOptions} = evaluate(options, state);\n        var coords = {x, y};\n        const overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        coords = coords[crossAxis];\n        checkMainAxis && (mainAxisCoord = max(mainAxisCoord + overflow[\"y\" === mainAxis ? \"top\" : \"left\"], min(mainAxisCoord, mainAxisCoord - overflow[\"y\" === mainAxis ? \"bottom\" : \"right\"])));\n        checkCrossAxis && (coords = max(coords + overflow[\"y\" === crossAxis ? \"top\" : \"left\"], min(coords, coords - overflow[\"y\" === crossAxis ? \"bottom\" : \"right\"])));\n        state = limiter.fn({...state, [mainAxis]:mainAxisCoord, [crossAxis]:coords});\n        return {...state, data:{x:state.x - x, y:state.y - y}};\n      }};\n    };\n    exports.size = function(options) {\n      void 0 === options && (options = {});\n      return {name:\"size\", options, async fn(state) {\n        const {placement, rects, platform, elements} = state, {apply = () => {\n        }, ...detectOverflowOptions} = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions);\n        var side = getSide(placement), alignment = getAlignment(placement);\n        const isYAxis = \"y\" === getSideAxis(placement), {width, height} = rects.floating;\n        if (\"top\" === side || \"bottom\" === side) {\n          var heightSide = side;\n          side = alignment === (await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n        } else {\n          heightSide = \"end\" === alignment ? \"top\" : \"bottom\";\n        }\n        var overflowAvailableHeight = height - overflow[heightSide], overflowAvailableWidth = width - overflow[side], noShift = !state.middlewareData.shift;\n        side = overflowAvailableHeight;\n        heightSide = overflowAvailableWidth;\n        isYAxis ? (heightSide = width - overflow.left - overflow.right, heightSide = alignment || noShift ? min(overflowAvailableWidth, heightSide) : heightSide) : (side = height - overflow.top - overflow.bottom, side = alignment || noShift ? min(overflowAvailableHeight, side) : side);\n        noShift && !alignment && (alignment = max(overflow.left, 0), overflowAvailableHeight = max(overflow.right, 0), noShift = max(overflow.top, 0), overflowAvailableWidth = max(overflow.bottom, 0), isYAxis ? heightSide = width - 2 * (0 !== alignment || 0 !== overflowAvailableHeight ? alignment + overflowAvailableHeight : max(overflow.left, overflow.right)) : side = height - 2 * (0 !== noShift || 0 !== overflowAvailableWidth ? noShift + overflowAvailableWidth : max(overflow.top, overflow.bottom)));\n        await apply({...state, availableWidth:heightSide, availableHeight:side});\n        state = await platform.getDimensions(elements.floating);\n        return width !== state.width || height !== state.height ? {reset:{rects:!0}} : {};\n      }};\n    };\n  });\n};\n","~:source","shadow$provide[\"module$node_modules$$floating_ui$core$dist$floating_ui_core_umd\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUICore = {}));\n})(this, (function (exports) { 'use strict';\n\n  /**\n   * Custom positioning reference element.\n   * @see https://floating-ui.com/docs/virtual-elements\n   */\n\n  const sides = ['top', 'right', 'bottom', 'left'];\n  const alignments = ['start', 'end'];\n  const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\n  const min = Math.min;\n  const max = Math.max;\n  const oppositeSideMap = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  const oppositeAlignmentMap = {\n    start: 'end',\n    end: 'start'\n  };\n  function clamp(start, value, end) {\n    return max(start, min(value, end));\n  }\n  function evaluate(value, param) {\n    return typeof value === 'function' ? value(param) : value;\n  }\n  function getSide(placement) {\n    return placement.split('-')[0];\n  }\n  function getAlignment(placement) {\n    return placement.split('-')[1];\n  }\n  function getOppositeAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function getAxisLength(axis) {\n    return axis === 'y' ? 'height' : 'width';\n  }\n  function getSideAxis(placement) {\n    return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n  }\n  function getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n  }\n  function getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n      rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n    if (rects.reference[length] > rects.floating[length]) {\n      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n  }\n  function getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n  }\n  function getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n  }\n  function getSideList(side, isStart, rtl) {\n    const lr = ['left', 'right'];\n    const rl = ['right', 'left'];\n    const tb = ['top', 'bottom'];\n    const bt = ['bottom', 'top'];\n    switch (side) {\n      case 'top':\n      case 'bottom':\n        if (rtl) return isStart ? rl : lr;\n        return isStart ? lr : rl;\n      case 'left':\n      case 'right':\n        return isStart ? tb : bt;\n      default:\n        return [];\n    }\n  }\n  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === 'start', rtl);\n    if (alignment) {\n      list = list.map(side => side + \"-\" + alignment);\n      if (flipAlignment) {\n        list = list.concat(list.map(getOppositeAlignmentPlacement));\n      }\n    }\n    return list;\n  }\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n  }\n  function expandPaddingObject(padding) {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...padding\n    };\n  }\n  function getPaddingObject(padding) {\n    return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n  }\n  function rectToClientRect(rect) {\n    return {\n      ...rect,\n      top: rect.y,\n      left: rect.x,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    };\n  }\n\n  function computeCoordsFromPlacement(_ref, placement, rtl) {\n    let {\n      reference,\n      floating\n    } = _ref;\n    const sideAxis = getSideAxis(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const alignLength = getAxisLength(alignmentAxis);\n    const side = getSide(placement);\n    const isVertical = sideAxis === 'y';\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch (side) {\n      case 'top':\n        coords = {\n          x: commonX,\n          y: reference.y - floating.height\n        };\n        break;\n      case 'bottom':\n        coords = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case 'right':\n        coords = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case 'left':\n        coords = {\n          x: reference.x - floating.width,\n          y: commonY\n        };\n        break;\n      default:\n        coords = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    switch (getAlignment(placement)) {\n      case 'start':\n        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n      case 'end':\n        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n    }\n    return coords;\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a given reference element.\n   *\n   * This export does not have any `platform` interface logic. You will need to\n   * write one for the platform you are using Floating UI with.\n   */\n  const computePosition = async (reference, floating, config) => {\n    const {\n      placement = 'bottom',\n      strategy = 'absolute',\n      middleware = [],\n      platform\n    } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n      reference,\n      floating,\n      strategy\n    });\n    let {\n      x,\n      y\n    } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for (let i = 0; i < validMiddleware.length; i++) {\n      const {\n        name,\n        fn\n      } = validMiddleware[i];\n      const {\n        x: nextX,\n        y: nextY,\n        data,\n        reset\n      } = await fn({\n        x,\n        y,\n        initialPlacement: placement,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData,\n        rects,\n        platform,\n        elements: {\n          reference,\n          floating\n        }\n      });\n      x = nextX != null ? nextX : x;\n      y = nextY != null ? nextY : y;\n      middlewareData = {\n        ...middlewareData,\n        [name]: {\n          ...middlewareData[name],\n          ...data\n        }\n      };\n      if (reset && resetCount <= 50) {\n        resetCount++;\n        if (typeof reset === 'object') {\n          if (reset.placement) {\n            statefulPlacement = reset.placement;\n          }\n          if (reset.rects) {\n            rects = reset.rects === true ? await platform.getElementRects({\n              reference,\n              floating,\n              strategy\n            }) : reset.rects;\n          }\n          ({\n            x,\n            y\n          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n        }\n        i = -1;\n      }\n    }\n    return {\n      x,\n      y,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData\n    };\n  };\n\n  /**\n   * Resolves with an object of overflow side offsets that determine how much the\n   * element is overflowing a given clipping boundary on each side.\n   * - positive = overflowing the boundary by that number of pixels\n   * - negative = how many pixels left before it will overflow\n   * - 0 = lies flush with the boundary\n   * @see https://floating-ui.com/docs/detectOverflow\n   */\n  async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      x,\n      y,\n      platform,\n      rects,\n      elements,\n      strategy\n    } = state;\n    const {\n      boundary = 'clippingAncestors',\n      rootBoundary = 'viewport',\n      elementContext = 'floating',\n      altBoundary = false,\n      padding = 0\n    } = evaluate(options, state);\n    const paddingObject = getPaddingObject(padding);\n    const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n      element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n      boundary,\n      rootBoundary,\n      strategy\n    }));\n    const rect = elementContext === 'floating' ? {\n      ...rects.floating,\n      x,\n      y\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    };\n    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n      elements,\n      rect,\n      offsetParent,\n      strategy\n    }) : rect);\n    return {\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n  }\n\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  const arrow = options => ({\n    name: 'arrow',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        platform,\n        elements,\n        middlewareData\n      } = state;\n      // Since `element` is required, we don't Partial<> the type.\n      const {\n        element,\n        padding = 0\n      } = evaluate(options, state) || {};\n      if (element == null) {\n        return {};\n      }\n      const paddingObject = getPaddingObject(padding);\n      const coords = {\n        x,\n        y\n      };\n      const axis = getAlignmentAxis(placement);\n      const length = getAxisLength(axis);\n      const arrowDimensions = await platform.getDimensions(element);\n      const isYAxis = axis === 'y';\n      const minProp = isYAxis ? 'top' : 'left';\n      const maxProp = isYAxis ? 'bottom' : 'right';\n      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n      const startDiff = coords[axis] - rects.reference[axis];\n      const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n      // DOM platform can return `window` as the `offsetParent`.\n      if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n        clientSize = elements.floating[clientProp] || rects.floating[length];\n      }\n      const centerToReference = endDiff / 2 - startDiff / 2;\n\n      // If the padding is large enough that it causes the arrow to no longer be\n      // centered, modify the padding so that it is centered.\n      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n      const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n      // Make sure the arrow doesn't overflow the floating element if the center\n      // point is outside the floating element's bounds.\n      const min$1 = minPadding;\n      const max = clientSize - arrowDimensions[length] - maxPadding;\n      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n      const offset = clamp(min$1, center, max);\n\n      // If the reference is small enough that the arrow's padding causes it to\n      // to point to nothing for an aligned placement, adjust the offset of the\n      // floating element itself. To ensure `shift()` continues to take action,\n      // a single reset is performed when this is true.\n      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n      return {\n        [axis]: coords[axis] + alignmentOffset,\n        data: {\n          [axis]: offset,\n          centerOffset: center - offset - alignmentOffset,\n          ...(shouldAddOffset && {\n            alignmentOffset\n          })\n        },\n        reset: shouldAddOffset\n      };\n    }\n  });\n\n  function getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter(placement => {\n      if (alignment) {\n        return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n      }\n      return true;\n    });\n  }\n  /**\n   * Optimizes the visibility of the floating element by choosing the placement\n   * that has the most space available automatically, without needing to specify a\n   * preferred placement. Alternative to `flip`.\n   * @see https://floating-ui.com/docs/autoPlacement\n   */\n  const autoPlacement = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'autoPlacement',\n      options,\n      async fn(state) {\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n        const {\n          rects,\n          middlewareData,\n          placement,\n          platform,\n          elements\n        } = state;\n        const {\n          crossAxis = false,\n          alignment,\n          allowedPlacements = placements,\n          autoAlignment = true,\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n        const overflow = await detectOverflow(state, detectOverflowOptions);\n        const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n        const currentPlacement = placements$1[currentIndex];\n        if (currentPlacement == null) {\n          return {};\n        }\n        const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n        // Make `computeCoords` start from the right place.\n        if (placement !== currentPlacement) {\n          return {\n            reset: {\n              placement: placements$1[0]\n            }\n          };\n        }\n        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n        const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n          placement: currentPlacement,\n          overflows: currentOverflows\n        }];\n        const nextPlacement = placements$1[currentIndex + 1];\n\n        // There are more placements to check.\n        if (nextPlacement) {\n          return {\n            data: {\n              index: currentIndex + 1,\n              overflows: allOverflows\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        const placementsSortedByMostSpace = allOverflows.map(d => {\n          const alignment = getAlignment(d.placement);\n          return [d.placement, alignment && crossAxis ?\n          // Check along the mainAxis and main crossAxis side.\n          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n          // Check only the mainAxis.\n          d.overflows[0], d.overflows];\n        }).sort((a, b) => a[1] - b[1]);\n        const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n        // Aligned placements should not check their opposite crossAxis\n        // side.\n        getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n        const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n        if (resetPlacement !== placement) {\n          return {\n            data: {\n              index: currentIndex + 1,\n              overflows: allOverflows\n            },\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n        return {};\n      }\n    };\n  };\n\n  /**\n   * Optimizes the visibility of the floating element by flipping the `placement`\n   * in order to keep it in view when the preferred placement(s) will overflow the\n   * clipping boundary. Alternative to `autoPlacement`.\n   * @see https://floating-ui.com/docs/flip\n   */\n  const flip = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'flip',\n      options,\n      async fn(state) {\n        var _middlewareData$arrow, _middlewareData$flip;\n        const {\n          placement,\n          middlewareData,\n          rects,\n          initialPlacement,\n          platform,\n          elements\n        } = state;\n        const {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = 'bestFit',\n          fallbackAxisSideDirection = 'none',\n          flipAlignment = true,\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n\n        // If a reset by the arrow was caused due to an alignment offset being\n        // added, we should skip any logic now since `flip()` has already done its\n        // work.\n        // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n          return {};\n        }\n        const side = getSide(placement);\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n        }\n        const placements = [initialPlacement, ...fallbackPlacements];\n        const overflow = await detectOverflow(state, detectOverflowOptions);\n        const overflows = [];\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n        if (checkMainAxis) {\n          overflows.push(overflow[side]);\n        }\n        if (checkCrossAxis) {\n          const sides = getAlignmentSides(placement, rects, rtl);\n          overflows.push(overflow[sides[0]], overflow[sides[1]]);\n        }\n        overflowsData = [...overflowsData, {\n          placement,\n          overflows\n        }];\n\n        // One or more sides is overflowing.\n        if (!overflows.every(side => side <= 0)) {\n          var _middlewareData$flip2, _overflowsData$filter;\n          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n          const nextPlacement = placements[nextIndex];\n          if (nextPlacement) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n\n          // First, find the candidates that fit on the mainAxis side of overflow,\n          // then find the placement that fits the best on the main crossAxis side.\n          let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n          // Otherwise fallback.\n          if (!resetPlacement) {\n            switch (fallbackStrategy) {\n              case 'bestFit':\n                {\n                  var _overflowsData$map$so;\n                  const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                  if (placement) {\n                    resetPlacement = placement;\n                  }\n                  break;\n                }\n              case 'initialPlacement':\n                resetPlacement = initialPlacement;\n                break;\n            }\n          }\n          if (placement !== resetPlacement) {\n            return {\n              reset: {\n                placement: resetPlacement\n              }\n            };\n          }\n        }\n        return {};\n      }\n    };\n  };\n\n  function getSideOffsets(overflow, rect) {\n    return {\n      top: overflow.top - rect.height,\n      right: overflow.right - rect.width,\n      bottom: overflow.bottom - rect.height,\n      left: overflow.left - rect.width\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return sides.some(side => overflow[side] >= 0);\n  }\n  /**\n   * Provides data to hide the floating element in applicable situations, such as\n   * when it is not in the same clipping context as the reference element.\n   * @see https://floating-ui.com/docs/hide\n   */\n  const hide = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'hide',\n      options,\n      async fn(state) {\n        const {\n          rects\n        } = state;\n        const {\n          strategy = 'referenceHidden',\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        switch (strategy) {\n          case 'referenceHidden':\n            {\n              const overflow = await detectOverflow(state, {\n                ...detectOverflowOptions,\n                elementContext: 'reference'\n              });\n              const offsets = getSideOffsets(overflow, rects.reference);\n              return {\n                data: {\n                  referenceHiddenOffsets: offsets,\n                  referenceHidden: isAnySideFullyClipped(offsets)\n                }\n              };\n            }\n          case 'escaped':\n            {\n              const overflow = await detectOverflow(state, {\n                ...detectOverflowOptions,\n                altBoundary: true\n              });\n              const offsets = getSideOffsets(overflow, rects.floating);\n              return {\n                data: {\n                  escapedOffsets: offsets,\n                  escaped: isAnySideFullyClipped(offsets)\n                }\n              };\n            }\n          default:\n            {\n              return {};\n            }\n        }\n      }\n    };\n  };\n\n  function getBoundingRect(rects) {\n    const minX = min(...rects.map(rect => rect.left));\n    const minY = min(...rects.map(rect => rect.top));\n    const maxX = max(...rects.map(rect => rect.right));\n    const maxY = max(...rects.map(rect => rect.bottom));\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n  function getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for (let i = 0; i < sortedRects.length; i++) {\n      const rect = sortedRects[i];\n      if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n        groups.push([rect]);\n      } else {\n        groups[groups.length - 1].push(rect);\n      }\n      prevRect = rect;\n    }\n    return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n  }\n  /**\n   * Provides improved positioning for inline reference elements that can span\n   * over multiple lines, such as hyperlinks or range selections.\n   * @see https://floating-ui.com/docs/inline\n   */\n  const inline = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'inline',\n      options,\n      async fn(state) {\n        const {\n          placement,\n          elements,\n          rects,\n          platform,\n          strategy\n        } = state;\n        // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n        // ClientRect's bounds, despite the event listener being triggered. A\n        // padding of 2 seems to handle this issue.\n        const {\n          padding = 2,\n          x,\n          y\n        } = evaluate(options, state);\n        const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n        const clientRects = getRectsByLine(nativeClientRects);\n        const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n        const paddingObject = getPaddingObject(padding);\n        function getBoundingClientRect() {\n          // There are two rects and they are disjoined.\n          if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n            // Find the first rect in which the point is fully inside.\n            return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n          }\n\n          // There are 2 or more connected rects.\n          if (clientRects.length >= 2) {\n            if (getSideAxis(placement) === 'y') {\n              const firstRect = clientRects[0];\n              const lastRect = clientRects[clientRects.length - 1];\n              const isTop = getSide(placement) === 'top';\n              const top = firstRect.top;\n              const bottom = lastRect.bottom;\n              const left = isTop ? firstRect.left : lastRect.left;\n              const right = isTop ? firstRect.right : lastRect.right;\n              const width = right - left;\n              const height = bottom - top;\n              return {\n                top,\n                bottom,\n                left,\n                right,\n                width,\n                height,\n                x: left,\n                y: top\n              };\n            }\n            const isLeftSide = getSide(placement) === 'left';\n            const maxRight = max(...clientRects.map(rect => rect.right));\n            const minLeft = min(...clientRects.map(rect => rect.left));\n            const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n            const top = measureRects[0].top;\n            const bottom = measureRects[measureRects.length - 1].bottom;\n            const left = minLeft;\n            const right = maxRight;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          return fallback;\n        }\n        const resetRects = await platform.getElementRects({\n          reference: {\n            getBoundingClientRect\n          },\n          floating: elements.floating,\n          strategy\n        });\n        if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n          return {\n            reset: {\n              rects: resetRects\n            }\n          };\n        }\n        return {};\n      }\n    };\n  };\n\n  // For type backwards-compatibility, the `OffsetOptions` type was also\n  // Derivable.\n\n  async function convertValueToCoords(state, options) {\n    const {\n      placement,\n      platform,\n      elements\n    } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = getSide(placement);\n    const alignment = getAlignment(placement);\n    const isVertical = getSideAxis(placement) === 'y';\n    const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = evaluate(options, state);\n    let {\n      mainAxis,\n      crossAxis,\n      alignmentAxis\n    } = typeof rawValue === 'number' ? {\n      mainAxis: rawValue,\n      crossAxis: 0,\n      alignmentAxis: null\n    } : {\n      mainAxis: 0,\n      crossAxis: 0,\n      alignmentAxis: null,\n      ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === 'number') {\n      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n      x: crossAxis * crossAxisMulti,\n      y: mainAxis * mainAxisMulti\n    } : {\n      x: mainAxis * mainAxisMulti,\n      y: crossAxis * crossAxisMulti\n    };\n  }\n\n  /**\n   * Modifies the placement by translating the floating element along the\n   * specified axes.\n   * A number (shorthand for `mainAxis` or distance), or an axes configuration\n   * object may be passed.\n   * @see https://floating-ui.com/docs/offset\n   */\n  const offset = function (options) {\n    if (options === void 0) {\n      options = 0;\n    }\n    return {\n      name: 'offset',\n      options,\n      async fn(state) {\n        var _middlewareData$offse, _middlewareData$arrow;\n        const {\n          x,\n          y,\n          placement,\n          middlewareData\n        } = state;\n        const diffCoords = await convertValueToCoords(state, options);\n\n        // If the placement is the same and the arrow caused an alignment offset\n        // then we don't need to change the positioning coordinates.\n        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n          return {};\n        }\n        return {\n          x: x + diffCoords.x,\n          y: y + diffCoords.y,\n          data: {\n            ...diffCoords,\n            placement\n          }\n        };\n      }\n    };\n  };\n\n  /**\n   * Optimizes the visibility of the floating element by shifting it in order to\n   * keep it in view when it will overflow the clipping boundary.\n   * @see https://floating-ui.com/docs/shift\n   */\n  const shift = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'shift',\n      options,\n      async fn(state) {\n        const {\n          x,\n          y,\n          placement\n        } = state;\n        const {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: _ref => {\n              let {\n                x,\n                y\n              } = _ref;\n              return {\n                x,\n                y\n              };\n            }\n          },\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const coords = {\n          x,\n          y\n        };\n        const overflow = await detectOverflow(state, detectOverflowOptions);\n        const crossAxis = getSideAxis(getSide(placement));\n        const mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n        if (checkMainAxis) {\n          const minSide = mainAxis === 'y' ? 'top' : 'left';\n          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n          const min = mainAxisCoord + overflow[minSide];\n          const max = mainAxisCoord - overflow[maxSide];\n          mainAxisCoord = clamp(min, mainAxisCoord, max);\n        }\n        if (checkCrossAxis) {\n          const minSide = crossAxis === 'y' ? 'top' : 'left';\n          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n          const min = crossAxisCoord + overflow[minSide];\n          const max = crossAxisCoord - overflow[maxSide];\n          crossAxisCoord = clamp(min, crossAxisCoord, max);\n        }\n        const limitedCoords = limiter.fn({\n          ...state,\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        });\n        return {\n          ...limitedCoords,\n          data: {\n            x: limitedCoords.x - x,\n            y: limitedCoords.y - y\n          }\n        };\n      }\n    };\n  };\n  /**\n   * Built-in `limiter` that will stop `shift()` at a certain point.\n   */\n  const limitShift = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      options,\n      fn(state) {\n        const {\n          x,\n          y,\n          placement,\n          rects,\n          middlewareData\n        } = state;\n        const {\n          offset = 0,\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true\n        } = evaluate(options, state);\n        const coords = {\n          x,\n          y\n        };\n        const crossAxis = getSideAxis(placement);\n        const mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n        const rawOffset = evaluate(offset, state);\n        const computedOffset = typeof rawOffset === 'number' ? {\n          mainAxis: rawOffset,\n          crossAxis: 0\n        } : {\n          mainAxis: 0,\n          crossAxis: 0,\n          ...rawOffset\n        };\n        if (checkMainAxis) {\n          const len = mainAxis === 'y' ? 'height' : 'width';\n          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n          if (mainAxisCoord < limitMin) {\n            mainAxisCoord = limitMin;\n          } else if (mainAxisCoord > limitMax) {\n            mainAxisCoord = limitMax;\n          }\n        }\n        if (checkCrossAxis) {\n          var _middlewareData$offse, _middlewareData$offse2;\n          const len = mainAxis === 'y' ? 'width' : 'height';\n          const isOriginSide = ['top', 'left'].includes(getSide(placement));\n          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n          if (crossAxisCoord < limitMin) {\n            crossAxisCoord = limitMin;\n          } else if (crossAxisCoord > limitMax) {\n            crossAxisCoord = limitMax;\n          }\n        }\n        return {\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        };\n      }\n    };\n  };\n\n  /**\n   * Provides data that allows you to change the size of the floating element \n   * for instance, prevent it from overflowing the clipping boundary or match the\n   * width of the reference element.\n   * @see https://floating-ui.com/docs/size\n   */\n  const size = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'size',\n      options,\n      async fn(state) {\n        const {\n          placement,\n          rects,\n          platform,\n          elements\n        } = state;\n        const {\n          apply = () => {},\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const overflow = await detectOverflow(state, detectOverflowOptions);\n        const side = getSide(placement);\n        const alignment = getAlignment(placement);\n        const isYAxis = getSideAxis(placement) === 'y';\n        const {\n          width,\n          height\n        } = rects.floating;\n        let heightSide;\n        let widthSide;\n        if (side === 'top' || side === 'bottom') {\n          heightSide = side;\n          widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n        } else {\n          widthSide = side;\n          heightSide = alignment === 'end' ? 'top' : 'bottom';\n        }\n        const overflowAvailableHeight = height - overflow[heightSide];\n        const overflowAvailableWidth = width - overflow[widthSide];\n        const noShift = !state.middlewareData.shift;\n        let availableHeight = overflowAvailableHeight;\n        let availableWidth = overflowAvailableWidth;\n        if (isYAxis) {\n          const maximumClippingWidth = width - overflow.left - overflow.right;\n          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n        } else {\n          const maximumClippingHeight = height - overflow.top - overflow.bottom;\n          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n        }\n        if (noShift && !alignment) {\n          const xMin = max(overflow.left, 0);\n          const xMax = max(overflow.right, 0);\n          const yMin = max(overflow.top, 0);\n          const yMax = max(overflow.bottom, 0);\n          if (isYAxis) {\n            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n          } else {\n            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n          }\n        }\n        await apply({\n          ...state,\n          availableWidth,\n          availableHeight\n        });\n        const nextDimensions = await platform.getDimensions(elements.floating);\n        if (width !== nextDimensions.width || height !== nextDimensions.height) {\n          return {\n            reset: {\n              rects: true\n            }\n          };\n        }\n        return {};\n      }\n    };\n  };\n\n  exports.arrow = arrow;\n  exports.autoPlacement = autoPlacement;\n  exports.computePosition = computePosition;\n  exports.detectOverflow = detectOverflow;\n  exports.flip = flip;\n  exports.hide = hide;\n  exports.inline = inline;\n  exports.limitShift = limitShift;\n  exports.offset = offset;\n  exports.rectToClientRect = rectToClientRect;\n  exports.shift = shift;\n  exports.size = size;\n\n}));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["width","referenceHiddenOffsets","right","top","hide","index","strategy","offset","height","arrow","rectToClientRect","mainAxis","getBoundingClientRect","inline","offsetParent","placement","x","alignmentAxis","availableWidth","fn","crossAxis","reset","flip","limitShift","referenceHidden","floating","element","name","initialPlacement","shift","boundary","middlewareData","availableHeight","start","rects","alignmentOffset","overflows","escaped","reference","rootBoundary","y","computePosition","centerOffset","elementContext","FloatingUICore","bottom","rect","size","options","data","platform","altBoundary","end","elements","left","detectOverflow","autoPlacement","escapedOffsets"]],"~:compiled-at",1712152511117,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$floating_ui$core$dist$floating_ui_core_umd.js\",\n\"lineCount\":379,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@floating-ui/core/dist/floating-ui.core.umd.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$floating_ui$core$dist$floating_ui_core_umd\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUICore = {}));\\n})(this, (function (exports) { 'use strict';\\n\\n  /**\\n   * Custom positioning reference element.\\n   * @see https://floating-ui.com/docs/virtual-elements\\n   */\\n\\n  const sides = ['top', 'right', 'bottom', 'left'];\\n  const alignments = ['start', 'end'];\\n  const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \\\"-\\\" + alignments[0], side + \\\"-\\\" + alignments[1]), []);\\n  const min = Math.min;\\n  const max = Math.max;\\n  const oppositeSideMap = {\\n    left: 'right',\\n    right: 'left',\\n    bottom: 'top',\\n    top: 'bottom'\\n  };\\n  const oppositeAlignmentMap = {\\n    start: 'end',\\n    end: 'start'\\n  };\\n  function clamp(start, value, end) {\\n    return max(start, min(value, end));\\n  }\\n  function evaluate(value, param) {\\n    return typeof value === 'function' ? value(param) : value;\\n  }\\n  function getSide(placement) {\\n    return placement.split('-')[0];\\n  }\\n  function getAlignment(placement) {\\n    return placement.split('-')[1];\\n  }\\n  function getOppositeAxis(axis) {\\n    return axis === 'x' ? 'y' : 'x';\\n  }\\n  function getAxisLength(axis) {\\n    return axis === 'y' ? 'height' : 'width';\\n  }\\n  function getSideAxis(placement) {\\n    return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\\n  }\\n  function getAlignmentAxis(placement) {\\n    return getOppositeAxis(getSideAxis(placement));\\n  }\\n  function getAlignmentSides(placement, rects, rtl) {\\n    if (rtl === void 0) {\\n      rtl = false;\\n    }\\n    const alignment = getAlignment(placement);\\n    const alignmentAxis = getAlignmentAxis(placement);\\n    const length = getAxisLength(alignmentAxis);\\n    let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\\n    if (rects.reference[length] > rects.floating[length]) {\\n      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\\n    }\\n    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\\n  }\\n  function getExpandedPlacements(placement) {\\n    const oppositePlacement = getOppositePlacement(placement);\\n    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\\n  }\\n  function getOppositeAlignmentPlacement(placement) {\\n    return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\\n  }\\n  function getSideList(side, isStart, rtl) {\\n    const lr = ['left', 'right'];\\n    const rl = ['right', 'left'];\\n    const tb = ['top', 'bottom'];\\n    const bt = ['bottom', 'top'];\\n    switch (side) {\\n      case 'top':\\n      case 'bottom':\\n        if (rtl) return isStart ? rl : lr;\\n        return isStart ? lr : rl;\\n      case 'left':\\n      case 'right':\\n        return isStart ? tb : bt;\\n      default:\\n        return [];\\n    }\\n  }\\n  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\\n    const alignment = getAlignment(placement);\\n    let list = getSideList(getSide(placement), direction === 'start', rtl);\\n    if (alignment) {\\n      list = list.map(side => side + \\\"-\\\" + alignment);\\n      if (flipAlignment) {\\n        list = list.concat(list.map(getOppositeAlignmentPlacement));\\n      }\\n    }\\n    return list;\\n  }\\n  function getOppositePlacement(placement) {\\n    return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\\n  }\\n  function expandPaddingObject(padding) {\\n    return {\\n      top: 0,\\n      right: 0,\\n      bottom: 0,\\n      left: 0,\\n      ...padding\\n    };\\n  }\\n  function getPaddingObject(padding) {\\n    return typeof padding !== 'number' ? expandPaddingObject(padding) : {\\n      top: padding,\\n      right: padding,\\n      bottom: padding,\\n      left: padding\\n    };\\n  }\\n  function rectToClientRect(rect) {\\n    return {\\n      ...rect,\\n      top: rect.y,\\n      left: rect.x,\\n      right: rect.x + rect.width,\\n      bottom: rect.y + rect.height\\n    };\\n  }\\n\\n  function computeCoordsFromPlacement(_ref, placement, rtl) {\\n    let {\\n      reference,\\n      floating\\n    } = _ref;\\n    const sideAxis = getSideAxis(placement);\\n    const alignmentAxis = getAlignmentAxis(placement);\\n    const alignLength = getAxisLength(alignmentAxis);\\n    const side = getSide(placement);\\n    const isVertical = sideAxis === 'y';\\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\\n    let coords;\\n    switch (side) {\\n      case 'top':\\n        coords = {\\n          x: commonX,\\n          y: reference.y - floating.height\\n        };\\n        break;\\n      case 'bottom':\\n        coords = {\\n          x: commonX,\\n          y: reference.y + reference.height\\n        };\\n        break;\\n      case 'right':\\n        coords = {\\n          x: reference.x + reference.width,\\n          y: commonY\\n        };\\n        break;\\n      case 'left':\\n        coords = {\\n          x: reference.x - floating.width,\\n          y: commonY\\n        };\\n        break;\\n      default:\\n        coords = {\\n          x: reference.x,\\n          y: reference.y\\n        };\\n    }\\n    switch (getAlignment(placement)) {\\n      case 'start':\\n        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\\n        break;\\n      case 'end':\\n        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\\n        break;\\n    }\\n    return coords;\\n  }\\n\\n  /**\\n   * Computes the `x` and `y` coordinates that will place the floating element\\n   * next to a given reference element.\\n   *\\n   * This export does not have any `platform` interface logic. You will need to\\n   * write one for the platform you are using Floating UI with.\\n   */\\n  const computePosition = async (reference, floating, config) => {\\n    const {\\n      placement = 'bottom',\\n      strategy = 'absolute',\\n      middleware = [],\\n      platform\\n    } = config;\\n    const validMiddleware = middleware.filter(Boolean);\\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\\n    let rects = await platform.getElementRects({\\n      reference,\\n      floating,\\n      strategy\\n    });\\n    let {\\n      x,\\n      y\\n    } = computeCoordsFromPlacement(rects, placement, rtl);\\n    let statefulPlacement = placement;\\n    let middlewareData = {};\\n    let resetCount = 0;\\n    for (let i = 0; i < validMiddleware.length; i++) {\\n      const {\\n        name,\\n        fn\\n      } = validMiddleware[i];\\n      const {\\n        x: nextX,\\n        y: nextY,\\n        data,\\n        reset\\n      } = await fn({\\n        x,\\n        y,\\n        initialPlacement: placement,\\n        placement: statefulPlacement,\\n        strategy,\\n        middlewareData,\\n        rects,\\n        platform,\\n        elements: {\\n          reference,\\n          floating\\n        }\\n      });\\n      x = nextX != null ? nextX : x;\\n      y = nextY != null ? nextY : y;\\n      middlewareData = {\\n        ...middlewareData,\\n        [name]: {\\n          ...middlewareData[name],\\n          ...data\\n        }\\n      };\\n      if (reset && resetCount <= 50) {\\n        resetCount++;\\n        if (typeof reset === 'object') {\\n          if (reset.placement) {\\n            statefulPlacement = reset.placement;\\n          }\\n          if (reset.rects) {\\n            rects = reset.rects === true ? await platform.getElementRects({\\n              reference,\\n              floating,\\n              strategy\\n            }) : reset.rects;\\n          }\\n          ({\\n            x,\\n            y\\n          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\\n        }\\n        i = -1;\\n      }\\n    }\\n    return {\\n      x,\\n      y,\\n      placement: statefulPlacement,\\n      strategy,\\n      middlewareData\\n    };\\n  };\\n\\n  /**\\n   * Resolves with an object of overflow side offsets that determine how much the\\n   * element is overflowing a given clipping boundary on each side.\\n   * - positive = overflowing the boundary by that number of pixels\\n   * - negative = how many pixels left before it will overflow\\n   * - 0 = lies flush with the boundary\\n   * @see https://floating-ui.com/docs/detectOverflow\\n   */\\n  async function detectOverflow(state, options) {\\n    var _await$platform$isEle;\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    const {\\n      x,\\n      y,\\n      platform,\\n      rects,\\n      elements,\\n      strategy\\n    } = state;\\n    const {\\n      boundary = 'clippingAncestors',\\n      rootBoundary = 'viewport',\\n      elementContext = 'floating',\\n      altBoundary = false,\\n      padding = 0\\n    } = evaluate(options, state);\\n    const paddingObject = getPaddingObject(padding);\\n    const altContext = elementContext === 'floating' ? 'reference' : 'floating';\\n    const element = elements[altBoundary ? altContext : elementContext];\\n    const clippingClientRect = rectToClientRect(await platform.getClippingRect({\\n      element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\\n      boundary,\\n      rootBoundary,\\n      strategy\\n    }));\\n    const rect = elementContext === 'floating' ? {\\n      ...rects.floating,\\n      x,\\n      y\\n    } : rects.reference;\\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\\n    const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\\n      x: 1,\\n      y: 1\\n    } : {\\n      x: 1,\\n      y: 1\\n    };\\n    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\\n      elements,\\n      rect,\\n      offsetParent,\\n      strategy\\n    }) : rect);\\n    return {\\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\\n    };\\n  }\\n\\n  /**\\n   * Provides data to position an inner element of the floating element so that it\\n   * appears centered to the reference element.\\n   * @see https://floating-ui.com/docs/arrow\\n   */\\n  const arrow = options => ({\\n    name: 'arrow',\\n    options,\\n    async fn(state) {\\n      const {\\n        x,\\n        y,\\n        placement,\\n        rects,\\n        platform,\\n        elements,\\n        middlewareData\\n      } = state;\\n      // Since `element` is required, we don't Partial<> the type.\\n      const {\\n        element,\\n        padding = 0\\n      } = evaluate(options, state) || {};\\n      if (element == null) {\\n        return {};\\n      }\\n      const paddingObject = getPaddingObject(padding);\\n      const coords = {\\n        x,\\n        y\\n      };\\n      const axis = getAlignmentAxis(placement);\\n      const length = getAxisLength(axis);\\n      const arrowDimensions = await platform.getDimensions(element);\\n      const isYAxis = axis === 'y';\\n      const minProp = isYAxis ? 'top' : 'left';\\n      const maxProp = isYAxis ? 'bottom' : 'right';\\n      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\\n      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\\n      const startDiff = coords[axis] - rects.reference[axis];\\n      const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\\n      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\\n\\n      // DOM platform can return `window` as the `offsetParent`.\\n      if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\\n        clientSize = elements.floating[clientProp] || rects.floating[length];\\n      }\\n      const centerToReference = endDiff / 2 - startDiff / 2;\\n\\n      // If the padding is large enough that it causes the arrow to no longer be\\n      // centered, modify the padding so that it is centered.\\n      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\\n      const minPadding = min(paddingObject[minProp], largestPossiblePadding);\\n      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\\n\\n      // Make sure the arrow doesn't overflow the floating element if the center\\n      // point is outside the floating element's bounds.\\n      const min$1 = minPadding;\\n      const max = clientSize - arrowDimensions[length] - maxPadding;\\n      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\\n      const offset = clamp(min$1, center, max);\\n\\n      // If the reference is small enough that the arrow's padding causes it to\\n      // to point to nothing for an aligned placement, adjust the offset of the\\n      // floating element itself. To ensure `shift()` continues to take action,\\n      // a single reset is performed when this is true.\\n      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\\n      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\\n      return {\\n        [axis]: coords[axis] + alignmentOffset,\\n        data: {\\n          [axis]: offset,\\n          centerOffset: center - offset - alignmentOffset,\\n          ...(shouldAddOffset && {\\n            alignmentOffset\\n          })\\n        },\\n        reset: shouldAddOffset\\n      };\\n    }\\n  });\\n\\n  function getPlacementList(alignment, autoAlignment, allowedPlacements) {\\n    const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\\n    return allowedPlacementsSortedByAlignment.filter(placement => {\\n      if (alignment) {\\n        return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\\n      }\\n      return true;\\n    });\\n  }\\n  /**\\n   * Optimizes the visibility of the floating element by choosing the placement\\n   * that has the most space available automatically, without needing to specify a\\n   * preferred placement. Alternative to `flip`.\\n   * @see https://floating-ui.com/docs/autoPlacement\\n   */\\n  const autoPlacement = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      name: 'autoPlacement',\\n      options,\\n      async fn(state) {\\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\\n        const {\\n          rects,\\n          middlewareData,\\n          placement,\\n          platform,\\n          elements\\n        } = state;\\n        const {\\n          crossAxis = false,\\n          alignment,\\n          allowedPlacements = placements,\\n          autoAlignment = true,\\n          ...detectOverflowOptions\\n        } = evaluate(options, state);\\n        const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\\n        const overflow = await detectOverflow(state, detectOverflowOptions);\\n        const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\\n        const currentPlacement = placements$1[currentIndex];\\n        if (currentPlacement == null) {\\n          return {};\\n        }\\n        const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\\n\\n        // Make `computeCoords` start from the right place.\\n        if (placement !== currentPlacement) {\\n          return {\\n            reset: {\\n              placement: placements$1[0]\\n            }\\n          };\\n        }\\n        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\\n        const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\\n          placement: currentPlacement,\\n          overflows: currentOverflows\\n        }];\\n        const nextPlacement = placements$1[currentIndex + 1];\\n\\n        // There are more placements to check.\\n        if (nextPlacement) {\\n          return {\\n            data: {\\n              index: currentIndex + 1,\\n              overflows: allOverflows\\n            },\\n            reset: {\\n              placement: nextPlacement\\n            }\\n          };\\n        }\\n        const placementsSortedByMostSpace = allOverflows.map(d => {\\n          const alignment = getAlignment(d.placement);\\n          return [d.placement, alignment && crossAxis ?\\n          // Check along the mainAxis and main crossAxis side.\\n          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\\n          // Check only the mainAxis.\\n          d.overflows[0], d.overflows];\\n        }).sort((a, b) => a[1] - b[1]);\\n        const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\\n        // Aligned placements should not check their opposite crossAxis\\n        // side.\\n        getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\\n        const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\\n        if (resetPlacement !== placement) {\\n          return {\\n            data: {\\n              index: currentIndex + 1,\\n              overflows: allOverflows\\n            },\\n            reset: {\\n              placement: resetPlacement\\n            }\\n          };\\n        }\\n        return {};\\n      }\\n    };\\n  };\\n\\n  /**\\n   * Optimizes the visibility of the floating element by flipping the `placement`\\n   * in order to keep it in view when the preferred placement(s) will overflow the\\n   * clipping boundary. Alternative to `autoPlacement`.\\n   * @see https://floating-ui.com/docs/flip\\n   */\\n  const flip = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      name: 'flip',\\n      options,\\n      async fn(state) {\\n        var _middlewareData$arrow, _middlewareData$flip;\\n        const {\\n          placement,\\n          middlewareData,\\n          rects,\\n          initialPlacement,\\n          platform,\\n          elements\\n        } = state;\\n        const {\\n          mainAxis: checkMainAxis = true,\\n          crossAxis: checkCrossAxis = true,\\n          fallbackPlacements: specifiedFallbackPlacements,\\n          fallbackStrategy = 'bestFit',\\n          fallbackAxisSideDirection = 'none',\\n          flipAlignment = true,\\n          ...detectOverflowOptions\\n        } = evaluate(options, state);\\n\\n        // If a reset by the arrow was caused due to an alignment offset being\\n        // added, we should skip any logic now since `flip()` has already done its\\n        // work.\\n        // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\\n        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\\n          return {};\\n        }\\n        const side = getSide(placement);\\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\\n        const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\\n        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\\n          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\\n        }\\n        const placements = [initialPlacement, ...fallbackPlacements];\\n        const overflow = await detectOverflow(state, detectOverflowOptions);\\n        const overflows = [];\\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\\n        if (checkMainAxis) {\\n          overflows.push(overflow[side]);\\n        }\\n        if (checkCrossAxis) {\\n          const sides = getAlignmentSides(placement, rects, rtl);\\n          overflows.push(overflow[sides[0]], overflow[sides[1]]);\\n        }\\n        overflowsData = [...overflowsData, {\\n          placement,\\n          overflows\\n        }];\\n\\n        // One or more sides is overflowing.\\n        if (!overflows.every(side => side <= 0)) {\\n          var _middlewareData$flip2, _overflowsData$filter;\\n          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\\n          const nextPlacement = placements[nextIndex];\\n          if (nextPlacement) {\\n            // Try next placement and re-run the lifecycle.\\n            return {\\n              data: {\\n                index: nextIndex,\\n                overflows: overflowsData\\n              },\\n              reset: {\\n                placement: nextPlacement\\n              }\\n            };\\n          }\\n\\n          // First, find the candidates that fit on the mainAxis side of overflow,\\n          // then find the placement that fits the best on the main crossAxis side.\\n          let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\\n\\n          // Otherwise fallback.\\n          if (!resetPlacement) {\\n            switch (fallbackStrategy) {\\n              case 'bestFit':\\n                {\\n                  var _overflowsData$map$so;\\n                  const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\\n                  if (placement) {\\n                    resetPlacement = placement;\\n                  }\\n                  break;\\n                }\\n              case 'initialPlacement':\\n                resetPlacement = initialPlacement;\\n                break;\\n            }\\n          }\\n          if (placement !== resetPlacement) {\\n            return {\\n              reset: {\\n                placement: resetPlacement\\n              }\\n            };\\n          }\\n        }\\n        return {};\\n      }\\n    };\\n  };\\n\\n  function getSideOffsets(overflow, rect) {\\n    return {\\n      top: overflow.top - rect.height,\\n      right: overflow.right - rect.width,\\n      bottom: overflow.bottom - rect.height,\\n      left: overflow.left - rect.width\\n    };\\n  }\\n  function isAnySideFullyClipped(overflow) {\\n    return sides.some(side => overflow[side] >= 0);\\n  }\\n  /**\\n   * Provides data to hide the floating element in applicable situations, such as\\n   * when it is not in the same clipping context as the reference element.\\n   * @see https://floating-ui.com/docs/hide\\n   */\\n  const hide = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      name: 'hide',\\n      options,\\n      async fn(state) {\\n        const {\\n          rects\\n        } = state;\\n        const {\\n          strategy = 'referenceHidden',\\n          ...detectOverflowOptions\\n        } = evaluate(options, state);\\n        switch (strategy) {\\n          case 'referenceHidden':\\n            {\\n              const overflow = await detectOverflow(state, {\\n                ...detectOverflowOptions,\\n                elementContext: 'reference'\\n              });\\n              const offsets = getSideOffsets(overflow, rects.reference);\\n              return {\\n                data: {\\n                  referenceHiddenOffsets: offsets,\\n                  referenceHidden: isAnySideFullyClipped(offsets)\\n                }\\n              };\\n            }\\n          case 'escaped':\\n            {\\n              const overflow = await detectOverflow(state, {\\n                ...detectOverflowOptions,\\n                altBoundary: true\\n              });\\n              const offsets = getSideOffsets(overflow, rects.floating);\\n              return {\\n                data: {\\n                  escapedOffsets: offsets,\\n                  escaped: isAnySideFullyClipped(offsets)\\n                }\\n              };\\n            }\\n          default:\\n            {\\n              return {};\\n            }\\n        }\\n      }\\n    };\\n  };\\n\\n  function getBoundingRect(rects) {\\n    const minX = min(...rects.map(rect => rect.left));\\n    const minY = min(...rects.map(rect => rect.top));\\n    const maxX = max(...rects.map(rect => rect.right));\\n    const maxY = max(...rects.map(rect => rect.bottom));\\n    return {\\n      x: minX,\\n      y: minY,\\n      width: maxX - minX,\\n      height: maxY - minY\\n    };\\n  }\\n  function getRectsByLine(rects) {\\n    const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\\n    const groups = [];\\n    let prevRect = null;\\n    for (let i = 0; i < sortedRects.length; i++) {\\n      const rect = sortedRects[i];\\n      if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\\n        groups.push([rect]);\\n      } else {\\n        groups[groups.length - 1].push(rect);\\n      }\\n      prevRect = rect;\\n    }\\n    return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\\n  }\\n  /**\\n   * Provides improved positioning for inline reference elements that can span\\n   * over multiple lines, such as hyperlinks or range selections.\\n   * @see https://floating-ui.com/docs/inline\\n   */\\n  const inline = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      name: 'inline',\\n      options,\\n      async fn(state) {\\n        const {\\n          placement,\\n          elements,\\n          rects,\\n          platform,\\n          strategy\\n        } = state;\\n        // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\\n        // ClientRect's bounds, despite the event listener being triggered. A\\n        // padding of 2 seems to handle this issue.\\n        const {\\n          padding = 2,\\n          x,\\n          y\\n        } = evaluate(options, state);\\n        const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\\n        const clientRects = getRectsByLine(nativeClientRects);\\n        const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\\n        const paddingObject = getPaddingObject(padding);\\n        function getBoundingClientRect() {\\n          // There are two rects and they are disjoined.\\n          if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\\n            // Find the first rect in which the point is fully inside.\\n            return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\\n          }\\n\\n          // There are 2 or more connected rects.\\n          if (clientRects.length >= 2) {\\n            if (getSideAxis(placement) === 'y') {\\n              const firstRect = clientRects[0];\\n              const lastRect = clientRects[clientRects.length - 1];\\n              const isTop = getSide(placement) === 'top';\\n              const top = firstRect.top;\\n              const bottom = lastRect.bottom;\\n              const left = isTop ? firstRect.left : lastRect.left;\\n              const right = isTop ? firstRect.right : lastRect.right;\\n              const width = right - left;\\n              const height = bottom - top;\\n              return {\\n                top,\\n                bottom,\\n                left,\\n                right,\\n                width,\\n                height,\\n                x: left,\\n                y: top\\n              };\\n            }\\n            const isLeftSide = getSide(placement) === 'left';\\n            const maxRight = max(...clientRects.map(rect => rect.right));\\n            const minLeft = min(...clientRects.map(rect => rect.left));\\n            const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\\n            const top = measureRects[0].top;\\n            const bottom = measureRects[measureRects.length - 1].bottom;\\n            const left = minLeft;\\n            const right = maxRight;\\n            const width = right - left;\\n            const height = bottom - top;\\n            return {\\n              top,\\n              bottom,\\n              left,\\n              right,\\n              width,\\n              height,\\n              x: left,\\n              y: top\\n            };\\n          }\\n          return fallback;\\n        }\\n        const resetRects = await platform.getElementRects({\\n          reference: {\\n            getBoundingClientRect\\n          },\\n          floating: elements.floating,\\n          strategy\\n        });\\n        if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\\n          return {\\n            reset: {\\n              rects: resetRects\\n            }\\n          };\\n        }\\n        return {};\\n      }\\n    };\\n  };\\n\\n  // For type backwards-compatibility, the `OffsetOptions` type was also\\n  // Derivable.\\n\\n  async function convertValueToCoords(state, options) {\\n    const {\\n      placement,\\n      platform,\\n      elements\\n    } = state;\\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\\n    const side = getSide(placement);\\n    const alignment = getAlignment(placement);\\n    const isVertical = getSideAxis(placement) === 'y';\\n    const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\\n    const rawValue = evaluate(options, state);\\n    let {\\n      mainAxis,\\n      crossAxis,\\n      alignmentAxis\\n    } = typeof rawValue === 'number' ? {\\n      mainAxis: rawValue,\\n      crossAxis: 0,\\n      alignmentAxis: null\\n    } : {\\n      mainAxis: 0,\\n      crossAxis: 0,\\n      alignmentAxis: null,\\n      ...rawValue\\n    };\\n    if (alignment && typeof alignmentAxis === 'number') {\\n      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\\n    }\\n    return isVertical ? {\\n      x: crossAxis * crossAxisMulti,\\n      y: mainAxis * mainAxisMulti\\n    } : {\\n      x: mainAxis * mainAxisMulti,\\n      y: crossAxis * crossAxisMulti\\n    };\\n  }\\n\\n  /**\\n   * Modifies the placement by translating the floating element along the\\n   * specified axes.\\n   * A number (shorthand for `mainAxis` or distance), or an axes configuration\\n   * object may be passed.\\n   * @see https://floating-ui.com/docs/offset\\n   */\\n  const offset = function (options) {\\n    if (options === void 0) {\\n      options = 0;\\n    }\\n    return {\\n      name: 'offset',\\n      options,\\n      async fn(state) {\\n        var _middlewareData$offse, _middlewareData$arrow;\\n        const {\\n          x,\\n          y,\\n          placement,\\n          middlewareData\\n        } = state;\\n        const diffCoords = await convertValueToCoords(state, options);\\n\\n        // If the placement is the same and the arrow caused an alignment offset\\n        // then we don't need to change the positioning coordinates.\\n        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\\n          return {};\\n        }\\n        return {\\n          x: x + diffCoords.x,\\n          y: y + diffCoords.y,\\n          data: {\\n            ...diffCoords,\\n            placement\\n          }\\n        };\\n      }\\n    };\\n  };\\n\\n  /**\\n   * Optimizes the visibility of the floating element by shifting it in order to\\n   * keep it in view when it will overflow the clipping boundary.\\n   * @see https://floating-ui.com/docs/shift\\n   */\\n  const shift = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      name: 'shift',\\n      options,\\n      async fn(state) {\\n        const {\\n          x,\\n          y,\\n          placement\\n        } = state;\\n        const {\\n          mainAxis: checkMainAxis = true,\\n          crossAxis: checkCrossAxis = false,\\n          limiter = {\\n            fn: _ref => {\\n              let {\\n                x,\\n                y\\n              } = _ref;\\n              return {\\n                x,\\n                y\\n              };\\n            }\\n          },\\n          ...detectOverflowOptions\\n        } = evaluate(options, state);\\n        const coords = {\\n          x,\\n          y\\n        };\\n        const overflow = await detectOverflow(state, detectOverflowOptions);\\n        const crossAxis = getSideAxis(getSide(placement));\\n        const mainAxis = getOppositeAxis(crossAxis);\\n        let mainAxisCoord = coords[mainAxis];\\n        let crossAxisCoord = coords[crossAxis];\\n        if (checkMainAxis) {\\n          const minSide = mainAxis === 'y' ? 'top' : 'left';\\n          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\\n          const min = mainAxisCoord + overflow[minSide];\\n          const max = mainAxisCoord - overflow[maxSide];\\n          mainAxisCoord = clamp(min, mainAxisCoord, max);\\n        }\\n        if (checkCrossAxis) {\\n          const minSide = crossAxis === 'y' ? 'top' : 'left';\\n          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\\n          const min = crossAxisCoord + overflow[minSide];\\n          const max = crossAxisCoord - overflow[maxSide];\\n          crossAxisCoord = clamp(min, crossAxisCoord, max);\\n        }\\n        const limitedCoords = limiter.fn({\\n          ...state,\\n          [mainAxis]: mainAxisCoord,\\n          [crossAxis]: crossAxisCoord\\n        });\\n        return {\\n          ...limitedCoords,\\n          data: {\\n            x: limitedCoords.x - x,\\n            y: limitedCoords.y - y\\n          }\\n        };\\n      }\\n    };\\n  };\\n  /**\\n   * Built-in `limiter` that will stop `shift()` at a certain point.\\n   */\\n  const limitShift = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      options,\\n      fn(state) {\\n        const {\\n          x,\\n          y,\\n          placement,\\n          rects,\\n          middlewareData\\n        } = state;\\n        const {\\n          offset = 0,\\n          mainAxis: checkMainAxis = true,\\n          crossAxis: checkCrossAxis = true\\n        } = evaluate(options, state);\\n        const coords = {\\n          x,\\n          y\\n        };\\n        const crossAxis = getSideAxis(placement);\\n        const mainAxis = getOppositeAxis(crossAxis);\\n        let mainAxisCoord = coords[mainAxis];\\n        let crossAxisCoord = coords[crossAxis];\\n        const rawOffset = evaluate(offset, state);\\n        const computedOffset = typeof rawOffset === 'number' ? {\\n          mainAxis: rawOffset,\\n          crossAxis: 0\\n        } : {\\n          mainAxis: 0,\\n          crossAxis: 0,\\n          ...rawOffset\\n        };\\n        if (checkMainAxis) {\\n          const len = mainAxis === 'y' ? 'height' : 'width';\\n          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\\n          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\\n          if (mainAxisCoord < limitMin) {\\n            mainAxisCoord = limitMin;\\n          } else if (mainAxisCoord > limitMax) {\\n            mainAxisCoord = limitMax;\\n          }\\n        }\\n        if (checkCrossAxis) {\\n          var _middlewareData$offse, _middlewareData$offse2;\\n          const len = mainAxis === 'y' ? 'width' : 'height';\\n          const isOriginSide = ['top', 'left'].includes(getSide(placement));\\n          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\\n          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\\n          if (crossAxisCoord < limitMin) {\\n            crossAxisCoord = limitMin;\\n          } else if (crossAxisCoord > limitMax) {\\n            crossAxisCoord = limitMax;\\n          }\\n        }\\n        return {\\n          [mainAxis]: mainAxisCoord,\\n          [crossAxis]: crossAxisCoord\\n        };\\n      }\\n    };\\n  };\\n\\n  /**\\n   * Provides data that allows you to change the size of the floating element \\u2014\\n   * for instance, prevent it from overflowing the clipping boundary or match the\\n   * width of the reference element.\\n   * @see https://floating-ui.com/docs/size\\n   */\\n  const size = function (options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    return {\\n      name: 'size',\\n      options,\\n      async fn(state) {\\n        const {\\n          placement,\\n          rects,\\n          platform,\\n          elements\\n        } = state;\\n        const {\\n          apply = () => {},\\n          ...detectOverflowOptions\\n        } = evaluate(options, state);\\n        const overflow = await detectOverflow(state, detectOverflowOptions);\\n        const side = getSide(placement);\\n        const alignment = getAlignment(placement);\\n        const isYAxis = getSideAxis(placement) === 'y';\\n        const {\\n          width,\\n          height\\n        } = rects.floating;\\n        let heightSide;\\n        let widthSide;\\n        if (side === 'top' || side === 'bottom') {\\n          heightSide = side;\\n          widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\\n        } else {\\n          widthSide = side;\\n          heightSide = alignment === 'end' ? 'top' : 'bottom';\\n        }\\n        const overflowAvailableHeight = height - overflow[heightSide];\\n        const overflowAvailableWidth = width - overflow[widthSide];\\n        const noShift = !state.middlewareData.shift;\\n        let availableHeight = overflowAvailableHeight;\\n        let availableWidth = overflowAvailableWidth;\\n        if (isYAxis) {\\n          const maximumClippingWidth = width - overflow.left - overflow.right;\\n          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\\n        } else {\\n          const maximumClippingHeight = height - overflow.top - overflow.bottom;\\n          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\\n        }\\n        if (noShift && !alignment) {\\n          const xMin = max(overflow.left, 0);\\n          const xMax = max(overflow.right, 0);\\n          const yMin = max(overflow.top, 0);\\n          const yMax = max(overflow.bottom, 0);\\n          if (isYAxis) {\\n            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\\n          } else {\\n            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\\n          }\\n        }\\n        await apply({\\n          ...state,\\n          availableWidth,\\n          availableHeight\\n        });\\n        const nextDimensions = await platform.getDimensions(elements.floating);\\n        if (width !== nextDimensions.width || height !== nextDimensions.height) {\\n          return {\\n            reset: {\\n              rects: true\\n            }\\n          };\\n        }\\n        return {};\\n      }\\n    };\\n  };\\n\\n  exports.arrow = arrow;\\n  exports.autoPlacement = autoPlacement;\\n  exports.computePosition = computePosition;\\n  exports.detectOverflow = detectOverflow;\\n  exports.flip = flip;\\n  exports.hide = hide;\\n  exports.inline = inline;\\n  exports.limitShift = limitShift;\\n  exports.offset = offset;\\n  exports.rectToClientRect = rectToClientRect;\\n  exports.shift = shift;\\n  exports.size = size;\\n\\n}));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"FloatingUICore\",\"evaluate\",\"value\",\"param\",\"getSide\",\"placement\",\"split\",\"getAlignment\",\"getOppositeAxis\",\"axis\",\"getAxisLength\",\"getSideAxis\",\"includes\",\"getAlignmentSides\",\"rects\",\"rtl\",\"alignment\",\"alignmentAxis\",\"length\",\"mainAlignmentSide\",\"reference\",\"floating\",\"getOppositePlacement\",\"getExpandedPlacements\",\"oppositePlacement\",\"getOppositeAlignmentPlacement\",\"replace\",\"oppositeAlignmentMap\",\"getSideList\",\"side\",\"isStart\",\"lr\",\"rl\",\"tb\",\"bt\",\"getOppositeAxisPlacements\",\"flipAlignment\",\"direction\",\"list\",\"map\",\"concat\",\"oppositeSideMap\",\"getPaddingObject\",\"padding\",\"top\",\"right\",\"bottom\",\"left\",\"rectToClientRect\",\"rect\",\"y\",\"x\",\"width\",\"height\",\"computeCoordsFromPlacement\",\"_ref\",\"sideAxis\",\"alignLength\",\"isVertical\",\"commonX\",\"commonY\",\"commonAlign\",\"coords\",\"detectOverflow\",\"state\",\"options\",\"_await$platform$isEle\",\"platform\",\"elements\",\"strategy\",\"boundary\",\"rootBoundary\",\"elementContext\",\"altBoundary\",\"paddingObject\",\"element\",\"altContext\",\"clippingClientRect\",\"getClippingRect\",\"isElement\",\"contextElement\",\"getDocumentElement\",\"offsetParent\",\"getOffsetParent\",\"offsetScale\",\"getScale\",\"elementClientRect\",\"convertOffsetParentRelativeRectToViewportRelativeRect\",\"getPlacementList\",\"autoAlignment\",\"allowedPlacements\",\"filter\",\"allowedPlacementsSortedByAlignment\",\"getSideOffsets\",\"overflow\",\"isAnySideFullyClipped\",\"sides\",\"some\",\"getBoundingRect\",\"minX\",\"min\",\"minY\",\"maxX\",\"max\",\"maxY\",\"getRectsByLine\",\"sortedRects\",\"slice\",\"sort\",\"a\",\"b\",\"groups\",\"prevRect\",\"i\",\"push\",\"convertValueToCoords\",\"isRTL\",\"mainAxisMulti\",\"crossAxisMulti\",\"rawValue\",\"mainAxis\",\"crossAxis\",\"alignments\",\"placements\",\"reduce\",\"acc\",\"Math\",\"start\",\"end\",\"arrow\",\"name\",\"fn\",\"middlewareData\",\"arrowDimensions\",\"getDimensions\",\"isYAxis\",\"minProp\",\"maxProp\",\"clientProp\",\"endDiff\",\"startDiff\",\"arrowOffsetParent\",\"clientSize\",\"centerToReference\",\"largestPossiblePadding\",\"minPadding\",\"maxPadding\",\"center\",\"offset\",\"alignmentOffset\",\"shouldAddOffset\",\"data\",\"centerOffset\",\"reset\",\"autoPlacement\",\"_middlewareData$autoP\",\"_middlewareData$autoP2\",\"_placementsThatFitOnE\",\"detectOverflowOptions\",\"placements$1\",\"undefined\",\"currentIndex\",\"index\",\"currentPlacement\",\"alignmentSides\",\"currentOverflows\",\"allOverflows\",\"overflows\",\"nextPlacement\",\"placementsSortedByMostSpace\",\"d\",\"v\",\"resetPlacement\",\"placementsThatFitOnEachSide\",\"every\",\"computePosition\",\"config\",\"middleware\",\"validMiddleware\",\"Boolean\",\"getElementRects\",\"statefulPlacement\",\"resetCount\",\"nextX\",\"nextY\",\"initialPlacement\",\"flip\",\"_middlewareData$arrow\",\"_middlewareData$flip\",\"checkMainAxis\",\"checkCrossAxis\",\"specifiedFallbackPlacements\",\"fallbackStrategy\",\"fallbackAxisSideDirection\",\"isBasePlacement\",\"fallbackPlacements\",\"overflowsData\",\"_middlewareData$flip2\",\"_overflowsData$filter\",\"nextIndex\",\"_overflowsData$map$so\",\"hide\",\"offsets\",\"referenceHiddenOffsets\",\"referenceHidden\",\"escapedOffsets\",\"escaped\",\"inline\",\"nativeClientRects\",\"Array\",\"from\",\"getClientRects\",\"clientRects\",\"fallback\",\"resetRects\",\"getBoundingClientRect\",\"find\",\"firstRect\",\"lastRect\",\"isTop\",\"isLeftSide\",\"maxRight\",\"minLeft\",\"measureRects\",\"limitShift\",\"mainAxisCoord\",\"crossAxisCoord\",\"rawOffset\",\"computedOffset\",\"len\",\"limitMin\",\"limitMax\",\"_middlewareData$offse\",\"_middlewareData$offse2\",\"isOriginSide\",\"diffCoords\",\"shift\",\"limiter\",\"minSide\",\"maxSide\",\"limitedCoords\",\"size\",\"apply\",\"heightSide\",\"widthSide\",\"overflowAvailableHeight\",\"overflowAvailableWidth\",\"noShift\",\"availableHeight\",\"availableWidth\",\"maximumClippingWidth\",\"maximumClippingHeight\",\"xMin\",\"xMax\",\"yMin\",\"yMax\",\"nextDimensions\"]\n}\n"]