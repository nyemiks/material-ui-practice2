["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/base/node/useOption/useOptionContextStabilizer.js"],"~:js","shadow$provide.module$node_modules$$mui$base$node$useOption$useOptionContextStabilizer = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  \"use client\";\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.useOptionContextStabilizer = function(value) {\n    const listContext = React.useContext(_useList.ListContext);\n    if (!listContext) {\n      throw Error(\"Option: ListContext was not found.\");\n    }\n    const {getItemState, dispatch} = listContext, {highlighted, selected, focusable} = getItemState(value), localGetItemState = React.useCallback(itemValue => {\n      if (itemValue !== value) {\n        throw Error(\"Base UI Option: Tried to access the state of another Option./nThis is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.\");\n      }\n      return {highlighted, selected, focusable};\n    }, [highlighted, selected, focusable, value]);\n    return {contextValue:React.useMemo(() => ({dispatch, getItemState:localGetItemState}), [dispatch, localGetItemState])};\n  };\n  var React = function(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }(require(\"module$node_modules$react$index\")), _useList = require(\"module$node_modules$$mui$base$node$useList$index\");\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$base$node$useOption$useOptionContextStabilizer\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useOptionContextStabilizer = useOptionContextStabilizer;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useList = require(\"../useList\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n/**\n * Stabilizes the ListContext value for the Option component, so it doesn't change when sibling Options update.\n *\n * @param value The value of the Option.\n * @returns The stable ListContext value.\n *\n * Demos:\n *\n * - [Select](https://mui.com/base-ui/react-select/#hooks)\n *\n * API:\n *\n * - [useOptionContextStabilizer API](https://mui.com/base-ui/react-select/hooks-api/#use-option-context-stabilizer)\n */\nfunction useOptionContextStabilizer(value) {\n  const listContext = React.useContext(_useList.ListContext);\n  if (!listContext) {\n    throw new Error('Option: ListContext was not found.');\n  }\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = getItemState(value);\n\n  // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== value) {\n      throw new Error(['Base UI Option: Tried to access the state of another Option.', 'This is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.'].join('/n'));\n    }\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, value]);\n\n  // Create a local (per Option) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes Options re-render only when their state actually change, not when any Option's state changes.\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$mui$base$node$useList$index","~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["selected","dispatch","__esModule","highlighted","value","contextValue","getItemState","useOptionContextStabilizer","__proto__","default","focusable"]],"~:compiled-at",1712152511279,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$base$node$useOption$useOptionContextStabilizer.js\",\n\"lineCount\":46,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@mui/base/node/useOption/useOptionContextStabilizer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$base$node$useOption$useOptionContextStabilizer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.useOptionContextStabilizer = useOptionContextStabilizer;\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar _useList = require(\\\"../useList\\\");\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\n/**\\n * Stabilizes the ListContext value for the Option component, so it doesn't change when sibling Options update.\\n *\\n * @param value The value of the Option.\\n * @returns The stable ListContext value.\\n *\\n * Demos:\\n *\\n * - [Select](https://mui.com/base-ui/react-select/#hooks)\\n *\\n * API:\\n *\\n * - [useOptionContextStabilizer API](https://mui.com/base-ui/react-select/hooks-api/#use-option-context-stabilizer)\\n */\\nfunction useOptionContextStabilizer(value) {\\n  const listContext = React.useContext(_useList.ListContext);\\n  if (!listContext) {\\n    throw new Error('Option: ListContext was not found.');\\n  }\\n  const {\\n    getItemState,\\n    dispatch\\n  } = listContext;\\n  const {\\n    highlighted,\\n    selected,\\n    focusable\\n  } = getItemState(value);\\n\\n  // The local version of getItemState can be only called with the current Option's value.\\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\\n  const localGetItemState = React.useCallback(itemValue => {\\n    if (itemValue !== value) {\\n      throw new Error(['Base UI Option: Tried to access the state of another Option.', 'This is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.'].join('/n'));\\n    }\\n    return {\\n      highlighted,\\n      selected,\\n      focusable\\n    };\\n  }, [highlighted, selected, focusable, value]);\\n\\n  // Create a local (per Option) instance of the ListContext that changes only when\\n  // the getItemState's return value changes.\\n  // This makes Options re-render only when their state actually change, not when any Option's state changes.\\n  const localContextValue = React.useMemo(() => ({\\n    dispatch,\\n    getItemState: localGetItemState\\n  }), [dispatch, localGetItemState]);\\n  return {\\n    contextValue: localContextValue\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"Object\",\"defineProperty\",\"value\",\"useOptionContextStabilizer\",\"listContext\",\"React\",\"useContext\",\"_useList\",\"ListContext\",\"Error\",\"getItemState\",\"dispatch\",\"highlighted\",\"selected\",\"focusable\",\"localGetItemState\",\"useCallback\",\"itemValue\",\"contextValue\",\"useMemo\",\"localContextValue\",\"_interopRequireWildcard\",\"__esModule\",\"default\",\"has\",\"get\",\"n\",\"__proto__\",\"a\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"call\",\"i\",\"set\"]\n}\n"]