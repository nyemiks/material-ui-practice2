["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/cjs/utils/ChildMapping.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$cjs$utils$ChildMapping = function(global, require, module, exports) {\n  function getChildMapping(children, mapFn) {\n    var result = Object.create(null);\n    children && _react.Children.map(children, function(c) {\n      return c;\n    }).forEach(function(child) {\n      var JSCompiler_temp_const = child.key;\n      child = mapFn && (0,_react.isValidElement)(child) ? mapFn(child) : child;\n      result[JSCompiler_temp_const] = child;\n    });\n    return result;\n  }\n  function mergeChildMappings(prev, next) {\n    function getValueForKey(key) {\n      return key in next ? next[key] : prev[key];\n    }\n    prev = prev || {};\n    next = next || {};\n    var nextKeysPending = Object.create(null), pendingKeys = [], prevKey;\n    for (prevKey in prev) {\n      prevKey in next ? pendingKeys.length && (nextKeysPending[prevKey] = pendingKeys, pendingKeys = []) : pendingKeys.push(prevKey);\n    }\n    var childMapping = {}, nextKey;\n    for (nextKey in next) {\n      if (nextKeysPending[nextKey]) {\n        for (prevKey = 0; prevKey < nextKeysPending[nextKey].length; prevKey++) {\n          childMapping[nextKeysPending[nextKey][prevKey]] = getValueForKey(nextKeysPending[nextKey][prevKey]);\n        }\n      }\n      childMapping[nextKey] = getValueForKey(nextKey);\n    }\n    for (prevKey = 0; prevKey < pendingKeys.length; prevKey++) {\n      childMapping[pendingKeys[prevKey]] = getValueForKey(pendingKeys[prevKey]);\n    }\n    return childMapping;\n  }\n  function getProp(child, prop, props) {\n    return null != props[prop] ? props[prop] : child.props[prop];\n  }\n  exports.__esModule = !0;\n  exports.getChildMapping = getChildMapping;\n  exports.mergeChildMappings = mergeChildMappings;\n  exports.getInitialChildMapping = function(props, onExited) {\n    return getChildMapping(props.children, function(child) {\n      return (0,_react.cloneElement)(child, {onExited:onExited.bind(null, child), in:!0, appear:getProp(child, \"appear\", props), enter:getProp(child, \"enter\", props), exit:getProp(child, \"exit\", props)});\n    });\n  };\n  exports.getNextChildMapping = function(nextProps, prevChildMapping, onExited) {\n    var nextChildMapping = getChildMapping(nextProps.children), children = mergeChildMappings(prevChildMapping, nextChildMapping);\n    Object.keys(children).forEach(function(key) {\n      var child = children[key];\n      if ((0,_react.isValidElement)(child)) {\n        var hasPrev = key in prevChildMapping, hasNext = key in nextChildMapping, prevChild = prevChildMapping[key], isLeaving = (0,_react.isValidElement)(prevChild) && !prevChild.props.in;\n        !hasNext || hasPrev && !isLeaving ? hasNext || !hasPrev || isLeaving ? hasNext && hasPrev && (0,_react.isValidElement)(prevChild) && (children[key] = (0,_react.cloneElement)(child, {onExited:onExited.bind(null, child), in:prevChild.props.in, exit:getProp(child, \"exit\", nextProps), enter:getProp(child, \"enter\", nextProps)})) : children[key] = (0,_react.cloneElement)(child, {in:!1}) : children[key] = (0,_react.cloneElement)(child, {onExited:onExited.bind(null, child), in:!0, exit:getProp(child, \n        \"exit\", nextProps), enter:getProp(child, \"enter\", nextProps)});\n      }\n    });\n    return children;\n  };\n  var _react = require(\"module$node_modules$react$index\");\n};\n","~:source","shadow$provide[\"module$node_modules$react_transition_group$cjs$utils$ChildMapping\"] = function(global,require,module,exports) {\n\"use strict\";\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\nexports.getInitialChildMapping = getInitialChildMapping;\nexports.getNextChildMapping = getNextChildMapping;\n\nvar _react = require(\"react\");\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) _react.Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nfunction getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return (0, _react.cloneElement)(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\n\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!(0, _react.isValidElement)(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["appear","onExited","__esModule","getNextChildMapping","getInitialChildMapping","getChildMapping","exit","mergeChildMappings","enter","in"]],"~:compiled-at",1712152510928,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$cjs$utils$ChildMapping.js\",\n\"lineCount\":62,\n\"mappings\":\"AAAAA,cAAA,CAAA,iEAAA,GAAsF,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAiB9HC,UAASA,gBAAe,CAACC,QAAD,EAAWC,KAAX,CAAkB;AAKxC,QAAIC,SAASC,MAAOC,CAAAA,MAAP,CAAc,IAAd,CAAb;AACIJ,YAAJ,IAAcK,MAAOC,CAAAA,QAASC,CAAAA,GAAhB,CAAoBP,QAApB,EAA8B,QAAS,CAACQ,CAAD,CAAI;AACvD,aAAOA,CAAP;AADuD,KAA3C,CAEXC,CAAAA,OAFW,CAEH,QAAS,CAACC,KAAD,CAAQ;AAEbC,UAAAA,wBAAND,KAAMC,CAAAA,GAAAA;AARb,WAAA,GAAOV,KAAA,IAAS,GAAII,MAAOO,CAAAA,cAAX,EAQWF,KARX,CAAT,GAA6CT,KAAA,CAQzBS,KARyB,CAA7C,GAQoBA,KAR3B;AAQAR,YAAA,CAAaS,qBAAb,CAAA,GAAoB,KAApB;AAF0B,KAFd,CAAd;AAMA,WAAOT,MAAP;AAZwC;AAiC1CW,UAASA,mBAAkB,CAACC,IAAD,EAAOC,IAAP,CAAa;AAItCC,YAASA,eAAc,CAACL,GAAD,CAAM;AAC3B,aAAOA,GAAA,IAAOI,IAAP,GAAcA,IAAA,CAAKJ,GAAL,CAAd,GAA0BG,IAAA,CAAKH,GAAL,CAAjC;AAD2B;AAH7BG,QAAA,GAAOA,IAAP,IAAe,EAAf;AACAC,QAAA,GAAOA,IAAP,IAAe,EAAf;AAQA,QAAIE,kBAAkBd,MAAOC,CAAAA,MAAP,CAAc,IAAd,CAAtB,EACIc,cAAc,EADlB,EAGSC,OAHT;AAGA,SAASA,OAAT,GAAoBL,KAApB;AACMK,aAAJ,IAAeJ,IAAf,GACMG,WAAYE,CAAAA,MADlB,KAEIH,eAAA,CAAgBE,OAAhB,CACA,GAD2BD,WAC3B,EAAAA,WAAA,GAAc,EAHlB,IAMEA,WAAYG,CAAAA,IAAZ,CAAiBF,OAAjB,CANF;AADF;AAYA,QAAIG,eAAe,EAAnB,EAESC,OAFT;AAEA,SAASA,OAAT,GAAoBR,KAApB,CAA0B;AACxB,UAAIE,eAAA,CAAgBM,OAAhB,CAAJ;AACE,aAAKC,OAAL,GAAS,CAAT,EAAYA,OAAZ,GAAgBP,eAAA,CAAgBM,OAAhB,CAAyBH,CAAAA,MAAzC,EAAiDI,OAAA,EAAjD;AAEEF,sBAAA,CAAaL,eAAA,CAAgBM,OAAhB,CAAA,CAAyBC,OAAzB,CAAb,CAAA,GAA4CR,cAAA,CADvBC,eAAA,CAAgBM,OAAhB,CAAAE,CAAyBD,OAAzBC,CACuB,CAA5C;AAFF;AADF;AAOAH,kBAAA,CAAaC,OAAb,CAAA,GAAwBP,cAAA,CAAeO,OAAf,CAAxB;AARwB;AAY1B,SAAKC,OAAL,GAAS,CAAT,EAAYA,OAAZ,GAAgBN,WAAYE,CAAAA,MAA5B,EAAoCI,OAAA,EAApC;AACEF,kBAAA,CAAaJ,WAAA,CAAYM,OAAZ,CAAb,CAAA,GAA+BR,cAAA,CAAeE,WAAA,CAAYM,OAAZ,CAAf,CAA/B;AADF;AAIA,WAAOF,YAAP;AA3CsC;AA8CxCI,UAASA,QAAO,CAAChB,KAAD,EAAQiB,IAAR,EAAcC,KAAd,CAAqB;AACnC,WAAsB,IAAf,IAAAA,KAAA,CAAMD,IAAN,CAAA,GAAsBC,KAAA,CAAMD,IAAN,CAAtB,GAAoCjB,KAAMkB,CAAAA,KAAN,CAAYD,IAAZ,CAA3C;AADmC;AA7FrC7B,SAAQ+B,CAAAA,UAAR,GAAqB,CAAA,CAArB;AACA/B,SAAQC,CAAAA,eAAR,GAA0BA,eAA1B;AACAD,SAAQe,CAAAA,kBAAR,GAA6BA,kBAA7B;AACAf,SAAQgC,CAAAA,sBAAR,GA8FAA,QAA+B,CAACF,KAAD,EAAQG,QAAR,CAAkB;AAC/C,WAAOhC,eAAA,CAAgB6B,KAAM5B,CAAAA,QAAtB,EAAgC,QAAS,CAACU,KAAD,CAAQ;AACtD,aAAO,GAAIL,MAAO2B,CAAAA,YAAX,EAAyBtB,KAAzB,EAAgC,CACrCqB,SAAUA,QAASE,CAAAA,IAAT,CAAc,IAAd,EAAoBvB,KAApB,CAD2B,EAErCwB,GAAI,CAAA,CAFiC,EAGrCC,OAAQT,OAAA,CAAQhB,KAAR,EAAe,QAAf,EAAyBkB,KAAzB,CAH6B,EAIrCQ,MAAOV,OAAA,CAAQhB,KAAR,EAAe,OAAf,EAAwBkB,KAAxB,CAJ8B,EAKrCS,KAAMX,OAAA,CAAQhB,KAAR,EAAe,MAAf,EAAuBkB,KAAvB,CAL+B,CAAhC,CAAP;AADsD,KAAjD,CAAP;AAD+C,GA9FjD;AACA9B,SAAQwC,CAAAA,mBAAR,GAyGAA,QAA4B,CAACC,SAAD,EAAYC,gBAAZ,EAA8BT,QAA9B,CAAwC;AAClE,QAAIU,mBAAmB1C,eAAA,CAAgBwC,SAAUvC,CAAAA,QAA1B,CAAvB,EACIA,WAAWa,kBAAA,CAAmB2B,gBAAnB,EAAqCC,gBAArC,CADf;AAEAtC,UAAOuC,CAAAA,IAAP,CAAY1C,QAAZ,CAAsBS,CAAAA,OAAtB,CAA8B,QAAS,CAACE,GAAD,CAAM;AAC3C,UAAID,QAAQV,QAAA,CAASW,GAAT,CAAZ;AACA,UAAK,GAAIN,MAAOO,CAAAA,cAAX,EAA2BF,KAA3B,CAAL,CAAA;AACA,YAAIiC,UAAWhC,GAAXgC,IAAkBH,gBAAtB,EACII,UAAWjC,GAAXiC,IAAkBH,gBADtB,EAEII,YAAYL,gBAAA,CAAiB7B,GAAjB,CAFhB,EAGImC,YAAY,GAAIzC,MAAOO,CAAAA,cAAX,EAA2BiC,SAA3B,CAAZC,IAAqD,CAACD,SAAUjB,CAAAA,KAAMM,CAAAA,EAH1E;AAKIU,SAAAA,OAAJ,IAAiBD,OAAjB,IAA4BG,CAAAA,SAA5B,GAQYF,OAAL,IAAgBD,CAAAA,OAAhB,IAA4BG,SAA5B,GAMIF,OANJ,IAMeD,OANf,IAM0B,GAAItC,MAAOO,CAAAA,cAAX,EAA2BiC,SAA3B,CAN1B,KAUL7C,QAAA,CAASW,GAAT,CAVK,GAUW,GAAIN,MAAO2B,CAAAA,YAAX,EAAyBtB,KAAzB,EAAgC,CAC9CqB,SAAUA,QAASE,CAAAA,IAAT,CAAc,IAAd,EAAoBvB,KAApB,CADoC,EAE9CwB,GAAIW,SAAUjB,CAAAA,KAAMM,CAAAA,EAF0B,EAG9CG,KAAMX,OAAA,CAAQhB,KAAR,EAAe,MAAf,EAAuB6B,SAAvB,CAHwC,EAI9CH,MAAOV,OAAA,CAAQhB,KAAR,EAAe,OAAf,EAAwB6B,SAAxB,CAJuC,CAAhC,CAVX,IAGLvC,QAAA,CAASW,GAAT,CAHK,GAGW,GAAIN,MAAO2B,CAAAA,YAAX,EAAyBtB,KAAzB,EAAgC,CAC9CwB,GAAI,CAAA,CAD0C,CAAhC,CAXlB,GAEElC,QAAA,CAASW,GAAT,CAFF,GAEkB,GAAIN,MAAO2B,CAAAA,YAAX,EAAyBtB,KAAzB,EAAgC,CAC9CqB,SAAUA,QAASE,CAAAA,IAAT,CAAc,IAAd,EAAoBvB,KAApB,CADoC,EAE9CwB,GAAI,CAAA,CAF0C,EAG9CG,KAAMX,OAAA,CAAQhB,KAAR;AAAe,cAAf,EAAuB6B,SAAvB,CAHwC,EAI9CH,MAAOV,OAAA,CAAQhB,KAAR,EAAe,OAAf,EAAwB6B,SAAxB,CAJuC,CAAhC,CAFlB;AANA;AAF2C,KAA7C,CAAA;AAkCA,WAAOvC,QAAP;AArCkE,GAzGpE;AAEA,MAAIK,SAAST,OAAA,CAAQ,iCAAR,CAAb;AAT8H,CAA9H;;\",\n\"sources\":[\"node_modules/react-transition-group/cjs/utils/ChildMapping.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$cjs$utils$ChildMapping\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nexports.getChildMapping = getChildMapping;\\nexports.mergeChildMappings = mergeChildMappings;\\nexports.getInitialChildMapping = getInitialChildMapping;\\nexports.getNextChildMapping = getNextChildMapping;\\n\\nvar _react = require(\\\"react\\\");\\n\\n/**\\n * Given `this.props.children`, return an object mapping key to child.\\n *\\n * @param {*} children `this.props.children`\\n * @return {object} Mapping of key to child\\n */\\nfunction getChildMapping(children, mapFn) {\\n  var mapper = function mapper(child) {\\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\\n  };\\n\\n  var result = Object.create(null);\\n  if (children) _react.Children.map(children, function (c) {\\n    return c;\\n  }).forEach(function (child) {\\n    // run the map function here instead so that the key is the computed one\\n    result[child.key] = mapper(child);\\n  });\\n  return result;\\n}\\n/**\\n * When you're adding or removing children some may be added or removed in the\\n * same render pass. We want to show *both* since we want to simultaneously\\n * animate elements in and out. This function takes a previous set of keys\\n * and a new set of keys and merges them with its best guess of the correct\\n * ordering. In the future we may expose some of the utilities in\\n * ReactMultiChild to make this easy, but for now React itself does not\\n * directly have this concept of the union of prevChildren and nextChildren\\n * so we implement it here.\\n *\\n * @param {object} prev prev children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @param {object} next next children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @return {object} a key set that contains all keys in `prev` and all keys\\n * in `next` in a reasonable order.\\n */\\n\\n\\nfunction mergeChildMappings(prev, next) {\\n  prev = prev || {};\\n  next = next || {};\\n\\n  function getValueForKey(key) {\\n    return key in next ? next[key] : prev[key];\\n  } // For each key of `next`, the list of keys to insert before that key in\\n  // the combined list\\n\\n\\n  var nextKeysPending = Object.create(null);\\n  var pendingKeys = [];\\n\\n  for (var prevKey in prev) {\\n    if (prevKey in next) {\\n      if (pendingKeys.length) {\\n        nextKeysPending[prevKey] = pendingKeys;\\n        pendingKeys = [];\\n      }\\n    } else {\\n      pendingKeys.push(prevKey);\\n    }\\n  }\\n\\n  var i;\\n  var childMapping = {};\\n\\n  for (var nextKey in next) {\\n    if (nextKeysPending[nextKey]) {\\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\\n        var pendingNextKey = nextKeysPending[nextKey][i];\\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\\n      }\\n    }\\n\\n    childMapping[nextKey] = getValueForKey(nextKey);\\n  } // Finally, add the keys which didn't appear before any key in `next`\\n\\n\\n  for (i = 0; i < pendingKeys.length; i++) {\\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\\n  }\\n\\n  return childMapping;\\n}\\n\\nfunction getProp(child, prop, props) {\\n  return props[prop] != null ? props[prop] : child.props[prop];\\n}\\n\\nfunction getInitialChildMapping(props, onExited) {\\n  return getChildMapping(props.children, function (child) {\\n    return (0, _react.cloneElement)(child, {\\n      onExited: onExited.bind(null, child),\\n      in: true,\\n      appear: getProp(child, 'appear', props),\\n      enter: getProp(child, 'enter', props),\\n      exit: getProp(child, 'exit', props)\\n    });\\n  });\\n}\\n\\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\\n  var nextChildMapping = getChildMapping(nextProps.children);\\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\\n  Object.keys(children).forEach(function (key) {\\n    var child = children[key];\\n    if (!(0, _react.isValidElement)(child)) return;\\n    var hasPrev = (key in prevChildMapping);\\n    var hasNext = (key in nextChildMapping);\\n    var prevChild = prevChildMapping[key];\\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)\\n\\n    if (hasNext && (!hasPrev || isLeaving)) {\\n      // console.log('entering', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: true,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    } else if (!hasNext && hasPrev && !isLeaving) {\\n      // item is old (exiting)\\n      // console.log('leaving', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        in: false\\n      });\\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\\n      // item hasn't changed transition states\\n      // copy over the last transition props;\\n      // console.log('unchanged', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: prevChild.props.in,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    }\\n  });\\n  return children;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getChildMapping\",\"children\",\"mapFn\",\"result\",\"Object\",\"create\",\"_react\",\"Children\",\"map\",\"c\",\"forEach\",\"child\",\"key\",\"isValidElement\",\"mergeChildMappings\",\"prev\",\"next\",\"getValueForKey\",\"nextKeysPending\",\"pendingKeys\",\"prevKey\",\"length\",\"push\",\"childMapping\",\"nextKey\",\"i\",\"pendingNextKey\",\"getProp\",\"prop\",\"props\",\"__esModule\",\"getInitialChildMapping\",\"onExited\",\"cloneElement\",\"bind\",\"in\",\"appear\",\"enter\",\"exit\",\"getNextChildMapping\",\"nextProps\",\"prevChildMapping\",\"nextChildMapping\",\"keys\",\"hasPrev\",\"hasNext\",\"prevChild\",\"isLeaving\"]\n}\n"]