["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/cjs/Transition.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$cjs$Transition = function(global, require, module, exports) {\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {default:obj};\n  }\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n  function noop() {\n  }\n  exports.__esModule = !0;\n  exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;\n  var _propTypes = _interopRequireDefault(require(\"module$node_modules$prop_types$index\")), _react = _interopRequireDefault(require(\"module$node_modules$react$index\")), _reactDom = _interopRequireDefault(require(\"module$node_modules$react_dom$index\")), _config = _interopRequireDefault(require(\"module$node_modules$react_transition_group$cjs$config\")), _PropTypes = require(\"module$node_modules$react_transition_group$cjs$utils$PropTypes\"), _TransitionGroupContext = _interopRequireDefault(require(\"module$node_modules$react_transition_group$cjs$TransitionGroupContext\")), \n  _reflow = require(\"module$node_modules$react_transition_group$cjs$utils$reflow\");\n  exports.UNMOUNTED = \"unmounted\";\n  exports.EXITED = \"exited\";\n  exports.ENTERING = \"entering\";\n  exports.ENTERED = \"entered\";\n  exports.EXITING = \"exiting\";\n  global = function(_React$Component) {\n    function Transition(props, context) {\n      var _this = _React$Component.call(this, props, context) || this;\n      context = context && !context.isMounting ? props.enter : props.appear;\n      _this.appearStatus = null;\n      props.in ? context ? (props = \"exited\", _this.appearStatus = \"entering\") : props = \"entered\" : props = props.unmountOnExit || props.mountOnEnter ? \"unmounted\" : \"exited\";\n      _this.state = {status:props};\n      _this.nextCallback = null;\n      return _this;\n    }\n    _inheritsLoose(Transition, _React$Component);\n    Transition.getDerivedStateFromProps = function(_ref, prevState) {\n      return _ref.in && \"unmounted\" === prevState.status ? {status:\"exited\"} : null;\n    };\n    var _proto = Transition.prototype;\n    _proto.componentDidMount = function() {\n      this.updateStatus(!0, this.appearStatus);\n    };\n    _proto.componentDidUpdate = function(prevProps) {\n      var nextStatus = null;\n      if (prevProps !== this.props) {\n        if (prevProps = this.state.status, this.props.in) {\n          \"entering\" !== prevProps && \"entered\" !== prevProps && (nextStatus = \"entering\");\n        } else {\n          if (\"entering\" === prevProps || \"entered\" === prevProps) {\n            nextStatus = \"exiting\";\n          }\n        }\n      }\n      this.updateStatus(!1, nextStatus);\n    };\n    _proto.componentWillUnmount = function() {\n      this.cancelNextCallback();\n    };\n    _proto.getTimeouts = function() {\n      var timeout = this.props.timeout, enter, appear;\n      var exit = enter = appear = timeout;\n      null != timeout && \"number\" !== typeof timeout && (exit = timeout.exit, enter = timeout.enter, appear = void 0 !== timeout.appear ? timeout.appear : enter);\n      return {exit, enter, appear};\n    };\n    _proto.updateStatus = function(mounting, nextStatus) {\n      void 0 === mounting && (mounting = !1);\n      null !== nextStatus ? (this.cancelNextCallback(), \"entering\" === nextStatus ? ((this.props.unmountOnExit || this.props.mountOnEnter) && (nextStatus = this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this)) && (0,_reflow.forceReflow)(nextStatus), this.performEnter(mounting)) : this.performExit()) : this.props.unmountOnExit && \"exited\" === this.state.status && this.setState({status:\"unmounted\"});\n    };\n    _proto.performEnter = function(mounting) {\n      var _this2 = this, enter = this.props.enter, appearing = this.context ? this.context.isMounting : mounting, _ref2 = this.props.nodeRef ? [appearing] : [_reactDom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];\n      _ref2 = this.getTimeouts();\n      var enterTimeout = appearing ? _ref2.appear : _ref2.enter;\n      !mounting && !enter || _config.default.disabled ? this.safeSetState({status:\"entered\"}, function() {\n        _this2.props.onEntered(maybeNode);\n      }) : (this.props.onEnter(maybeNode, maybeAppearing), this.safeSetState({status:\"entering\"}, function() {\n        _this2.props.onEntering(maybeNode, maybeAppearing);\n        _this2.onTransitionEnd(enterTimeout, function() {\n          _this2.safeSetState({status:\"entered\"}, function() {\n            _this2.props.onEntered(maybeNode, maybeAppearing);\n          });\n        });\n      }));\n    };\n    _proto.performExit = function() {\n      var _this3 = this, exit = this.props.exit, timeouts = this.getTimeouts(), maybeNode = this.props.nodeRef ? void 0 : _reactDom.default.findDOMNode(this);\n      !exit || _config.default.disabled ? this.safeSetState({status:\"exited\"}, function() {\n        _this3.props.onExited(maybeNode);\n      }) : (this.props.onExit(maybeNode), this.safeSetState({status:\"exiting\"}, function() {\n        _this3.props.onExiting(maybeNode);\n        _this3.onTransitionEnd(timeouts.exit, function() {\n          _this3.safeSetState({status:\"exited\"}, function() {\n            _this3.props.onExited(maybeNode);\n          });\n        });\n      }));\n    };\n    _proto.cancelNextCallback = function() {\n      null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null);\n    };\n    _proto.safeSetState = function(nextState, callback) {\n      callback = this.setNextCallback(callback);\n      this.setState(nextState, callback);\n    };\n    _proto.setNextCallback = function(callback) {\n      var _this4 = this, active = !0;\n      this.nextCallback = function(event) {\n        active && (active = !1, _this4.nextCallback = null, callback(event));\n      };\n      this.nextCallback.cancel = function() {\n        active = !1;\n      };\n      return this.nextCallback;\n    };\n    _proto.onTransitionEnd = function(timeout, handler) {\n      this.setNextCallback(handler);\n      handler = this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this);\n      var doesNotHaveTimeoutOrListener = null == timeout && !this.props.addEndListener;\n      !handler || doesNotHaveTimeoutOrListener ? setTimeout(this.nextCallback, 0) : (this.props.addEndListener && (handler = this.props.nodeRef ? [this.nextCallback] : [handler, this.nextCallback], this.props.addEndListener(handler[0], handler[1])), null != timeout && setTimeout(this.nextCallback, timeout));\n    };\n    _proto.render = function() {\n      var status = this.state.status;\n      if (\"unmounted\" === status) {\n        return null;\n      }\n      var _this$props = this.props, children = _this$props.children;\n      var excluded = \"children in mountOnEnter unmountOnExit appear enter exit timeout addEndListener onEnter onEntering onEntered onExit onExiting onExited nodeRef\".split(\" \");\n      if (null == _this$props) {\n        _this$props = {};\n      } else {\n        var target = {}, sourceKeys = Object.keys(_this$props), i;\n        for (i = 0; i < sourceKeys.length; i++) {\n          var key = sourceKeys[i];\n          0 <= excluded.indexOf(key) || (target[key] = _this$props[key]);\n        }\n        _this$props = target;\n      }\n      return _react.default.createElement(_TransitionGroupContext.default.Provider, {value:null}, \"function\" === typeof children ? children(status, _this$props) : _react.default.cloneElement(_react.default.Children.only(children), _this$props));\n    };\n    return Transition;\n  }(_react.default.Component);\n  global.contextType = _TransitionGroupContext.default;\n  global.propTypes = {nodeRef:_propTypes.default.shape({current:\"undefined\" === typeof Element ? _propTypes.default.any : function(propValue, key, componentName, location, propFullName, secret) {\n    var value = propValue[key];\n    return _propTypes.default.instanceOf(value && \"ownerDocument\" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);\n  }}), children:_propTypes.default.oneOfType([_propTypes.default.func.isRequired, _propTypes.default.element.isRequired]).isRequired, in:_propTypes.default.bool, mountOnEnter:_propTypes.default.bool, unmountOnExit:_propTypes.default.bool, appear:_propTypes.default.bool, enter:_propTypes.default.bool, exit:_propTypes.default.bool, timeout:function(props) {\n    var pt = _PropTypes.timeoutsShape;\n    props.addEndListener || (pt = pt.isRequired);\n    for (var _len = arguments.length, args = Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return pt.apply(void 0, [props].concat(args));\n  }, addEndListener:_propTypes.default.func, onEnter:_propTypes.default.func, onEntering:_propTypes.default.func, onEntered:_propTypes.default.func, onExit:_propTypes.default.func, onExiting:_propTypes.default.func, onExited:_propTypes.default.func};\n  global.defaultProps = {in:!1, mountOnEnter:!1, unmountOnExit:!1, appear:!1, enter:!0, exit:!0, onEnter:noop, onEntering:noop, onEntered:noop, onExit:noop, onExiting:noop, onExited:noop};\n  global.UNMOUNTED = \"unmounted\";\n  global.EXITED = \"exited\";\n  global.ENTERING = \"entering\";\n  global.ENTERED = \"entered\";\n  global.EXITING = \"exiting\";\n  exports.default = global;\n};\n","~:source","shadow$provide[\"module$node_modules$react_transition_group$cjs$Transition\"] = function(global,require,module,exports) {\n\"use strict\";\n\nexports.__esModule = true;\nexports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _PropTypes = require(\"./utils/PropTypes\");\n\nvar _TransitionGroupContext = _interopRequireDefault(require(\"./TransitionGroupContext\"));\n\nvar _reflow = require(\"./utils/reflow\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar UNMOUNTED = 'unmounted';\nexports.UNMOUNTED = UNMOUNTED;\nvar EXITED = 'exited';\nexports.EXITED = EXITED;\nvar ENTERING = 'entering';\nexports.ENTERING = ENTERING;\nvar ENTERED = 'entered';\nexports.ENTERED = ENTERED;\nvar EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\n * transitions in CSS, you'll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the\n * components. It's up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from 'react-transition-group';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the \"Enter\" stage. During this stage, the component will shift from\n * its current transition state, to `'entering'` for the duration of the\n * transition and then to the `'entered'` stage once it's complete. Let's take\n * the following example (we'll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `'exiting'` to `'exited'`.\n */\n\nexports.EXITING = EXITING;\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        if (this.props.unmountOnExit || this.props.mountOnEnter) {\n          var node = this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749\n          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.\n          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.\n\n          if (node) (0, _reflow.forceReflow)(node);\n        }\n\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n\n    var _ref2 = this.props.nodeRef ? [appearing] : [_reactDom.default.findDOMNode(this), appearing],\n        maybeNode = _ref2[0],\n        maybeAppearing = _ref2[1];\n\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || _config.default.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : _reactDom.default.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || _config.default.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n          maybeNode = _ref3[0],\n          maybeNextCallback = _ref3[1];\n\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        _in = _this$props.in,\n        _mountOnEnter = _this$props.mountOnEnter,\n        _unmountOnExit = _this$props.unmountOnExit,\n        _appear = _this$props.appear,\n        _enter = _this$props.enter,\n        _exit = _this$props.exit,\n        _timeout = _this$props.timeout,\n        _addEndListener = _this$props.addEndListener,\n        _onEnter = _this$props.onEnter,\n        _onEntering = _this$props.onEntering,\n        _onEntered = _this$props.onEntered,\n        _onExit = _this$props.onExit,\n        _onExiting = _this$props.onExiting,\n        _onExited = _this$props.onExited,\n        _nodeRef = _this$props.nodeRef,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n\n    return (\n      /*#__PURE__*/\n      // allows for nested Transitions\n      _react.default.createElement(_TransitionGroupContext.default.Provider, {\n        value: null\n      }, typeof children === 'function' ? children(status, childProps) : _react.default.cloneElement(_react.default.Children.only(children), childProps))\n    );\n  };\n\n  return Transition;\n}(_react.default.Component);\n\nTransition.contextType = _TransitionGroupContext.default;\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A React reference to DOM element that need to transition:\n   * https://stackoverflow.com/a/51127130/4671932\n   *\n   *   - When `nodeRef` prop is used, `node` is not passed to callback functions\n   *      (e.g. `onEnter`) because user already has direct access to the node.\n   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new\n   *     `nodeRef` need to be provided to `Transition` with changed `key` prop\n   *     (see\n   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).\n   */\n  nodeRef: _propTypes.default.shape({\n    current: typeof Element === 'undefined' ? _propTypes.default.any : function (propValue, key, componentName, location, propFullName, secret) {\n      var value = propValue[key];\n      return _propTypes.default.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);\n    }\n  }),\n\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: _propTypes.default.oneOfType([_propTypes.default.func.isRequired, _propTypes.default.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: _propTypes.default.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: _propTypes.default.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: _propTypes.default.bool,\n\n  /**\n   * By default the child component does not perform the enter transition when\n   * it first mounts, regardless of the value of `in`. If you want this\n   * behavior, set both `appear` and `in` to `true`.\n   *\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\n   * > only adds an additional enter transition. However, in the\n   * > `<CSSTransition>` component that first enter transition does result in\n   * > additional `.appear-*` classes, that way you can choose to style it\n   * > differently.\n   */\n  appear: _propTypes.default.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: _propTypes.default.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: _propTypes.default.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function timeout(props) {\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return pt.apply(void 0, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. Timeouts are still used as a fallback if provided.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: _propTypes.default.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: _propTypes.default.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: _propTypes.default.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: _propTypes.default.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: _propTypes.default.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: _propTypes.default.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: _propTypes.default.func\n} : {}; // Name the function so it is clearer in the documentation\n\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\nvar _default = Transition;\nexports.default = _default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_transition_group$cjs$config","~$module$node_modules$react_dom$index","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$react_transition_group$cjs$TransitionGroupContext","~$module$node_modules$react_transition_group$cjs$utils$PropTypes","~$module$node_modules$react_transition_group$cjs$utils$reflow"]],"~:properties",["^5",["nodeRef","appear","EXITED","getDerivedStateFromProps","onExited","cancel","prototype","unmountOnExit","cancelNextCallback","safeSetState","updateStatus","performEnter","children","__esModule","EXITING","propTypes","appearStatus","value","addEndListener","setNextCallback","UNMOUNTED","onEntering","getTimeouts","status","timeout","onExit","componentDidUpdate","performExit","onEntered","current","contextType","componentDidMount","defaultProps","render","onExiting","state","__proto__","exit","onTransitionEnd","componentWillUnmount","nextCallback","mountOnEnter","ENTERED","onEnter","ENTERING","enter","default","constructor","in"]],"~:compiled-at",1712152510897,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$cjs$Transition.js\",\n\"lineCount\":157,\n\"mappings\":\"AAAAA,cAAA,CAAA,yDAAA,GAA8E,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAoBtHC,UAASA,uBAAsB,CAACC,GAAD,CAAM;AAAE,WAAOA,GAAA,IAAOA,GAAIC,CAAAA,UAAX,GAAwBD,GAAxB,GAA8B,CAAEE,QAASF,GAAX,CAArC;AAAF;AAIrCG,UAASA,eAAc,CAACC,QAAD,EAAWC,UAAX,CAAuB;AAAED,YAASE,CAAAA,SAAT,GAAqBC,MAAOC,CAAAA,MAAP,CAAcH,UAAWC,CAAAA,SAAzB,CAArB;AAA0DF,YAASE,CAAAA,SAAUG,CAAAA,WAAnB,GAAiCL,QAAjC;AAA2CA,YAASM,CAAAA,SAAT,GAAqBL,UAArB;AAAvG;AA0lB9CM,UAASA,KAAI,EAAG;;AA/mBhBb,SAAQG,CAAAA,UAAR,GAAqB,CAAA,CAArB;AACAH,SAAQI,CAAAA,OAAR,GAAkBJ,OAAQc,CAAAA,OAA1B,GAAoCd,OAAQe,CAAAA,OAA5C,GAAsDf,OAAQgB,CAAAA,QAA9D,GAAyEhB,OAAQiB,CAAAA,MAAjF,GAA0FjB,OAAQkB,CAAAA,SAAlG,GAA8G,IAAK,EAAnH;AAEA,MAAIC,aAAalB,sBAAA,CAAuBH,OAAA,CAAQ,sCAAR,CAAvB,CAAjB,EAEIsB,SAASnB,sBAAA,CAAuBH,OAAA,CAAQ,iCAAR,CAAvB,CAFb,EAIIuB,YAAYpB,sBAAA,CAAuBH,OAAA,CAAQ,qCAAR,CAAvB,CAJhB,EAMIwB,UAAUrB,sBAAA,CAAuBH,OAAA,CAAQ,uDAAR,CAAvB,CANd,EAQIyB,aAAazB,OAAA,CAAQ,gEAAR,CARjB,EAUI0B,0BAA0BvB,sBAAA,CAAuBH,OAAA,CAAQ,uEAAR,CAAvB,CAV9B;AAYI2B,YAAU3B,OAAA,CAAQ,6DAAR,CAZd;AAqBAE,SAAQkB,CAAAA,SAAR,GADgBA,WAChB;AAEAlB,SAAQiB,CAAAA,MAAR,GADaA,QACb;AAEAjB,SAAQgB,CAAAA,QAAR,GADeA,UACf;AAEAhB,SAAQe,CAAAA,OAAR,GADcA,SACd;AA8FAf,SAAQc,CAAAA,OAAR,GA7FcA,SA6Fd;AAEIY,QAAAA,GAA0B,QAAS,CAACC,gBAAD,CAAmB;AAGxDD,YAASA,WAAU,CAACE,KAAD,EAAQC,OAAR,CAAiB;AAGlC,UAAAC,QAAQH,gBAAiBI,CAAAA,IAAjB,CAAsB,IAAtB,EAA4BH,KAA5B,EAAmCC,OAAnC,CAARC,IAAuD,IAAvD;AAGIE,aAAAA,GAFcH,OAEL,IAAe,CAFVA,OAEuBI,CAAAA,UAA5B,GAAyCL,KAAMM,CAAAA,KAA/C,GAAuDN,KAAMI,CAAAA,MAAtEA;AAEJF,WAAMK,CAAAA,YAAN,GAAqB,IAArB;AAEIP,WAAMQ,CAAAA,EAAV,GACMJ,OAAJ,IACEK,KACA,GArHKpB,QAqHL,EAAAa,KAAMK,CAAAA,YAAN,GAnHOnB,UAiHT,IAIEqB,KAJF,GA/GQtB,SA8GV,GASIsB,KATJ,GAQMT,KAAMU,CAAAA,aAAV,IAA2BV,KAAMW,CAAAA,YAAjC,GA5HUrB,WA4HV,GA1HOD,QAkHT;AAeAa,WAAMU,CAAAA,KAAN,GAAc,CACZC,OAAQJ,KADI,CAAd;AAGAP,WAAMY,CAAAA,YAAN,GAAqB,IAArB;AACA,aAAOZ,KAAP;AA7BkC;AAFpCzB,kBAAA,CAAeqB,UAAf,EAA2BC,gBAA3B,CAAA;AAkCAD,cAAWiB,CAAAA,wBAAX,GAAsCC,QAAiC,CAACC,IAAD,EAAOC,SAAP,CAAkB;AAGvF,aAFaD,IAAKT,CAAAA,EAElB,IA7IYlB,WA6IZ,KAAc4B,SAAUL,CAAAA,MAAxB,GACS,CACLA,OA7IKxB,QA4IA,CADT,GAMO,IANP;AAHuF,KAAzF;AA4BA,QAAI8B,SAASrB,UAAWlB,CAAAA,SAAxB;AAEAuC,UAAOC,CAAAA,iBAAP,GAA2BC,QAA0B,EAAG;AACtD,UAAKC,CAAAA,YAAL,CAAkB,CAAA,CAAlB,EAAwB,IAAKf,CAAAA,YAA7B,CAAA;AADsD,KAAxD;AAIAY,UAAOI,CAAAA,kBAAP,GAA4BC,QAA2B,CAACC,SAAD,CAAY;AACjE,UAAIC,aAAa,IAAjB;AAEA,UAAID,SAAJ,KAAkB,IAAKzB,CAAAA,KAAvB;AAGE,YAFIa,SAEWL,GAFF,IAAKI,CAAAA,KAAMC,CAAAA,MAETL,EAAX,IAAKR,CAAAA,KAAMQ,CAAAA,EAAf;AA9KSpB,oBA+KP,KAAIyB,SAAJ,IA7KM1B,SA6KN,KAA2B0B,SAA3B,KACEa,UADF,GA/KOtC,UA+KP;AADF;AAKE,cAnLOA,UAmLP,KAAIyB,SAAJ,IAjLM1B,SAiLN,KAA2B0B,SAA3B;AACEa,sBAAA,GAhLIxC,SAgLJ;AADF;AALF;AAHF;AAcA,UAAKoC,CAAAA,YAAL,CAAkB,CAAA,CAAlB,EAAyBI,UAAzB,CAAA;AAjBiE,KAAnE;AAoBAP,UAAOQ,CAAAA,oBAAP,GAA8BC,QAA6B,EAAG;AAC5D,UAAKC,CAAAA,kBAAL,EAAA;AAD4D,KAA9D;AAIAV,UAAOW,CAAAA,WAAP,GAAqBC,QAAoB,EAAG;AAC1C,UAAIC,UAAU,IAAKhC,CAAAA,KAAMgC,CAAAA,OAAzB,EACU1B,KADV,EACiBF,MADjB;AAEA,UAAA6B,OAAO3B,KAAP2B,GAAe7B,MAAf6B,GAAwBD,OAAxB;AAEe,UAAf,IAAIA,OAAJ,IAA0C,QAA1C,KAAuB,MAAOA,QAA9B,KACEC,IAGA,GAHOD,OAAQC,CAAAA,IAGf,EAFA3B,KAEA,GAFQ0B,OAAQ1B,CAAAA,KAEhB,EAAAF,MAAA,GAA4B8B,IAAAA,EAAnB,KAAAF,OAAQ5B,CAAAA,MAAR,GAA+B4B,OAAQ5B,CAAAA,MAAvC,GAAgDE,KAJ3D;AAOA,aAAO,CACC2B,IADD,EAEE3B,KAFF,EAGGF,MAHH,CAAP;AAZ0C,KAA5C;AAmBAe,UAAOG,CAAAA,YAAP,GAAsBa,QAAqB,CAACC,QAAD,EAAWV,UAAX,CAAuB;AAC/C,UAAK,EAAtB,KAAIU,QAAJ,KACEA,QADF,GACa,CAAA,CADb;AAImB,UAAnB,KAAIV,UAAJ,IAEE,IAAKG,CAAAA,kBAAL,EAEA,EA5NSzC,UA4NT,KAAIsC,UAAJ,IASE,CARI,IAAK1B,CAAAA,KAAMU,CAAAA,aAQf,IARgC,IAAKV,CAAAA,KAAMW,CAAAA,YAQ3C,MAPM0B,UAON,GAPa,IAAKrC,CAAAA,KAAMsC,CAAAA,OAAX,GAAqB,IAAKtC,CAAAA,KAAMsC,CAAAA,OAAQC,CAAAA,OAAxC,GAAkD9C,SAAUjB,CAAAA,OAAQgE,CAAAA,WAAlB,CAA8B,IAA9B,CAO/D,KAHY,GAAI3C,OAAQ4C,CAAAA,WAAZ,EAAyBJ,UAAzB,CAGZ,EAAA,IAAKK,CAAAA,YAAL,CAAkBN,QAAlB,CATF,IAWE,IAAKO,CAAAA,WAAL,EAfJ,IAiBW,IAAK3C,CAAAA,KAAMU,CAAAA,aAjBtB,IA1NSrB,QA0NT,KAiBuC,IAAKuB,CAAAA,KAAMC,CAAAA,MAjBlD,IAkBE,IAAK+B,CAAAA,QAAL,CAAc,CACZ/B,OA/OQvB,WA8OI,CAAd,CAlBF;AALgE,KAAlE;AA6BA6B,UAAOuB,CAAAA,YAAP,GAAsBG,QAAqB,CAACT,QAAD,CAAW;AACpD,UAAIU,SAAS,IAAb,EAEIxC,QAAQ,IAAKN,CAAAA,KAAMM,CAAAA,KAFvB,EAGIyC,YAAY,IAAK9C,CAAAA,OAAL,GAAe,IAAKA,CAAAA,OAAQI,CAAAA,UAA5B,GAAyC+B,QAHzD,EAKIY,QAAQ,IAAKhD,CAAAA,KAAMsC,CAAAA,OAAX,GAAqB,CAACS,SAAD,CAArB,GAAmC,CAACtD,SAAUjB,CAAAA,OAAQgE,CAAAA,WAAlB,CAA8B,IAA9B,CAAD,EAAsCO,SAAtC,CAL/C,EAMIE,YAAYD,KAAA,CAAM,CAAN,CANhB,EAOIE,iBAAiBF,KAAA,CAAM,CAAN,CAPrB;AASIG,WAAAA,GAAW,IAAKrB,CAAAA,WAAL,EAAXqB;AACJ,UAAIC,eAAeL,SAAA,GAAYI,KAAS/C,CAAAA,MAArB,GAA8B+C,KAAS7C,CAAAA,KAA1D;AAGI,OAAC8B,QAAL,IAAiB,CAAC9B,KAAlB,IAA2BZ,OAAQlB,CAAAA,OAAQ6E,CAAAA,QAA3C,GACE,IAAKC,CAAAA,YAAL,CAAkB,CAChBzC,OA9PM1B,SA6PU,CAAlB,EAEG,QAAS,EAAG;AACb2D,cAAO9C,CAAAA,KAAMuD,CAAAA,SAAb,CAAuBN,SAAvB,CAAA;AADa,OAFf,CADF,IASA,IAAKjD,CAAAA,KAAMwD,CAAAA,OAAX,CAAmBP,SAAnB,EAA8BC,cAA9B,CACA,EAAA,IAAKI,CAAAA,YAAL,CAAkB,CAChBzC,OAzQSzB,UAwQO,CAAlB,EAEG,QAAS,EAAG;AACb0D,cAAO9C,CAAAA,KAAMyD,CAAAA,UAAb,CAAwBR,SAAxB,EAAmCC,cAAnC,CAAA;AAEAJ,cAAOY,CAAAA,eAAP,CAAuBN,YAAvB,EAAqC,QAAS,EAAG;AAC/CN,gBAAOQ,CAAAA,YAAP,CAAoB,CAClBzC,OA7QI1B,SA4Qc,CAApB,EAEG,QAAS,EAAG;AACb2D,kBAAO9C,CAAAA,KAAMuD,CAAAA,SAAb,CAAuBN,SAAvB,EAAkCC,cAAlC,CAAA;AADa,WAFf,CAAA;AAD+C,SAAjD,CAAA;AAHa,OAFf,CAVA,CAAA;AAdoD,KAAtD;AAuCA/B,UAAOwB,CAAAA,WAAP,GAAqBgB,QAAoB,EAAG;AAC1C,UAAIC,SAAS,IAAb,EAEI3B,OAAO,IAAKjC,CAAAA,KAAMiC,CAAAA,IAFtB,EAGIkB,WAAW,IAAKrB,CAAAA,WAAL,EAHf,EAIImB,YAAY,IAAKjD,CAAAA,KAAMsC,CAAAA,OAAX,GAAqBJ,IAAAA,EAArB,GAAiCzC,SAAUjB,CAAAA,OAAQgE,CAAAA,WAAlB,CAA8B,IAA9B,CAJjD;AAMI,OAACP,IAAL,IAAavC,OAAQlB,CAAAA,OAAQ6E,CAAAA,QAA7B,GACE,IAAKC,CAAAA,YAAL,CAAkB,CAChBzC,OAlSKxB,QAiSW,CAAlB,EAEG,QAAS,EAAG;AACbuE,cAAO5D,CAAAA,KAAM6D,CAAAA,QAAb,CAAsBZ,SAAtB,CAAA;AADa,OAFf,CADF,IASA,IAAKjD,CAAAA,KAAM8D,CAAAA,MAAX,CAAkBb,SAAlB,CACA,EAAA,IAAKK,CAAAA,YAAL,CAAkB,CAChBzC,OArSQ3B,SAoSQ,CAAlB,EAEG,QAAS,EAAG;AACb0E,cAAO5D,CAAAA,KAAM+D,CAAAA,SAAb,CAAuBd,SAAvB,CAAA;AAEAW,cAAOF,CAAAA,eAAP,CAAuBP,QAASlB,CAAAA,IAAhC,EAAsC,QAAS,EAAG;AAChD2B,gBAAON,CAAAA,YAAP,CAAoB,CAClBzC,OAjTGxB,QAgTe,CAApB,EAEG,QAAS,EAAG;AACbuE,kBAAO5D,CAAAA,KAAM6D,CAAAA,QAAb,CAAsBZ,SAAtB,CAAA;AADa,WAFf,CAAA;AADgD,SAAlD,CAAA;AAHa,OAFf,CAVA,CAAA;AAP0C,KAA5C;AAgCA9B,UAAOU,CAAAA,kBAAP,GAA4BmC,QAA2B,EAAG;AAC9B,UAA1B,KAAI,IAAKlD,CAAAA,YAAT,KACE,IAAKA,CAAAA,YAAamD,CAAAA,MAAlB,EACA,EAAA,IAAKnD,CAAAA,YAAL,GAAoB,IAFtB;AADwD,KAA1D;AAOAK,UAAOmC,CAAAA,YAAP,GAAsBY,QAAqB,CAACC,SAAD,EAAYC,QAAZ,CAAsB;AAI/DA,cAAA,GAAW,IAAKC,CAAAA,eAAL,CAAqBD,QAArB,CAAX;AACA,UAAKxB,CAAAA,QAAL,CAAcuB,SAAd,EAAyBC,QAAzB,CAAA;AAL+D,KAAjE;AAQAjD,UAAOkD,CAAAA,eAAP,GAAyBC,QAAwB,CAACF,QAAD,CAAW;AAC1D,UAAIG,SAAS,IAAb,EAEIC,SAAS,CAAA,CAFb;AAIA,UAAK1D,CAAAA,YAAL,GAAoB2D,QAAS,CAACC,KAAD,CAAQ;AAC/BF,cAAJ,KACEA,MAEA,GAFS,CAAA,CAET,EADAD,MAAOzD,CAAAA,YACP,GADsB,IACtB,EAAAsD,QAAA,CAASM,KAAT,CAHF;AADmC,OAArC;AAQA,UAAK5D,CAAAA,YAAamD,CAAAA,MAAlB,GAA2BU,QAAS,EAAG;AACrCH,cAAA,GAAS,CAAA,CAAT;AADqC,OAAvC;AAIA,aAAO,IAAK1D,CAAAA,YAAZ;AAjB0D,KAA5D;AAoBAK,UAAOuC,CAAAA,eAAP,GAAyBkB,QAAwB,CAAC5C,OAAD,EAAU6C,OAAV,CAAmB;AAClE,UAAKR,CAAAA,eAAL,CAAqBQ,OAArB,CAAA;AACIxC,aAAAA,GAAO,IAAKrC,CAAAA,KAAMsC,CAAAA,OAAX,GAAqB,IAAKtC,CAAAA,KAAMsC,CAAAA,OAAQC,CAAAA,OAAxC,GAAkD9C,SAAUjB,CAAAA,OAAQgE,CAAAA,WAAlB,CAA8B,IAA9B,CAAzDH;AACJ,UAAIyC,+BAA0C,IAA1CA,IAA+B9C,OAA/B8C,IAAkD,CAAC,IAAK9E,CAAAA,KAAM+E,CAAAA,cAAlE;AAEI,OAAC1C,OAAL,IAAayC,4BAAb,GACEE,UAAA,CAAW,IAAKlE,CAAAA,YAAhB,EAA8B,CAA9B,CADF,IAKI,IAAKd,CAAAA,KAAM+E,CAAAA,cAQf,KAPME,OAIJ,GAJY,IAAKjF,CAAAA,KAAMsC,CAAAA,OAAX,GAAqB,CAAC,IAAKxB,CAAAA,YAAN,CAArB,GAA2C,CAACuB,OAAD,EAAO,IAAKvB,CAAAA,YAAZ,CAIvD,EAAA,IAAKd,CAAAA,KAAM+E,CAAAA,cAAX,CAHgBE,OAAAhC,CAAM,CAANA,CAGhB,EAFwBgC,OAAAC,CAAM,CAANA,CAExB,CAGF,GAAe,IAAf,IAAIlD,OAAJ,IACEgD,UAAA,CAAW,IAAKlE,CAAAA,YAAhB,EAA8BkB,OAA9B,CAdF,CAAA;AALkE,KAApE;AAuBAb,UAAOgE,CAAAA,MAAP,GAAgBC,QAAe,EAAG;AAChC,UAAIvE,SAAS,IAAKD,CAAAA,KAAMC,CAAAA,MAAxB;AAEA,UAxXYvB,WAwXZ,KAAIuB,MAAJ;AACE,eAAO,IAAP;AADF;AAHgC,UAO5BwE,cAAc,IAAKrF,CAAAA,KAPS,EAQ5BsF,WAAWD,WAAYC,CAAAA,QARK;AAwB4B,UAAA,WAAA,gJAAA,CAAA,KAAA,CAAA,GAAA,CAAA;AAjZL,UAAc,IAAd,IAiZRD,WAjZQ;AAAoB,mBAAA,GAAO,EAAP;AAApB,YAAA;AAA+B,YAAIE,SAAS,EAAb,EAAqBC,aAAa3G,MAAO4G,CAAAA,IAAP,CAiZzEJ,WAjZyE,CAAlC,EAAgEK,CAAhE;AAAmE,aAAKA,CAAL,GAAS,CAAT,EAAYA,CAAZ,GAAgBF,UAAWG,CAAAA,MAA3B,EAAmCD,CAAA,EAAnC,CAAwC;AAAE,cAAAE,MAAMJ,UAAA,CAAWE,CAAX,CAAN;AAAkD,WAA7B,IAAIG,QAASC,CAAAA,OAAT,CAAiBF,GAAjB,CAAJ,KAA0CL,MAAA,CAAOK,GAAP,CAA1C,GAiZzKP,WAjZiO,CAAOO,GAAP,CAAxD;AAAvB;AAA8F,mBAAA,GAAOL,MAAP;AAAxO;AAmZvD,aAGE/F,MAAOhB,CAAAA,OAAQuH,CAAAA,aAAf,CAA6BnG,uBAAwBpB,CAAAA,OAAQwH,CAAAA,QAA7D,EAAuE,CACrEC,MAAO,IAD8D,CAAvE,EAEuB,UAApB,KAAA,MAAOX,SAAP,GAAiCA,QAAA,CAASzE,MAAT,EAAiBqF,WAAjB,CAAjC,GAAgE1G,MAAOhB,CAAAA,OAAQ2H,CAAAA,YAAf,CAA4B3G,MAAOhB,CAAAA,OAAQ4H,CAAAA,QAASC,CAAAA,IAAxB,CAA6Bf,QAA7B,CAA5B,EAAoEY,WAApE,CAFnE,CAHF;AA1BgC,KAAlC;AAmCA,WAAOpG,UAAP;AAjTwD,GAA5B,CAkT5BN,MAAOhB,CAAAA,OAAQ8H,CAAAA,SAlTa,CAA1BxG;AAoTJA,QAAWyG,CAAAA,WAAX,GAAyB3G,uBAAwBpB,CAAAA,OAAjD;AACAsB,QAAW0G,CAAAA,SAAX,GAA+D,CAY7DlE,QAAS/C,UAAWf,CAAAA,OAAQiI,CAAAA,KAAnB,CAAyB,CAChClE,QAA4B,WAAnB,KAAA,MAAOmE,QAAP,GAAiCnH,UAAWf,CAAAA,OAAQmI,CAAAA,GAApD,GAA0D,QAAS,CAACC,SAAD,EAAYhB,GAAZ,EAAiBiB,aAAjB,EAAgCC,QAAhC,EAA0CC,YAA1C,EAAwDC,MAAxD,CAAgE;AAC1I,QAAIf,QAAQW,SAAA,CAAUhB,GAAV,CAAZ;AACA,WAAOrG,UAAWf,CAAAA,OAAQyI,CAAAA,UAAnB,CAA8BhB,KAAA,IAAS,eAAT,IAA4BA,KAA5B,GAAoCA,KAAMiB,CAAAA,aAAcC,CAAAA,WAAYT,CAAAA,OAApE,GAA8EA,OAA5G,CAAA,CAAqHE,SAArH,EAAgIhB,GAAhI,EAAqIiB,aAArI,EAAoJC,QAApJ,EAA8JC,YAA9J,EAA4KC,MAA5K,CAAP;AAF0I,GAD5G,CAAzB,CAZoD,EAiC7D1B,SAAU/F,UAAWf,CAAAA,OAAQ4I,CAAAA,SAAnB,CAA6B,CAAC7H,UAAWf,CAAAA,OAAQ6I,CAAAA,IAAKC,CAAAA,UAAzB,EAAqC/H,UAAWf,CAAAA,OAAQ+I,CAAAA,OAAQD,CAAAA,UAAhE,CAA7B,CAA0GA,CAAAA,UAjCvD,EAsC7D9G,GAAIjB,UAAWf,CAAAA,OAAQgJ,CAAAA,IAtCsC,EA8C7D7G,aAAcpB,UAAWf,CAAAA,OAAQgJ,CAAAA,IA9C4B,EAoD7D9G,cAAenB,UAAWf,CAAAA,OAAQgJ,CAAAA,IApD2B,EAiE7DpH,OAAQb,UAAWf,CAAAA,OAAQgJ,CAAAA,IAjEkC,EAsE7DlH,MAAOf,UAAWf,CAAAA,OAAQgJ,CAAAA,IAtEmC,EA2E7DvF,KAAM1C,UAAWf,CAAAA,OAAQgJ,CAAAA,IA3EoC,EAuG7DxF,QAASA,QAAgB,CAAChC,KAAD,CAAQ;AAC/B,QAAIyH,KAAK9H,UAAW+H,CAAAA,aAApB;AACK1H,SAAM+E,CAAAA,cAAX,KAA2B0C,EAA3B,GAAgCA,EAAGH,CAAAA,UAAnC;AAEA,SAJ+B,IAItBK,OAAOC,SAAUjC,CAAAA,MAJK,EAIGkC,OAAWC,KAAJ,CAAiB,CAAP,GAAAH,IAAA,GAAWA,IAAX,GAAkB,CAAlB,GAAsB,CAAhC,CAJV,EAI8CI,OAAO,CAApF,EAAuFA,IAAvF,GAA8FJ,IAA9F,EAAoGI,IAAA,EAApG;AACEF,UAAA,CAAKE,IAAL,GAAY,CAAZ,CAAA,GAAiBH,SAAA,CAAUG,IAAV,CAAjB;AADF;AAIA,WAAON,EAAGO,CAAAA,KAAH,CAAS,IAAK,EAAd,EAAiB,CAAChI,KAAD,CAAQiI,CAAAA,MAAR,CAAeJ,IAAf,CAAjB,CAAP;AAR+B,GAvG4B,EAgI7D9C,eAAgBxF,UAAWf,CAAAA,OAAQ6I,CAAAA,IAhI0B,EA0I7D7D,QAASjE,UAAWf,CAAAA,OAAQ6I,CAAAA,IA1IiC,EAoJ7D5D,WAAYlE,UAAWf,CAAAA,OAAQ6I,CAAAA,IApJ8B,EA8J7D9D,UAAWhE,UAAWf,CAAAA,OAAQ6I,CAAAA,IA9J+B,EAuK7DvD,OAAQvE,UAAWf,CAAAA,OAAQ6I,CAAAA,IAvKkC,EAgL7DtD,UAAWxE,UAAWf,CAAAA,OAAQ6I,CAAAA,IAhL+B,EAyL7DxD,SAAUtE,UAAWf,CAAAA,OAAQ6I,CAAAA,IAzLgC,CAA/D;AA8LAvH,QAAWoI,CAAAA,YAAX,GAA0B,CACxB1H,GAAI,CAAA,CADoB,EAExBG,aAAc,CAAA,CAFU,EAGxBD,cAAe,CAAA,CAHS,EAIxBN,OAAQ,CAAA,CAJgB,EAKxBE,MAAO,CAAA,CALiB,EAMxB2B,KAAM,CAAA,CANkB,EAOxBuB,QAASvE,IAPe,EAQxBwE,WAAYxE,IARY,EASxBsE,UAAWtE,IATa,EAUxB6E,OAAQ7E,IAVgB,EAWxB8E,UAAW9E,IAXa,EAYxB4E,SAAU5E,IAZc,CAA1B;AAcAa,QAAWR,CAAAA,SAAX,GAxmBgBA,WAwmBhB;AACAQ,QAAWT,CAAAA,MAAX,GAvmBaA,QAumBb;AACAS,QAAWV,CAAAA,QAAX,GAtmBeA,UAsmBf;AACAU,QAAWX,CAAAA,OAAX,GArmBcA,SAqmBd;AACAW,QAAWZ,CAAAA,OAAX,GApmBcA,SAomBd;AAEAd,SAAQI,CAAAA,OAAR,GADesB,MACf;AAxoBsH,CAAtH;;\",\n\"sources\":[\"node_modules/react-transition-group/cjs/Transition.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$cjs$Transition\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nexports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;\\n\\nvar _propTypes = _interopRequireDefault(require(\\\"prop-types\\\"));\\n\\nvar _react = _interopRequireDefault(require(\\\"react\\\"));\\n\\nvar _reactDom = _interopRequireDefault(require(\\\"react-dom\\\"));\\n\\nvar _config = _interopRequireDefault(require(\\\"./config\\\"));\\n\\nvar _PropTypes = require(\\\"./utils/PropTypes\\\");\\n\\nvar _TransitionGroupContext = _interopRequireDefault(require(\\\"./TransitionGroupContext\\\"));\\n\\nvar _reflow = require(\\\"./utils/reflow\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\\n\\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\\n\\nvar UNMOUNTED = 'unmounted';\\nexports.UNMOUNTED = UNMOUNTED;\\nvar EXITED = 'exited';\\nexports.EXITED = EXITED;\\nvar ENTERING = 'entering';\\nexports.ENTERING = ENTERING;\\nvar ENTERED = 'entered';\\nexports.ENTERED = ENTERED;\\nvar EXITING = 'exiting';\\n/**\\n * The Transition component lets you describe a transition from one component\\n * state to another _over time_ with a simple declarative API. Most commonly\\n * it's used to animate the mounting and unmounting of a component, but can also\\n * be used to describe in-place transition states as well.\\n *\\n * ---\\n *\\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\\n * transitions in CSS, you'll probably want to use\\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\\n * instead. It inherits all the features of `Transition`, but contains\\n * additional features necessary to play nice with CSS transitions (hence the\\n * name of the component).\\n *\\n * ---\\n *\\n * By default the `Transition` component does not alter the behavior of the\\n * component it renders, it only tracks \\\"enter\\\" and \\\"exit\\\" states for the\\n * components. It's up to you to give meaning and effect to those states. For\\n * example we can add styles to a component when it enters or exits:\\n *\\n * ```jsx\\n * import { Transition } from 'react-transition-group';\\n *\\n * const duration = 300;\\n *\\n * const defaultStyle = {\\n *   transition: `opacity ${duration}ms ease-in-out`,\\n *   opacity: 0,\\n * }\\n *\\n * const transitionStyles = {\\n *   entering: { opacity: 1 },\\n *   entered:  { opacity: 1 },\\n *   exiting:  { opacity: 0 },\\n *   exited:  { opacity: 0 },\\n * };\\n *\\n * const Fade = ({ in: inProp }) => (\\n *   <Transition in={inProp} timeout={duration}>\\n *     {state => (\\n *       <div style={{\\n *         ...defaultStyle,\\n *         ...transitionStyles[state]\\n *       }}>\\n *         I'm a fade Transition!\\n *       </div>\\n *     )}\\n *   </Transition>\\n * );\\n * ```\\n *\\n * There are 4 main states a Transition can be in:\\n *  - `'entering'`\\n *  - `'entered'`\\n *  - `'exiting'`\\n *  - `'exited'`\\n *\\n * Transition state is toggled via the `in` prop. When `true` the component\\n * begins the \\\"Enter\\\" stage. During this stage, the component will shift from\\n * its current transition state, to `'entering'` for the duration of the\\n * transition and then to the `'entered'` stage once it's complete. Let's take\\n * the following example (we'll use the\\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\\n *\\n * ```jsx\\n * function App() {\\n *   const [inProp, setInProp] = useState(false);\\n *   return (\\n *     <div>\\n *       <Transition in={inProp} timeout={500}>\\n *         {state => (\\n *           // ...\\n *         )}\\n *       </Transition>\\n *       <button onClick={() => setInProp(true)}>\\n *         Click to Enter\\n *       </button>\\n *     </div>\\n *   );\\n * }\\n * ```\\n *\\n * When the button is clicked the component will shift to the `'entering'` state\\n * and stay there for 500ms (the value of `timeout`) before it finally switches\\n * to `'entered'`.\\n *\\n * When `in` is `false` the same thing happens except the state moves from\\n * `'exiting'` to `'exited'`.\\n */\\n\\nexports.EXITING = EXITING;\\n\\nvar Transition = /*#__PURE__*/function (_React$Component) {\\n  _inheritsLoose(Transition, _React$Component);\\n\\n  function Transition(props, context) {\\n    var _this;\\n\\n    _this = _React$Component.call(this, props, context) || this;\\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\\n\\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\\n    var initialStatus;\\n    _this.appearStatus = null;\\n\\n    if (props.in) {\\n      if (appear) {\\n        initialStatus = EXITED;\\n        _this.appearStatus = ENTERING;\\n      } else {\\n        initialStatus = ENTERED;\\n      }\\n    } else {\\n      if (props.unmountOnExit || props.mountOnEnter) {\\n        initialStatus = UNMOUNTED;\\n      } else {\\n        initialStatus = EXITED;\\n      }\\n    }\\n\\n    _this.state = {\\n      status: initialStatus\\n    };\\n    _this.nextCallback = null;\\n    return _this;\\n  }\\n\\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\\n    var nextIn = _ref.in;\\n\\n    if (nextIn && prevState.status === UNMOUNTED) {\\n      return {\\n        status: EXITED\\n      };\\n    }\\n\\n    return null;\\n  } // getSnapshotBeforeUpdate(prevProps) {\\n  //   let nextStatus = null\\n  //   if (prevProps !== this.props) {\\n  //     const { status } = this.state\\n  //     if (this.props.in) {\\n  //       if (status !== ENTERING && status !== ENTERED) {\\n  //         nextStatus = ENTERING\\n  //       }\\n  //     } else {\\n  //       if (status === ENTERING || status === ENTERED) {\\n  //         nextStatus = EXITING\\n  //       }\\n  //     }\\n  //   }\\n  //   return { nextStatus }\\n  // }\\n  ;\\n\\n  var _proto = Transition.prototype;\\n\\n  _proto.componentDidMount = function componentDidMount() {\\n    this.updateStatus(true, this.appearStatus);\\n  };\\n\\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\\n    var nextStatus = null;\\n\\n    if (prevProps !== this.props) {\\n      var status = this.state.status;\\n\\n      if (this.props.in) {\\n        if (status !== ENTERING && status !== ENTERED) {\\n          nextStatus = ENTERING;\\n        }\\n      } else {\\n        if (status === ENTERING || status === ENTERED) {\\n          nextStatus = EXITING;\\n        }\\n      }\\n    }\\n\\n    this.updateStatus(false, nextStatus);\\n  };\\n\\n  _proto.componentWillUnmount = function componentWillUnmount() {\\n    this.cancelNextCallback();\\n  };\\n\\n  _proto.getTimeouts = function getTimeouts() {\\n    var timeout = this.props.timeout;\\n    var exit, enter, appear;\\n    exit = enter = appear = timeout;\\n\\n    if (timeout != null && typeof timeout !== 'number') {\\n      exit = timeout.exit;\\n      enter = timeout.enter; // TODO: remove fallback for next major\\n\\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\\n    }\\n\\n    return {\\n      exit: exit,\\n      enter: enter,\\n      appear: appear\\n    };\\n  };\\n\\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\\n    if (mounting === void 0) {\\n      mounting = false;\\n    }\\n\\n    if (nextStatus !== null) {\\n      // nextStatus will always be ENTERING or EXITING.\\n      this.cancelNextCallback();\\n\\n      if (nextStatus === ENTERING) {\\n        if (this.props.unmountOnExit || this.props.mountOnEnter) {\\n          var node = this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749\\n          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.\\n          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.\\n\\n          if (node) (0, _reflow.forceReflow)(node);\\n        }\\n\\n        this.performEnter(mounting);\\n      } else {\\n        this.performExit();\\n      }\\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\\n      this.setState({\\n        status: UNMOUNTED\\n      });\\n    }\\n  };\\n\\n  _proto.performEnter = function performEnter(mounting) {\\n    var _this2 = this;\\n\\n    var enter = this.props.enter;\\n    var appearing = this.context ? this.context.isMounting : mounting;\\n\\n    var _ref2 = this.props.nodeRef ? [appearing] : [_reactDom.default.findDOMNode(this), appearing],\\n        maybeNode = _ref2[0],\\n        maybeAppearing = _ref2[1];\\n\\n    var timeouts = this.getTimeouts();\\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\\n    // if we are mounting and running this it means appear _must_ be set\\n\\n    if (!mounting && !enter || _config.default.disabled) {\\n      this.safeSetState({\\n        status: ENTERED\\n      }, function () {\\n        _this2.props.onEntered(maybeNode);\\n      });\\n      return;\\n    }\\n\\n    this.props.onEnter(maybeNode, maybeAppearing);\\n    this.safeSetState({\\n      status: ENTERING\\n    }, function () {\\n      _this2.props.onEntering(maybeNode, maybeAppearing);\\n\\n      _this2.onTransitionEnd(enterTimeout, function () {\\n        _this2.safeSetState({\\n          status: ENTERED\\n        }, function () {\\n          _this2.props.onEntered(maybeNode, maybeAppearing);\\n        });\\n      });\\n    });\\n  };\\n\\n  _proto.performExit = function performExit() {\\n    var _this3 = this;\\n\\n    var exit = this.props.exit;\\n    var timeouts = this.getTimeouts();\\n    var maybeNode = this.props.nodeRef ? undefined : _reactDom.default.findDOMNode(this); // no exit animation skip right to EXITED\\n\\n    if (!exit || _config.default.disabled) {\\n      this.safeSetState({\\n        status: EXITED\\n      }, function () {\\n        _this3.props.onExited(maybeNode);\\n      });\\n      return;\\n    }\\n\\n    this.props.onExit(maybeNode);\\n    this.safeSetState({\\n      status: EXITING\\n    }, function () {\\n      _this3.props.onExiting(maybeNode);\\n\\n      _this3.onTransitionEnd(timeouts.exit, function () {\\n        _this3.safeSetState({\\n          status: EXITED\\n        }, function () {\\n          _this3.props.onExited(maybeNode);\\n        });\\n      });\\n    });\\n  };\\n\\n  _proto.cancelNextCallback = function cancelNextCallback() {\\n    if (this.nextCallback !== null) {\\n      this.nextCallback.cancel();\\n      this.nextCallback = null;\\n    }\\n  };\\n\\n  _proto.safeSetState = function safeSetState(nextState, callback) {\\n    // This shouldn't be necessary, but there are weird race conditions with\\n    // setState callbacks and unmounting in testing, so always make sure that\\n    // we can cancel any pending setState callbacks after we unmount.\\n    callback = this.setNextCallback(callback);\\n    this.setState(nextState, callback);\\n  };\\n\\n  _proto.setNextCallback = function setNextCallback(callback) {\\n    var _this4 = this;\\n\\n    var active = true;\\n\\n    this.nextCallback = function (event) {\\n      if (active) {\\n        active = false;\\n        _this4.nextCallback = null;\\n        callback(event);\\n      }\\n    };\\n\\n    this.nextCallback.cancel = function () {\\n      active = false;\\n    };\\n\\n    return this.nextCallback;\\n  };\\n\\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\\n    this.setNextCallback(handler);\\n    var node = this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this);\\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\\n\\n    if (!node || doesNotHaveTimeoutOrListener) {\\n      setTimeout(this.nextCallback, 0);\\n      return;\\n    }\\n\\n    if (this.props.addEndListener) {\\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\\n          maybeNode = _ref3[0],\\n          maybeNextCallback = _ref3[1];\\n\\n      this.props.addEndListener(maybeNode, maybeNextCallback);\\n    }\\n\\n    if (timeout != null) {\\n      setTimeout(this.nextCallback, timeout);\\n    }\\n  };\\n\\n  _proto.render = function render() {\\n    var status = this.state.status;\\n\\n    if (status === UNMOUNTED) {\\n      return null;\\n    }\\n\\n    var _this$props = this.props,\\n        children = _this$props.children,\\n        _in = _this$props.in,\\n        _mountOnEnter = _this$props.mountOnEnter,\\n        _unmountOnExit = _this$props.unmountOnExit,\\n        _appear = _this$props.appear,\\n        _enter = _this$props.enter,\\n        _exit = _this$props.exit,\\n        _timeout = _this$props.timeout,\\n        _addEndListener = _this$props.addEndListener,\\n        _onEnter = _this$props.onEnter,\\n        _onEntering = _this$props.onEntering,\\n        _onEntered = _this$props.onEntered,\\n        _onExit = _this$props.onExit,\\n        _onExiting = _this$props.onExiting,\\n        _onExited = _this$props.onExited,\\n        _nodeRef = _this$props.nodeRef,\\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\\\"children\\\", \\\"in\\\", \\\"mountOnEnter\\\", \\\"unmountOnExit\\\", \\\"appear\\\", \\\"enter\\\", \\\"exit\\\", \\\"timeout\\\", \\\"addEndListener\\\", \\\"onEnter\\\", \\\"onEntering\\\", \\\"onEntered\\\", \\\"onExit\\\", \\\"onExiting\\\", \\\"onExited\\\", \\\"nodeRef\\\"]);\\n\\n    return (\\n      /*#__PURE__*/\\n      // allows for nested Transitions\\n      _react.default.createElement(_TransitionGroupContext.default.Provider, {\\n        value: null\\n      }, typeof children === 'function' ? children(status, childProps) : _react.default.cloneElement(_react.default.Children.only(children), childProps))\\n    );\\n  };\\n\\n  return Transition;\\n}(_react.default.Component);\\n\\nTransition.contextType = _TransitionGroupContext.default;\\nTransition.propTypes = process.env.NODE_ENV !== \\\"production\\\" ? {\\n  /**\\n   * A React reference to DOM element that need to transition:\\n   * https://stackoverflow.com/a/51127130/4671932\\n   *\\n   *   - When `nodeRef` prop is used, `node` is not passed to callback functions\\n   *      (e.g. `onEnter`) because user already has direct access to the node.\\n   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new\\n   *     `nodeRef` need to be provided to `Transition` with changed `key` prop\\n   *     (see\\n   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).\\n   */\\n  nodeRef: _propTypes.default.shape({\\n    current: typeof Element === 'undefined' ? _propTypes.default.any : function (propValue, key, componentName, location, propFullName, secret) {\\n      var value = propValue[key];\\n      return _propTypes.default.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);\\n    }\\n  }),\\n\\n  /**\\n   * A `function` child can be used instead of a React element. This function is\\n   * called with the current transition status (`'entering'`, `'entered'`,\\n   * `'exiting'`, `'exited'`), which can be used to apply context\\n   * specific props to a component.\\n   *\\n   * ```jsx\\n   * <Transition in={this.state.in} timeout={150}>\\n   *   {state => (\\n   *     <MyComponent className={`fade fade-${state}`} />\\n   *   )}\\n   * </Transition>\\n   * ```\\n   */\\n  children: _propTypes.default.oneOfType([_propTypes.default.func.isRequired, _propTypes.default.element.isRequired]).isRequired,\\n\\n  /**\\n   * Show the component; triggers the enter or exit states\\n   */\\n  in: _propTypes.default.bool,\\n\\n  /**\\n   * By default the child component is mounted immediately along with\\n   * the parent `Transition` component. If you want to \\\"lazy mount\\\" the component on the\\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\\n   * mounted, even on \\\"exited\\\", unless you also specify `unmountOnExit`.\\n   */\\n  mountOnEnter: _propTypes.default.bool,\\n\\n  /**\\n   * By default the child component stays mounted after it reaches the `'exited'` state.\\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\\n   */\\n  unmountOnExit: _propTypes.default.bool,\\n\\n  /**\\n   * By default the child component does not perform the enter transition when\\n   * it first mounts, regardless of the value of `in`. If you want this\\n   * behavior, set both `appear` and `in` to `true`.\\n   *\\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\\n   * > only adds an additional enter transition. However, in the\\n   * > `<CSSTransition>` component that first enter transition does result in\\n   * > additional `.appear-*` classes, that way you can choose to style it\\n   * > differently.\\n   */\\n  appear: _propTypes.default.bool,\\n\\n  /**\\n   * Enable or disable enter transitions.\\n   */\\n  enter: _propTypes.default.bool,\\n\\n  /**\\n   * Enable or disable exit transitions.\\n   */\\n  exit: _propTypes.default.bool,\\n\\n  /**\\n   * The duration of the transition, in milliseconds.\\n   * Required unless `addEndListener` is provided.\\n   *\\n   * You may specify a single timeout for all transitions:\\n   *\\n   * ```jsx\\n   * timeout={500}\\n   * ```\\n   *\\n   * or individually:\\n   *\\n   * ```jsx\\n   * timeout={{\\n   *  appear: 500,\\n   *  enter: 300,\\n   *  exit: 500,\\n   * }}\\n   * ```\\n   *\\n   * - `appear` defaults to the value of `enter`\\n   * - `enter` defaults to `0`\\n   * - `exit` defaults to `0`\\n   *\\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\\n   */\\n  timeout: function timeout(props) {\\n    var pt = _PropTypes.timeoutsShape;\\n    if (!props.addEndListener) pt = pt.isRequired;\\n\\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      args[_key - 1] = arguments[_key];\\n    }\\n\\n    return pt.apply(void 0, [props].concat(args));\\n  },\\n\\n  /**\\n   * Add a custom transition end trigger. Called with the transitioning\\n   * DOM node and a `done` callback. Allows for more fine grained transition end\\n   * logic. Timeouts are still used as a fallback if provided.\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\\n   *\\n   * ```jsx\\n   * addEndListener={(node, done) => {\\n   *   // use the css transitionend event to mark the finish of a transition\\n   *   node.addEventListener('transitionend', done, false);\\n   * }}\\n   * ```\\n   */\\n  addEndListener: _propTypes.default.func,\\n\\n  /**\\n   * Callback fired before the \\\"entering\\\" status is applied. An extra parameter\\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\\n   *\\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\\n   */\\n  onEnter: _propTypes.default.func,\\n\\n  /**\\n   * Callback fired after the \\\"entering\\\" status is applied. An extra parameter\\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\\n   *\\n   * @type Function(node: HtmlElement, isAppearing: bool)\\n   */\\n  onEntering: _propTypes.default.func,\\n\\n  /**\\n   * Callback fired after the \\\"entered\\\" status is applied. An extra parameter\\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\\n   *\\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\\n   */\\n  onEntered: _propTypes.default.func,\\n\\n  /**\\n   * Callback fired before the \\\"exiting\\\" status is applied.\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\\n   *\\n   * @type Function(node: HtmlElement) -> void\\n   */\\n  onExit: _propTypes.default.func,\\n\\n  /**\\n   * Callback fired after the \\\"exiting\\\" status is applied.\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\\n   *\\n   * @type Function(node: HtmlElement) -> void\\n   */\\n  onExiting: _propTypes.default.func,\\n\\n  /**\\n   * Callback fired after the \\\"exited\\\" status is applied.\\n   *\\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\\n   *\\n   * @type Function(node: HtmlElement) -> void\\n   */\\n  onExited: _propTypes.default.func\\n} : {}; // Name the function so it is clearer in the documentation\\n\\nfunction noop() {}\\n\\nTransition.defaultProps = {\\n  in: false,\\n  mountOnEnter: false,\\n  unmountOnExit: false,\\n  appear: false,\\n  enter: true,\\n  exit: true,\\n  onEnter: noop,\\n  onEntering: noop,\\n  onEntered: noop,\\n  onExit: noop,\\n  onExiting: noop,\\n  onExited: noop\\n};\\nTransition.UNMOUNTED = UNMOUNTED;\\nTransition.EXITED = EXITED;\\nTransition.ENTERING = ENTERING;\\nTransition.ENTERED = ENTERED;\\nTransition.EXITING = EXITING;\\nvar _default = Transition;\\nexports.default = _default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"_inheritsLoose\",\"subClass\",\"superClass\",\"prototype\",\"Object\",\"create\",\"constructor\",\"__proto__\",\"noop\",\"EXITING\",\"ENTERED\",\"ENTERING\",\"EXITED\",\"UNMOUNTED\",\"_propTypes\",\"_react\",\"_reactDom\",\"_config\",\"_PropTypes\",\"_TransitionGroupContext\",\"_reflow\",\"Transition\",\"_React$Component\",\"props\",\"context\",\"_this\",\"call\",\"appear\",\"isMounting\",\"enter\",\"appearStatus\",\"in\",\"initialStatus\",\"unmountOnExit\",\"mountOnEnter\",\"state\",\"status\",\"nextCallback\",\"getDerivedStateFromProps\",\"Transition.getDerivedStateFromProps\",\"_ref\",\"prevState\",\"_proto\",\"componentDidMount\",\"_proto.componentDidMount\",\"updateStatus\",\"componentDidUpdate\",\"_proto.componentDidUpdate\",\"prevProps\",\"nextStatus\",\"componentWillUnmount\",\"_proto.componentWillUnmount\",\"cancelNextCallback\",\"getTimeouts\",\"_proto.getTimeouts\",\"timeout\",\"exit\",\"undefined\",\"_proto.updateStatus\",\"mounting\",\"node\",\"nodeRef\",\"current\",\"findDOMNode\",\"forceReflow\",\"performEnter\",\"performExit\",\"setState\",\"_proto.performEnter\",\"_this2\",\"appearing\",\"_ref2\",\"maybeNode\",\"maybeAppearing\",\"timeouts\",\"enterTimeout\",\"disabled\",\"safeSetState\",\"onEntered\",\"onEnter\",\"onEntering\",\"onTransitionEnd\",\"_proto.performExit\",\"_this3\",\"onExited\",\"onExit\",\"onExiting\",\"_proto.cancelNextCallback\",\"cancel\",\"_proto.safeSetState\",\"nextState\",\"callback\",\"setNextCallback\",\"_proto.setNextCallback\",\"_this4\",\"active\",\"this.nextCallback\",\"event\",\"this.nextCallback.cancel\",\"_proto.onTransitionEnd\",\"handler\",\"doesNotHaveTimeoutOrListener\",\"addEndListener\",\"setTimeout\",\"_ref3\",\"maybeNextCallback\",\"render\",\"_proto.render\",\"_this$props\",\"children\",\"target\",\"sourceKeys\",\"keys\",\"i\",\"length\",\"key\",\"excluded\",\"indexOf\",\"createElement\",\"Provider\",\"value\",\"childProps\",\"cloneElement\",\"Children\",\"only\",\"Component\",\"contextType\",\"propTypes\",\"shape\",\"Element\",\"any\",\"propValue\",\"componentName\",\"location\",\"propFullName\",\"secret\",\"instanceOf\",\"ownerDocument\",\"defaultView\",\"oneOfType\",\"func\",\"isRequired\",\"element\",\"bool\",\"pt\",\"timeoutsShape\",\"_len\",\"arguments\",\"args\",\"Array\",\"_key\",\"apply\",\"concat\",\"defaultProps\"]\n}\n"]