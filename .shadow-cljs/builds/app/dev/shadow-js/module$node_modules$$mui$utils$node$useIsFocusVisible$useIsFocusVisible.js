["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@mui/utils/node/useIsFocusVisible/useIsFocusVisible.js"],"~:js","shadow$provide.module$node_modules$$mui$utils$node$useIsFocusVisible$useIsFocusVisible = function(global, require, module, exports) {\n  function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) {\n      return null;\n    }\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function(e) {\n      return e ? t : r;\n    })(e);\n  }\n  function handleKeyDown(event) {\n    event.metaKey || event.altKey || event.ctrlKey || (hadKeyboardEvent = !0);\n  }\n  function handlePointerDown() {\n    hadKeyboardEvent = !1;\n  }\n  function handleVisibilityChange() {\n    \"hidden\" === this.visibilityState && hadFocusVisibleRecently && (hadKeyboardEvent = !0);\n  }\n  \"use client\";\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.default = function() {\n    const ref = React.useCallback(node => {\n      null != node && (node = node.ownerDocument, node.addEventListener(\"keydown\", handleKeyDown, !0), node.addEventListener(\"mousedown\", handlePointerDown, !0), node.addEventListener(\"pointerdown\", handlePointerDown, !0), node.addEventListener(\"touchstart\", handlePointerDown, !0), node.addEventListener(\"visibilitychange\", handleVisibilityChange, !0));\n    }, []), isFocusVisibleRef = React.useRef(!1);\n    return {isFocusVisibleRef, onFocus:function(event) {\n      a: {\n        ({target:event} = event);\n        try {\n          var JSCompiler_inline_result = event.matches(\":focus-visible\");\n          break a;\n        } catch (error) {\n        }\n        if (!(JSCompiler_inline_result = hadKeyboardEvent)) {\n          const {type, tagName} = event;\n          JSCompiler_inline_result = \"INPUT\" === tagName && inputTypesWhitelist[type] && !event.readOnly || \"TEXTAREA\" === tagName && !event.readOnly || event.isContentEditable ? !0 : !1;\n        }\n      }\n      return JSCompiler_inline_result ? isFocusVisibleRef.current = !0 : !1;\n    }, onBlur:function() {\n      return isFocusVisibleRef.current ? (hadFocusVisibleRecently = !0, hadFocusVisibleRecentlyTimeout.start(100, () => {\n        hadFocusVisibleRecently = !1;\n      }), isFocusVisibleRef.current = !1, !0) : !1;\n    }, ref};\n  };\n  exports.teardown = function(doc) {\n    doc.removeEventListener(\"keydown\", handleKeyDown, !0);\n    doc.removeEventListener(\"mousedown\", handlePointerDown, !0);\n    doc.removeEventListener(\"pointerdown\", handlePointerDown, !0);\n    doc.removeEventListener(\"touchstart\", handlePointerDown, !0);\n    doc.removeEventListener(\"visibilitychange\", handleVisibilityChange, !0);\n  };\n  var React = function(e, r) {\n    if (!r && e && e.__esModule) {\n      return e;\n    }\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) {\n      return {default:e};\n    }\n    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {\n      return r.get(e);\n    }\n    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;\n    for (u in e) {\n      if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n      }\n    }\n    return n.default = e, r && r.set(e, n), n;\n  }(require(\"module$node_modules$react$index\"));\n  let hadKeyboardEvent = !0, hadFocusVisibleRecently = !1;\n  const hadFocusVisibleRecentlyTimeout = new (require(\"module$node_modules$$mui$utils$node$useTimeout$useTimeout\").Timeout)(), inputTypesWhitelist = {text:!0, search:!0, url:!0, tel:!0, email:!0, password:!0, number:!0, date:!0, month:!0, week:!0, time:!0, datetime:!0, \"datetime-local\":!0};\n};\n","~:source","shadow$provide[\"module$node_modules$$mui$utils$node$useIsFocusVisible$useIsFocusVisible\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useIsFocusVisible;\nexports.teardown = teardown;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useTimeout = require(\"../useTimeout/useTimeout\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nconst hadFocusVisibleRecentlyTimeout = new _useTimeout.Timeout();\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @returns {boolean}\n */\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n  if (node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\n\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\nfunction isFocusVisible(event) {\n  const {\n    target\n  } = event;\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {\n    // Browsers not implementing :focus-visible will throw a SyntaxError.\n    // We use our own heuristic for those browsers.\n    // Rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  }\n\n  // No need for validFocusTarget check. The user does that by attaching it to\n  // focusable events only.\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\nfunction useIsFocusVisible() {\n  const ref = React.useCallback(node => {\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  const isFocusVisibleRef = React.useRef(false);\n\n  /**\n   * Should be called if a blur event is fired\n   */\n  function handleBlurVisible() {\n    // checking against potential state variable does not suffice if we focus and blur synchronously.\n    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\n    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\n    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\n    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\n    if (isFocusVisibleRef.current) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      hadFocusVisibleRecentlyTimeout.start(100, () => {\n        hadFocusVisibleRecently = false;\n      });\n      isFocusVisibleRef.current = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Should be called if a blur event is fired\n   */\n  function handleFocusVisible(event) {\n    if (isFocusVisible(event)) {\n      isFocusVisibleRef.current = true;\n      return true;\n    }\n    return false;\n  }\n  return {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$mui$utils$node$useTimeout$useTimeout","~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["isFocusVisibleRef","url","__esModule","tel","email","teardown","value","onFocus","text","number","week","current","time","datetime","onBlur","ref","__proto__","password","date","month","search","default"]],"~:compiled-at",1712152510641,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$mui$utils$node$useIsFocusVisible$useIsFocusVisible.js\",\n\"lineCount\":75,\n\"mappings\":\"AAAAA,cAAA,CAAA,uEAAA,GAA4F,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAYpIC,UAASA,yBAAwB,CAACC,CAAD,CAAI;AAAE,QAAI,UAAJ,IAAkB,MAAOC,QAAzB;AAAkC,aAAO,IAAP;AAAlC;AAAF,QAAqDC,IAAI,IAAID,OAAJ,EAAzD,EAAwEE,IAAI,IAAIF,OAAJ,EAA5E;AAA2F,WAAO,CAACF,wBAAD,GAA4BA,QAAS,CAACC,CAAD,CAAI;AAAE,aAAOA,CAAA,GAAIG,CAAJ,GAAQD,CAAf;AAAF,KAAzC,EAAgEF,CAAhE,CAAP;AAA3F;AAoDrCI,UAASA,cAAa,CAACC,KAAD,CAAQ;AACxBA,SAAMC,CAAAA,OAAV,IAAqBD,KAAME,CAAAA,MAA3B,IAAqCF,KAAMG,CAAAA,OAA3C,KAGAC,gBAHA,GAGmB,CAAA,CAHnB;AAD4B;AAc9BC,UAASA,kBAAiB,EAAG;AAC3BD,oBAAA,GAAmB,CAAA,CAAnB;AAD2B;AAG7BE,UAASA,uBAAsB,EAAG;AACH,YAA7B,KAAI,IAAKC,CAAAA,eAAT,IAKMC,uBALN,KAMIJ,gBANJ,GAMuB,CAAA,CANvB;AADgC;AA/ElC,cAAA;AAGAK,QAAOC,CAAAA,cAAP,CAAsBjB,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CkB,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAlB,SAAQmB,CAAAA,OAAR,GAmHAC,QAA0B,EAAG;AAC3B,UAAMC,MAAMC,KAAMC,CAAAA,WAAN,CAAkBC,IAAA,IAAQ;AACxB,UAAZ,IAAIA,IAAJ,KACeC,IA7BjB,GA6BYD,IAAKC,CAAAA,aA7BjB,EAJAC,IAAIC,CAAAA,gBAAJ,CAAqB,SAArB,EAAgCrB,aAAhC,EAA+C,CAAA,CAA/C,CAIA,EAHAoB,IAAIC,CAAAA,gBAAJ,CAAqB,WAArB,EAAkCf,iBAAlC,EAAqD,CAAA,CAArD,CAGA,EAFAc,IAAIC,CAAAA,gBAAJ,CAAqB,aAArB,EAAoCf,iBAApC,EAAuD,CAAA,CAAvD,CAEA,EADAc,IAAIC,CAAAA,gBAAJ,CAAqB,YAArB,EAAmCf,iBAAnC,EAAsD,CAAA,CAAtD,CACA,EAAAc,IAAIC,CAAAA,gBAAJ,CAAqB,kBAArB,EAAyCd,sBAAzC,EAAiE,CAAA,CAAjE,CA4BE;AADoC,KAA1B,EAIT,EAJS,CAAZ,EAKMe,oBAAoBN,KAAMO,CAAAA,MAAN,CAAa,CAAA,CAAb,CAL1B;AAyCA,WAAO,CACLD,iBADK,EAELE,QATFC,QAA2B,CAACxB,KAAD,CAAQ;AApDN,OAAA,CAAA;AAC7B,SAAM,CACJ,OAAAyB,KADI,CAAN,GAoDqBzB,KApDrB;AAGA,WAAI;AACF,cAAA,2BAAOyB,KAAOC,CAAAA,OAAP,CAAe,gBAAf,CAAP;AAAA,gBAAA,CAAA;AADE,SAEF,QAAOC,KAAP,CAAc;;AAST,YAAAvB,EAAAA,wBAAAA,GAAAA,gBAAAA,CAAA,CAAA;AAhFP,gBAAM,CACJwB,IADI,EAEJC,OAFI,CAAA,GAgFqBZ,KAhF3B;AAUA,kCAAA,GANgB,OAMhB,KANIY,OAMJ,IAN2BC,mBAAA,CAAoBF,IAApB,CAM3B,IANwD,CA4E7BX,KA5EmCc,CAAAA,QAM9D,IAHgB,UAGhB,KAHIF,OAGJ,IAH8B,CAyEHZ,KAzESc,CAAAA,QAGpC,IAsE2Bd,KAtElBe,CAAAA,iBAAT,GACS,CAAA,CADT,GAGO,CAAA,CAHP;AAsEO;AAfsB;AAqD3B,aAAI,wBAAJ,GACEX,iBAAkBY,CAAAA,OADpB,GAC8B,CAAA,CAD9B,GAIO,CAAA,CAJP;AADiC,KAO5B,EAGLC,OAlCFC,QAA0B,EAAG;AAM3B,aAAId,iBAAkBY,CAAAA,OAAtB,IAKEzB,uBAKO,GALmB,CAAA,CAKnB,EAJP4B,8BAA+BC,CAAAA,KAA/B,CAAqC,GAArC,EAA0C,EAAA,IAAM;AAC9C7B,+BAAA,GAA0B,CAAA,CAA1B;AAD8C,OAAhD,CAIO,EADPa,iBAAkBY,CAAAA,OACX,GADqB,CAAA,CACrB,EAAA,CAAA,CAVT,IAYO,CAAA,CAZP;AAN2B,KA+BtB,EAILnB,GAJK,CAAP;AA1C2B,GAnH7B;AACArB,SAAQ6C,CAAAA,QAAR,GA0FAA,QAAiB,CAACnB,GAAD,CAAM;AACrBA,OAAIoB,CAAAA,mBAAJ,CAAwB,SAAxB,EAAmCxC,aAAnC,EAAkD,CAAA,CAAlD,CAAA;AACAoB,OAAIoB,CAAAA,mBAAJ,CAAwB,WAAxB,EAAqClC,iBAArC,EAAwD,CAAA,CAAxD,CAAA;AACAc,OAAIoB,CAAAA,mBAAJ,CAAwB,aAAxB,EAAuClC,iBAAvC,EAA0D,CAAA,CAA1D,CAAA;AACAc,OAAIoB,CAAAA,mBAAJ,CAAwB,YAAxB,EAAsClC,iBAAtC,EAAyD,CAAA,CAAzD,CAAA;AACAc,OAAIoB,CAAAA,mBAAJ,CAAwB,kBAAxB,EAA4CjC,sBAA5C,EAAoE,CAAA,CAApE,CAAA;AALqB,GA1FvB;AACA,MAAIS,QAGJyB,QAAgC,CAAC7C,CAAD,EAAIE,CAAJ,CAAO;AAAE,QAAI,CAACA,CAAL,IAAUF,CAAV,IAAeA,CAAE8C,CAAAA,UAAjB;AAA6B,aAAO9C,CAAP;AAA7B;AAAuC,QAAI,IAAJ,KAAaA,CAAb,IAAkB,QAAlB,IAA8B,MAAOA,EAArC,IAA0C,UAA1C,IAAwD,MAAOA,EAA/D;AAAkE,aAAO,CAAEiB,QAASjB,CAAX,CAAP;AAAlE;AAA8H,SAAjCG,CAAiC,GAA7BJ,wBAAA,CAAyBG,CAAzB,CAA6B,KAASC,CAAE4C,CAAAA,GAAF,CAAM/C,CAAN,CAAT;AAAmB,aAAOG,CAAE6C,CAAAA,GAAF,CAAMhD,CAAN,CAAP;AAAnB;AAAvK,QAA+MiD,IAAI,CAAEC,UAAW,IAAb,CAAnN,EAAwOC,IAAIrC,MAAOC,CAAAA,cAAXoC,IAA6BrC,MAAOsC,CAAAA,wBAA5Q,EAA+SC,CAA/S;AAAsS,SAASA,CAAT,GAAcrD,EAAd;AAAiB,UAAI,SAAJ,KAAkBqD,CAAlB,IAAuBvC,MAAOwC,CAAAA,SAAUC,CAAAA,cAAeC,CAAAA,IAAhC,CAAqCxD,CAArC,EAAwCqD,CAAxC,CAAvB,CAAmE;AAAE,YAAII,IAAIN,CAAA,GAAIrC,MAAOsC,CAAAA,wBAAP,CAAgCpD,CAAhC,EAAmCqD,CAAnC,CAAJ,GAA4C,IAApD;AAA0DI,SAAA,KAAMA,CAAET,CAAAA,GAAR,IAAeS,CAAEC,CAAAA,GAAjB,IAAwB5C,MAAOC,CAAAA,cAAP,CAAsBkC,CAAtB,EAAyBI,CAAzB,EAA4BI,CAA5B,CAAxB,GAAyDR,CAAA,CAAEI,CAAF,CAAzD,GAAgErD,CAAA,CAAEqD,CAAF,CAAhE;AAA5D;AAApF;AAAwN,WAAOJ,CAAEhC,CAAAA,OAAF,GAAYjB,CAAZ,EAAeG,CAAf,IAAoBA,CAAEuD,CAAAA,GAAF,CAAM1D,CAAN,EAASiD,CAAT,CAApB,EAAiCA,CAAxC;AAA9f,GAH3B,CAAwBrD,OAAA,CAAQ,iCAAR,CAAxB,CAAZ;AAIA,MAAIa,mBAAmB,CAAA,CAAvB,EACII,0BAA0B,CAAA,CAD9B;AAEA,QAAM4B,iCAAiC,KALrB7C,OAAA+D,CAAQ,2DAARA,CAKqCC,CAAAA,OAAhB,GAAvC,EACMzB,sBAAsB,CAC1B0B,KAAM,CAAA,CADoB,EAE1BC,OAAQ,CAAA,CAFkB,EAG1BC,IAAK,CAAA,CAHqB,EAI1BC,IAAK,CAAA,CAJqB,EAK1BC,MAAO,CAAA,CALmB,EAM1BC,SAAU,CAAA,CANgB,EAO1BC,OAAQ,CAAA,CAPkB,EAQ1BC,KAAM,CAAA,CARoB,EAS1BC,MAAO,CAAA,CATmB,EAU1BC,KAAM,CAAA,CAVoB,EAW1BC,KAAM,CAAA,CAXoB,EAY1BC,SAAU,CAAA,CAZgB,EAa1B,iBAAkB,CAAA,CAbQ,CAD5B;AAhBoI,CAApI;;\",\n\"sources\":[\"node_modules/@mui/utils/node/useIsFocusVisible/useIsFocusVisible.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$mui$utils$node$useIsFocusVisible$useIsFocusVisible\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n'use client';\\n\\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = useIsFocusVisible;\\nexports.teardown = teardown;\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\nvar _useTimeout = require(\\\"../useTimeout/useTimeout\\\");\\nfunction _getRequireWildcardCache(e) { if (\\\"function\\\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \\\"object\\\" != typeof e && \\\"function\\\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\\\"default\\\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\\nlet hadKeyboardEvent = true;\\nlet hadFocusVisibleRecently = false;\\nconst hadFocusVisibleRecentlyTimeout = new _useTimeout.Timeout();\\nconst inputTypesWhitelist = {\\n  text: true,\\n  search: true,\\n  url: true,\\n  tel: true,\\n  email: true,\\n  password: true,\\n  number: true,\\n  date: true,\\n  month: true,\\n  week: true,\\n  time: true,\\n  datetime: true,\\n  'datetime-local': true\\n};\\n\\n/**\\n * Computes whether the given element should automatically trigger the\\n * `focus-visible` class being added, i.e. whether it should always match\\n * `:focus-visible` when focused.\\n * @param {Element} node\\n * @returns {boolean}\\n */\\nfunction focusTriggersKeyboardModality(node) {\\n  const {\\n    type,\\n    tagName\\n  } = node;\\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\\n    return true;\\n  }\\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\\n    return true;\\n  }\\n  if (node.isContentEditable) {\\n    return true;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\\n * If the most recent user interaction was via the keyboard;\\n * and the key press did not include a meta, alt/option, or control key;\\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\\n * @param {KeyboardEvent} event\\n */\\nfunction handleKeyDown(event) {\\n  if (event.metaKey || event.altKey || event.ctrlKey) {\\n    return;\\n  }\\n  hadKeyboardEvent = true;\\n}\\n\\n/**\\n * If at any point a user clicks with a pointing device, ensure that we change\\n * the modality away from keyboard.\\n * This avoids the situation where a user presses a key on an already focused\\n * element, and then clicks on a different element, focusing it with a\\n * pointing device, while we still think we're in keyboard modality.\\n */\\nfunction handlePointerDown() {\\n  hadKeyboardEvent = false;\\n}\\nfunction handleVisibilityChange() {\\n  if (this.visibilityState === 'hidden') {\\n    // If the tab becomes active again, the browser will handle calling focus\\n    // on the element (Safari actually calls it twice).\\n    // If this tab change caused a blur on an element with focus-visible,\\n    // re-apply the class when the user switches back to the tab.\\n    if (hadFocusVisibleRecently) {\\n      hadKeyboardEvent = true;\\n    }\\n  }\\n}\\nfunction prepare(doc) {\\n  doc.addEventListener('keydown', handleKeyDown, true);\\n  doc.addEventListener('mousedown', handlePointerDown, true);\\n  doc.addEventListener('pointerdown', handlePointerDown, true);\\n  doc.addEventListener('touchstart', handlePointerDown, true);\\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\\n}\\nfunction teardown(doc) {\\n  doc.removeEventListener('keydown', handleKeyDown, true);\\n  doc.removeEventListener('mousedown', handlePointerDown, true);\\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\\n  doc.removeEventListener('touchstart', handlePointerDown, true);\\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\\n}\\nfunction isFocusVisible(event) {\\n  const {\\n    target\\n  } = event;\\n  try {\\n    return target.matches(':focus-visible');\\n  } catch (error) {\\n    // Browsers not implementing :focus-visible will throw a SyntaxError.\\n    // We use our own heuristic for those browsers.\\n    // Rethrow might be better if it's not the expected error but do we really\\n    // want to crash if focus-visible malfunctioned?\\n  }\\n\\n  // No need for validFocusTarget check. The user does that by attaching it to\\n  // focusable events only.\\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\\n}\\nfunction useIsFocusVisible() {\\n  const ref = React.useCallback(node => {\\n    if (node != null) {\\n      prepare(node.ownerDocument);\\n    }\\n  }, []);\\n  const isFocusVisibleRef = React.useRef(false);\\n\\n  /**\\n   * Should be called if a blur event is fired\\n   */\\n  function handleBlurVisible() {\\n    // checking against potential state variable does not suffice if we focus and blur synchronously.\\n    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\\n    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\\n    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\\n    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\\n    if (isFocusVisibleRef.current) {\\n      // To detect a tab/window switch, we look for a blur event followed\\n      // rapidly by a visibility change.\\n      // If we don't see a visibility change within 100ms, it's probably a\\n      // regular focus change.\\n      hadFocusVisibleRecently = true;\\n      hadFocusVisibleRecentlyTimeout.start(100, () => {\\n        hadFocusVisibleRecently = false;\\n      });\\n      isFocusVisibleRef.current = false;\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Should be called if a blur event is fired\\n   */\\n  function handleFocusVisible(event) {\\n    if (isFocusVisible(event)) {\\n      isFocusVisibleRef.current = true;\\n      return true;\\n    }\\n    return false;\\n  }\\n  return {\\n    isFocusVisibleRef,\\n    onFocus: handleFocusVisible,\\n    onBlur: handleBlurVisible,\\n    ref\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_getRequireWildcardCache\",\"e\",\"WeakMap\",\"r\",\"t\",\"handleKeyDown\",\"event\",\"metaKey\",\"altKey\",\"ctrlKey\",\"hadKeyboardEvent\",\"handlePointerDown\",\"handleVisibilityChange\",\"visibilityState\",\"hadFocusVisibleRecently\",\"Object\",\"defineProperty\",\"value\",\"default\",\"useIsFocusVisible\",\"ref\",\"React\",\"useCallback\",\"node\",\"ownerDocument\",\"doc\",\"addEventListener\",\"isFocusVisibleRef\",\"useRef\",\"onFocus\",\"handleFocusVisible\",\"target\",\"matches\",\"error\",\"type\",\"tagName\",\"inputTypesWhitelist\",\"readOnly\",\"isContentEditable\",\"current\",\"onBlur\",\"handleBlurVisible\",\"hadFocusVisibleRecentlyTimeout\",\"start\",\"teardown\",\"removeEventListener\",\"_interopRequireWildcard\",\"__esModule\",\"has\",\"get\",\"n\",\"__proto__\",\"a\",\"getOwnPropertyDescriptor\",\"u\",\"prototype\",\"hasOwnProperty\",\"call\",\"i\",\"set\",\"_useTimeout\",\"Timeout\",\"text\",\"search\",\"url\",\"tel\",\"email\",\"password\",\"number\",\"date\",\"month\",\"week\",\"time\",\"datetime\"]\n}\n"]